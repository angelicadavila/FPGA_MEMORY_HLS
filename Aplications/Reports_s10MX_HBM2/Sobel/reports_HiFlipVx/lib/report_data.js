var areaJSON='{"columns":["", "ALUTs", "FFs", "RAMs", "DSPs", "MLABs", "Details"], "debug_enabled":"true", "type":"module", "total_percent":[3.647, 1.79205, 1.94372, 0.631345, 0], "total":[24784, 72549, 74, 0, 433], "name":"System", "max_resources":[1866240, 3732480, 11721, 5760, 93312], "children":[{"name":"ImgSobelFunc", "compute_units":1, "type":"function", "total_percent":[0.0296605, 0.0258809, 0.00715342, 0, 0], "total_kernel_resources":[203, 267, 0, 0, 14], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Component call", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 192 bits wide with a buffer size of 0 elements."}, {"type":"brief", "text":"192b wide with 0 elements."}]}, {"name":"Component return", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 1 bit wide with a buffer size of 0 elements."}, {"type":"brief", "text":"1b wide with 0 elements."}]}, {"name":"ImgSobelFunc.B1.start", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[5, 16, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[5, 16, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[16, 9, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[9, 2, 0, 0, 0]}, {"name":"sobel.h:30", "type":"resource", "data":[7, 7, 0, 0, 0], "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[146, 230, 0, 0, 14], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}]}, {"name":"sobel.h:30", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]], "children":[{"name":"Stream Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"sobel.h:34 > link_OpenCLIntel.h:144 > \\ntask.h:85 > task.h:54 > \\n_task_FPGA.h:43", "type":"resource", "data":[4.36667, 2.5, 0, 0, 0], "debug":[[{"filename":"./graph_test/sobel.h", "line":34}, {"filename":"./include/link_OpenCLIntel.h", "line":144}]], "children":[{"name":"1-bit Or", "type":"resource", "count":6, "data":[1.36667, 0.5, 0, 0, 0]}, {"name":"Stream Write", "type":"resource", "count":1, "data":[3, 2, 0, 0, 0]}], "replace_name":"true"}, {"name":"sobel.h:39 > img_filter_base_intel.h:24 > \\ntask.h:85 > task.h:54 > \\n_task_FPGA.h:43", "type":"resource", "data":[5.36667, 2.5, 0, 0, 0], "debug":[[{"filename":"./graph_test/sobel.h", "line":39}, {"filename":"./include/img_filter_base_intel.h", "line":24}]], "children":[{"name":"1-bit Or", "type":"resource", "count":7, "data":[2.36667, 0.5, 0, 0, 0]}, {"name":"Stream Write", "type":"resource", "count":1, "data":[3, 2, 0, 0, 0]}], "replace_name":"true"}, {"name":"sobel.h:42 > link_OpenCLIntel.h:156 > \\ntask.h:85 > task.h:54 > \\n_task_FPGA.h:43", "type":"resource", "data":[5.36667, 2.5, 0, 0, 0], "debug":[[{"filename":"./graph_test/sobel.h", "line":42}, {"filename":"./include/link_OpenCLIntel.h", "line":156}]], "children":[{"name":"1-bit Or", "type":"resource", "count":7, "data":[2.36667, 0.5, 0, 0, 0]}, {"name":"Stream Write", "type":"resource", "count":1, "data":[3, 2, 0, 0, 0]}], "replace_name":"true"}, {"name":"sobel.h:45 > link_OpenCLIntel.h:156 > \\ntask.h:85 > task.h:54 > \\n_task_FPGA.h:43", "type":"resource", "data":[4.7, 2.16667, 0, 0, 0], "debug":[[{"filename":"./graph_test/sobel.h", "line":45}, {"filename":"./include/link_OpenCLIntel.h", "line":156}]], "children":[{"name":"1-bit Or", "type":"resource", "count":5, "data":[1.7, 0.166667, 0, 0, 0]}, {"name":"Stream Write", "type":"resource", "count":1, "data":[3, 2, 0, 0, 0]}], "replace_name":"true"}, {"name":"sobel.h:47 > img_filter_base_intel.h:30 > \\ntask.h:95 > task.h:61 > \\n_task_FPGA.h:48", "type":"resource", "data":[4.7, 0.166667, 0, 0, 0], "debug":[[{"filename":"./graph_test/sobel.h", "line":47}, {"filename":"./include/img_filter_base_intel.h", "line":30}]], "children":[{"name":"1-bit Or", "type":"resource", "count":4, "data":[0.7, 0.166667, 0, 0, 0]}, {"name":"Stream Read", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"sobel.h:49 > link_OpenCLIntel.h:159 > \\ntask.h:95 > task.h:61 > \\n_task_FPGA.h:48", "type":"resource", "data":[3.5, 0.166667, 0, 0, 0], "debug":[[{"filename":"./graph_test/sobel.h", "line":49}, {"filename":"./include/link_OpenCLIntel.h", "line":159}]], "children":[{"name":"1-bit Or", "type":"resource", "count":3, "data":[0.5, 0.166667, 0, 0, 0]}, {"name":"Stream Read", "type":"resource", "count":1, "data":[3, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"sobel.h:50 > link_OpenCLIntel.h:159 > \\ntask.h:95 > task.h:61 > \\n_task_FPGA.h:48", "type":"resource", "data":[3, 0, 0, 0, 0], "debug":[[{"filename":"./graph_test/sobel.h", "line":50}, {"filename":"./include/link_OpenCLIntel.h", "line":159}]], "children":[{"name":"Stream Read", "type":"resource", "count":1, "data":[3, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"sobel.h:51", "type":"resource", "data":[3, 2, 0, 0, 0], "debug":[[{"filename":"./graph_test/sobel.h", "line":51}]], "children":[{"name":"Stream Write", "type":"resource", "count":1, "data":[3, 2, 0, 0, 0]}], "replace_name":"true"}]}]}]}, {"name":"ImgSobelIntel", "compute_units":1, "type":"function", "total_percent":[0.583526, 0.383123, 0.237215, 0.162102, 0], "total_kernel_resources":[5650, 8854, 19, 0, 75], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Coalesced Variables: \\n - \'window\' (img_filter_core.h:1881)\\n - \'kernel_window\' (img_filter_core.h:1489)", "type":"resource", "data":[62, 140, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_core.h", "line":1489}], [{"filename":"./include/img_filter_core.h", "line":1881}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"6 registers of width 8 and depth 1"}, {"type":"brief", "text":"Register,\\n6 regs, 8 width by 1 depth"}]}, {"name":"Stream \'streamX_1_2\'", "type":"resource", "data":[46, 38, 1, 0, 0], "details":[{"type":"text", "text":"Stream implemented 64 bits wide with a buffer size of 256 elements."}, {"type":"brief", "text":"64b wide with 256 elements."}]}, {"name":"Stream \'streamY_1_2\'", "type":"resource", "data":[46, 38, 1, 0, 0], "details":[{"type":"text", "text":"Stream implemented 64 bits wide with a buffer size of 256 elements."}, {"type":"brief", "text":"64b wide with 256 elements."}]}, {"name":"Stream \'stream_r_0\'", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 64 bits wide with a buffer size of 0 elements."}, {"type":"brief", "text":"64b wide with 0 elements."}, {"type":"text", "text":"Requested buffer size was 256. The buffer size differs from the value in the source code for the following reason:", "details":[{"type":"text", "text":"instruction scheduling requirements"}]}]}, {"name":"Task call", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 1 bit wide with a buffer size of 0 elements."}, {"type":"brief", "text":"1b wide with 0 elements."}]}, {"name":"Task return", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 1 bit wide with a buffer size of 0 elements."}, {"type":"brief", "text":"1b wide with 0 elements."}]}, {"name":"Variable: \\n - \'window\' (img_filter_core.h:1881)", "type":"resource", "data":[147, 252, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_core.h", "line":1881}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"21 registers of width 8 and depth 1"}, {"type":"brief", "text":"Register,\\n21 regs, 8 width by 1 depth"}]}, {"name":"Variable: \\n - \'x\' (img_filter_core.h:1890)", "type":"resource", "data":[23, 67, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_core.h", "line":1890}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 10 and depth 1"}, {"type":"text", "text":"1 register of width 16 and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 10 width by 1 depth,\\n1 reg, 16 width by 1 depth"}]}, {"name":"Variable: \\n - \'y\' (img_filter_core.h:1888)", "type":"resource", "data":[16, 58, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_core.h", "line":1888}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 13"}, {"type":"text", "text":"1 register of width 16"}, {"type":"brief", "text":"Register,\\n1 reg, 13 width,\\n1 reg, 16 width"}]}, {"name":"img_filter_core.h:1874 (linebuffer)", "type":"resource", "data":[0, 0, 8, 0, 0], "debug":[[{"filename":"./include/img_filter_core.h", "line":1874}]], "details":[{"type":"table", "Memory system":"Potentially inefficient configuration", "Requested size":"7680 bytes", "Implemented size":"8192 bytes", "Number of banks":"4 (banked on bits 11, 12)", "Bank width":"32 bits", "Bank depth":"512 words", "Total replication":"1", "Additional information":[{"type":"text", "text":"Requested size 7680 bytes, implemented size 8192 bytes, <b>stallable</b>, 4 reads and 4 writes. ", "details":[{"type":"text", "text":"Reduce the number of write accesses or fix banking to make this memory system stall-free. Banking may be improved by using compile-time known indexing on lowest array dimension."}]}, {"type":"text", "text":"Banked on bits 11, 12 into 4 separate banks."}]}, {"type":"brief", "text":"Potentially inefficient configuration,\\n7680B requested,\\n8192B implemented."}]}, {"name":"ImgSobelIntel.B1.start", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[1, 7, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1, 7, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[24, 11, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[9, 2, 0, 0, 0]}, {"name":"img_filter_base_intel.h:10", "type":"resource", "data":[7, 7, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":10}]]}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1929 > \\nimg_filter_core.h:69", "type":"resource", "data":[8, 2, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1929}, {"filename":"./include/img_filter_core.h", "line":69}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[13, 9, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}]}, {"name":"img_filter_base_intel.h:10", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":10}]], "children":[{"name":"Stream Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"ImgSobelIntel.B2", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[20, 61, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[20, 61, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[111, 27, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1881", "type":"resource", "data":[7, 0, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1881}]]}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1888", "type":"resource", "data":[24, 9, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1888}]]}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1929 > \\nimg_filter_core.h:69", "type":"resource", "data":[44, 10, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1929}, {"filename":"./include/img_filter_core.h", "line":69}]]}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1935 > \\nimg_filter_core.h:169", "type":"resource", "data":[36, 8, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1935}, {"filename":"./include/img_filter_core.h", "line":169}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[33, 29, 0, 0, 2], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1888", "type":"resource", "data":[34, 0, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1888}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"13-bit Integer Add", "type":"resource", "count":1, "data":[13, 0, 0, 0, 0]}, {"name":"13-bit Integer Compare", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}, {"name":"16-bit Integer Add", "type":"resource", "count":1, "data":[16, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1917", "type":"resource", "data":[19, 1, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1917}]], "children":[{"name":"16-bit Integer Compare", "type":"resource", "count":1, "data":[19, 1, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1932 > \\nimg_filter_core.h:583 > img_filter_core.h:313", "type":"resource", "data":[19, 1, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1932}, {"filename":"./include/img_filter_core.h", "line":583}, {"filename":"./include/img_filter_core.h", "line":313}]], "children":[{"name":"16-bit Integer Compare", "type":"resource", "count":1, "data":[19, 1, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1941", "type":"resource", "data":[5, 0, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1941}]], "children":[{"name":"16-bit Integer Compare", "type":"resource", "count":1, "data":[5, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"ImgSobelIntel.B3", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[27, 19, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1929 > \\nimg_filter_core.h:69", "type":"resource", "data":[27, 19, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1929}, {"filename":"./include/img_filter_core.h", "line":69}]]}]}]}, {"name":"ImgSobelIntel.B4", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[387, 2942, 9, 0, 13], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[387, 2942, 9, 0, 13]}]}, {"name":"Feedback", "type":"resource", "data":[212, 117, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[14, 0, 0, 0, 0]}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1881", "type":"resource", "data":[14, 0, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1881}]]}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1888", "type":"resource", "data":[24, 15, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1888}]]}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1890", "type":"resource", "data":[8, 7, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1890}]]}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1917", "type":"resource", "data":[8, 5, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1917}]]}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1929 > \\nimg_filter_core.h:69", "type":"resource", "data":[64, 40, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1929}, {"filename":"./include/img_filter_core.h", "line":69}]]}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1932 > \\nimg_filter_core.h:583 > img_filter_core.h:313", "type":"resource", "data":[8, 5, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1932}, {"filename":"./include/img_filter_core.h", "line":583}, {"filename":"./include/img_filter_core.h", "line":313}]]}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1935 > \\nimg_filter_core.h:169", "type":"resource", "data":[64, 40, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1935}, {"filename":"./include/img_filter_core.h", "line":169}]]}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1941", "type":"resource", "data":[8, 5, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1941}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[287, 515, 0, 0, 27], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[2, 2, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}, {"name":"1-bit Or", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}]}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1890", "type":"resource", "data":[29, 0, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1890}]], "children":[{"name":"10-bit Integer Add", "type":"resource", "count":1, "data":[10, 0, 0, 0, 0]}, {"name":"10-bit Integer Compare", "type":"resource", "count":1, "data":[3, 0, 0, 0, 0]}, {"name":"16-bit Integer Add", "type":"resource", "count":1, "data":[16, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1917", "type":"resource", "data":[6, 1, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1917}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"16-bit Integer Compare", "type":"resource", "count":1, "data":[5, 1, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1918 > \\nhls.h:1075", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1918}]], "children":[{"name":"Stream Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1929 > \\nimg_filter_core.h:69", "type":"resource", "data":[996, 880, 0, 0, 16], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1929}, {"filename":"./include/img_filter_core.h", "line":69}]], "children":[{"name":"1-bit Or", "type":"resource", "count":16, "data":[8, 4, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":4, "data":[988, 876, 0, 0, 16], "details":[{"type":"text", "text":"Load uses a Pipelined LSU"}, {"type":"brief", "text":"Pipelined LSU"}, {"type":"text", "text":"Stallable read from memory declared on %L.", "links":[{"filename":"./include/img_filter_core.h", "line":"1874"}]}]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1932 > \\nimg_filter_core.h:583 > img_filter_core.h:313", "type":"resource", "data":[32, 0, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1932}, {"filename":"./include/img_filter_core.h", "line":583}, {"filename":"./include/img_filter_core.h", "line":313}]], "children":[{"name":"8-bit Select", "type":"resource", "count":8, "data":[32, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1932 > \\nimg_filter_core.h:583 > img_filter_core.h:331", "type":"resource", "data":[32, 0, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1932}, {"filename":"./include/img_filter_core.h", "line":583}, {"filename":"./include/img_filter_core.h", "line":331}]], "children":[{"name":"8-bit Select", "type":"resource", "count":8, "data":[32, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1932 > \\nimg_filter_core.h:586 > img_filter_core.h:369", "type":"resource", "data":[21, 16, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1932}, {"filename":"./include/img_filter_core.h", "line":586}, {"filename":"./include/img_filter_core.h", "line":369}]], "children":[{"name":"16-bit Integer Compare", "type":"resource", "count":1, "data":[5, 0, 0, 0, 0]}, {"name":"8-bit Select", "type":"resource", "count":2, "data":[16, 16, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1932 > \\nimg_filter_core.h:586 > img_filter_core.h:370", "type":"resource", "data":[8, 8, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1932}, {"filename":"./include/img_filter_core.h", "line":586}, {"filename":"./include/img_filter_core.h", "line":370}]], "children":[{"name":"8-bit Select", "type":"resource", "count":1, "data":[8, 8, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1932 > \\nimg_filter_core.h:586 > img_filter_core.h:379", "type":"resource", "data":[67, 1, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1932}, {"filename":"./include/img_filter_core.h", "line":586}, {"filename":"./include/img_filter_core.h", "line":379}]], "children":[{"name":"16-bit Integer Compare", "type":"resource", "count":1, "data":[19, 1, 0, 0, 0]}, {"name":"8-bit Select", "type":"resource", "count":12, "data":[48, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1932 > \\nimg_filter_core.h:586 > img_filter_core.h:380", "type":"resource", "data":[56, 16, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1932}, {"filename":"./include/img_filter_core.h", "line":586}, {"filename":"./include/img_filter_core.h", "line":380}]], "children":[{"name":"8-bit Select", "type":"resource", "count":12, "data":[56, 16, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1935 > \\nimg_filter_core.h:169", "type":"resource", "data":[333, 1091, 0, 0, 16], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1935}, {"filename":"./include/img_filter_core.h", "line":169}]], "children":[{"name":"1-bit Or", "type":"resource", "count":25, "data":[17, 11, 0, 0, 0]}, {"name":"Store", "type":"resource", "count":4, "data":[316, 1080, 0, 0, 16], "details":[{"type":"text", "text":"Store uses a Pipelined LSU"}, {"type":"brief", "text":"Pipelined LSU"}, {"type":"text", "text":"Stallable write to memory declared on %L.", "links":[{"filename":"./include/img_filter_core.h", "line":"1874"}]}]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1513 > img_filter_core.h:1087", "type":"resource", "data":[72, 72, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1938}, {"filename":"./include/img_filter_core.h", "line":1513}, {"filename":"./include/img_filter_core.h", "line":1087}]], "children":[{"name":"unsigned 8-bit x unsigned 8-bit to 9-bit Integer Add", "type":"resource", "count":8, "data":[72, 72, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1513 > img_filter_core.h:1088", "type":"resource", "data":[80, 80, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1938}, {"filename":"./include/img_filter_core.h", "line":1513}, {"filename":"./include/img_filter_core.h", "line":1088}]], "children":[{"name":"unsigned 9-bit x unsigned 8-bit to 10-bit Integer Subtract", "type":"resource", "count":8, "data":[80, 80, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1513 > img_filter_core.h:1089", "type":"resource", "data":[88, 96, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1938}, {"filename":"./include/img_filter_core.h", "line":1513}, {"filename":"./include/img_filter_core.h", "line":1089}]], "children":[{"name":"signed 10-bit x unsigned 8-bit to 12-bit Integer Subtract", "type":"resource", "count":8, "data":[88, 96, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1513 > img_filter_core.h:1092", "type":"resource", "data":[72, 72, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1938}, {"filename":"./include/img_filter_core.h", "line":1513}, {"filename":"./include/img_filter_core.h", "line":1092}]], "children":[{"name":"unsigned 8-bit x unsigned 8-bit to 9-bit Integer Subtract", "type":"resource", "count":8, "data":[72, 72, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1513 > img_filter_core.h:1097", "type":"resource", "data":[544, 536, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1938}, {"filename":"./include/img_filter_core.h", "line":1513}, {"filename":"./include/img_filter_core.h", "line":1097}]], "children":[{"name":"64-bit Integer Add", "type":"resource", "count":8, "data":[544, 536, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1513 > img_filter_core.h:1103", "type":"resource", "data":[136, 134, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1938}, {"filename":"./include/img_filter_core.h", "line":1513}, {"filename":"./include/img_filter_core.h", "line":1103}]], "children":[{"name":"64-bit Integer Add", "type":"resource", "count":2, "data":[136, 134, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1516 > img_filter_core.h:1149", "type":"resource", "data":[72, 72, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1938}, {"filename":"./include/img_filter_core.h", "line":1516}, {"filename":"./include/img_filter_core.h", "line":1149}]], "children":[{"name":"unsigned 8-bit x unsigned 8-bit to 9-bit Integer Add", "type":"resource", "count":8, "data":[72, 72, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1516 > img_filter_core.h:1150", "type":"resource", "data":[80, 80, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1938}, {"filename":"./include/img_filter_core.h", "line":1516}, {"filename":"./include/img_filter_core.h", "line":1150}]], "children":[{"name":"unsigned 9-bit x unsigned 8-bit to 10-bit Integer Subtract", "type":"resource", "count":8, "data":[80, 80, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1516 > img_filter_core.h:1151", "type":"resource", "data":[88, 96, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1938}, {"filename":"./include/img_filter_core.h", "line":1516}, {"filename":"./include/img_filter_core.h", "line":1151}]], "children":[{"name":"signed 10-bit x unsigned 8-bit to 12-bit Integer Subtract", "type":"resource", "count":8, "data":[88, 96, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1516 > img_filter_core.h:1154", "type":"resource", "data":[72, 72, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1938}, {"filename":"./include/img_filter_core.h", "line":1516}, {"filename":"./include/img_filter_core.h", "line":1154}]], "children":[{"name":"unsigned 8-bit x unsigned 8-bit to 9-bit Integer Subtract", "type":"resource", "count":8, "data":[72, 72, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1516 > img_filter_core.h:1159", "type":"resource", "data":[544, 536, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1938}, {"filename":"./include/img_filter_core.h", "line":1516}, {"filename":"./include/img_filter_core.h", "line":1159}]], "children":[{"name":"64-bit Integer Add", "type":"resource", "count":8, "data":[544, 536, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1516 > img_filter_core.h:1165", "type":"resource", "data":[136, 134, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1938}, {"filename":"./include/img_filter_core.h", "line":1516}, {"filename":"./include/img_filter_core.h", "line":1165}]], "children":[{"name":"64-bit Integer Add", "type":"resource", "count":2, "data":[136, 134, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1543", "type":"resource", "data":[250, 245, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1938}, {"filename":"./include/img_filter_core.h", "line":1543}]], "children":[{"name":"64-bit Integer Add", "type":"resource", "count":6, "data":[250, 245, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1547", "type":"resource", "data":[252, 246, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1938}, {"filename":"./include/img_filter_core.h", "line":1547}]], "children":[{"name":"64-bit Integer Add", "type":"resource", "count":6, "data":[252, 246, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1941", "type":"resource", "data":[1, 1, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1941}]], "children":[{"name":"1-bit Or", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1946 > \\nhls.h:1080", "type":"resource", "data":[8, 7, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1946}]], "children":[{"name":"Stream Write", "type":"resource", "count":1, "data":[8, 7, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1952 > \\nhls.h:1080", "type":"resource", "data":[8, 7, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1952}]], "children":[{"name":"Stream Write", "type":"resource", "count":1, "data":[8, 7, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"ImgSobelIntel.B5", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[27, 19, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1929 > \\nimg_filter_core.h:69", "type":"resource", "data":[27, 19, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":11}, {"filename":"./include/img_filter_core.h", "line":2749}, {"filename":"./include/img_filter_core.h", "line":2215}, {"filename":"./include/img_filter_core.h", "line":1929}, {"filename":"./include/img_filter_core.h", "line":69}]]}]}, {"name":"Computation", "type":"resource", "children":[{"name":"img_filter_base_intel.h:12", "type":"resource", "data":[3, 2, 0, 0, 0], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":12}]], "children":[{"name":"Stream Write", "type":"resource", "count":1, "data":[3, 2, 0, 0, 0]}], "replace_name":"true"}]}]}]}, {"name":"vxReadDram", "compute_units":1, "type":"function", "total_percent":[1.84006, 0.802094, 1.05881, 0.145039, 0], "total_kernel_resources":[10569, 39520, 17, 0, 220], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Stream \'stream_r_0\'", "type":"resource", "data":[46, 38, 1, 0, 0], "details":[{"type":"text", "text":"Stream implemented 64 bits wide with a buffer size of 256 elements."}, {"type":"brief", "text":"64b wide with 256 elements."}]}, {"name":"Task call", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 64 bits wide with a buffer size of 0 elements."}, {"type":"brief", "text":"64b wide with 0 elements."}]}, {"name":"Task return", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 1 bit wide with a buffer size of 0 elements."}, {"type":"brief", "text":"1b wide with 0 elements."}]}, {"name":"Variable: \\n - \'i\' (link_OpenCLIntel.h:26)", "type":"resource", "data":[16, 100, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":26}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 18"}, {"type":"text", "text":"1 register of width 32"}, {"type":"brief", "text":"Register,\\n1 reg, 18 width,\\n1 reg, 32 width"}]}, {"name":"Variable: \\n - \'j\' (link_OpenCLIntel.h:38)", "type":"resource", "data":[16, 24, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":38}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 4"}, {"type":"text", "text":"1 register of width 8"}, {"type":"brief", "text":"Register,\\n1 reg, 4 width,\\n1 reg, 8 width"}]}, {"name":"vxReadDram.B1.start", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[1, 135, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1, 135, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[23, 11, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[9, 2, 0, 0, 0]}, {"name":"link_OpenCLIntel.h:20", "type":"resource", "data":[14, 9, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":20}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[20, 14, 0, 0, 2], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}]}, {"name":"link_OpenCLIntel.h:20", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":20}]], "children":[{"name":"Stream Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"vxReadDram.B2", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[31, 181, 1, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[31, 181, 1, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[41, 9, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"link_OpenCLIntel.h:26", "type":"resource", "data":[41, 9, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":26}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[1877, 3727, 0, 0, 187], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"link_OpenCLIntel.h:26", "type":"resource", "data":[57, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":26}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"18-bit Integer Add", "type":"resource", "count":1, "data":[18, 0, 0, 0, 0]}, {"name":"18-bit Integer Compare", "type":"resource", "count":1, "data":[6, 0, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[32, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"link_OpenCLIntel.h:34", "type":"resource", "data":[1858, 13948, 15, 0, 26], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":34}]], "children":[{"name":"Load", "type":"resource", "count":1, "data":[1858, 13948, 15, 0, 26], "details":[{"type":"text", "text":"Load uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}]}]}, {"name":"vxReadDram.B3", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[5, 8, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[5, 8, 0, 0, 0]}]}, {"name":"Cluster logic", "type":"resource", "data":[9, 7, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"link_OpenCLIntel.h:41", "type":"resource", "data":[3, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":41}]], "children":[{"name":"Non-Blocking Stream Write", "type":"resource", "count":1, "data":[3, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"vxReadDram.B5", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[1826, 13935, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1826, 13935, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[3010, 7307, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[2920, 7168, 0, 0, 0]}, {"name":"link_OpenCLIntel.h:26", "type":"resource", "data":[9, 2, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":26}]]}, {"name":"link_OpenCLIntel.h:34", "type":"resource", "data":[59, 128, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":34}]]}, {"name":"link_OpenCLIntel.h:38", "type":"resource", "data":[22, 9, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":38}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[46, 74, 0, 0, 4], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[1664, 0, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"llvm.fpga.case", "type":"resource", "count":8, "data":[1664, 0, 0, 0, 0]}]}, {"name":"link_OpenCLIntel.h:38", "type":"resource", "data":[14, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":38}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"4-bit Integer Add", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}, {"name":"4-bit Integer Compare", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"8-bit Integer Add", "type":"resource", "count":1, "data":[8, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"link_OpenCLIntel.h:39 > hls.h:1080", "type":"resource", "data":[4, 2, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":39}]], "children":[{"name":"Stream Write", "type":"resource", "count":1, "data":[4, 2, 0, 0, 0]}], "replace_name":"true"}]}]}]}, {"name":"vxWriteDram", "compute_units":1, "type":"function", "total_percent":[0.596878, 0.290477, 0.32027, 0.162102, 0], "total_kernel_resources":[4181, 11954, 19, 0, 62], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Stream \'streamY_1_2\'", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 64 bits wide with a buffer size of 0 elements."}, {"type":"brief", "text":"64b wide with 0 elements."}]}, {"name":"Task call", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 64 bits wide with a buffer size of 0 elements."}, {"type":"brief", "text":"64b wide with 0 elements."}]}, {"name":"Task return", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 1 bit wide with a buffer size of 0 elements."}, {"type":"brief", "text":"1b wide with 0 elements."}]}, {"name":"Variable: \\n - \'data\' (link_OpenCLIntel.h:69)", "type":"resource", "data":[399, 740, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":69}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"56 registers of width 8 and depth 1"}, {"type":"text", "text":"1 register of width 64 and depth 1"}, {"type":"brief", "text":"Register,\\n56 regs, 8 width by 1 depth,\\n1 reg, 64 width by 1 depth"}]}, {"name":"Variable: \\n - \'i\' (link_OpenCLIntel.h:71)", "type":"resource", "data":[16, 100, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":71}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 18"}, {"type":"text", "text":"1 register of width 32"}, {"type":"brief", "text":"Register,\\n1 reg, 18 width,\\n1 reg, 32 width"}]}, {"name":"Variable: \\n - \'j\' (link_OpenCLIntel.h:73)", "type":"resource", "data":[14, 20, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":73}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 4 and depth 1"}, {"type":"text", "text":"1 register of width 8 and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 4 width by 1 depth,\\n1 reg, 8 width by 1 depth"}]}, {"name":"vxWriteDram.B1.start", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[1, 135, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1, 135, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[23, 11, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[9, 2, 0, 0, 0]}, {"name":"link_OpenCLIntel.h:68", "type":"resource", "data":[14, 9, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[20, 14, 0, 0, 2], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}]}, {"name":"link_OpenCLIntel.h:68", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]], "children":[{"name":"Stream Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"vxWriteDram.B2", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[1, 7, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1, 7, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[41, 9, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"link_OpenCLIntel.h:69", "type":"resource", "data":[9, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":69}]]}, {"name":"link_OpenCLIntel.h:71", "type":"resource", "data":[32, 9, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":71}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[30, 42, 0, 0, 2], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"link_OpenCLIntel.h:71", "type":"resource", "data":[57, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":71}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"18-bit Integer Add", "type":"resource", "count":1, "data":[18, 0, 0, 0, 0]}, {"name":"18-bit Integer Compare", "type":"resource", "count":1, "data":[6, 0, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[32, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"vxWriteDram.B3", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[5, 8, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[5, 8, 0, 0, 0]}]}, {"name":"Computation", "type":"resource", "children":[{"name":"link_OpenCLIntel.h:82", "type":"resource", "data":[3, 2, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":82}]], "children":[{"name":"Stream Write", "type":"resource", "count":1, "data":[3, 2, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"vxWriteDram.B4", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[1049, 2180, 1, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1049, 2180, 1, 0, 0]}]}, {"name":"Cluster logic", "type":"resource", "data":[305, 589, 0, 0, 30], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"link_OpenCLIntel.h:78", "type":"resource", "data":[1039, 7048, 18, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":78}]], "children":[{"name":"Store", "type":"resource", "count":1, "data":[1039, 7048, 18, 0, 0], "details":[{"type":"text", "text":"Store uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}]}]}, {"name":"vxWriteDram.B5", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[119, 419, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[119, 419, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[98, 58, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"link_OpenCLIntel.h:69", "type":"resource", "data":[46, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":69}]]}, {"name":"link_OpenCLIntel.h:71", "type":"resource", "data":[32, 51, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":71}]]}, {"name":"link_OpenCLIntel.h:73", "type":"resource", "data":[8, 7, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":73}]]}, {"name":"link_OpenCLIntel.h:74", "type":"resource", "data":[12, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":74}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[294, 562, 0, 0, 28], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[2, 2, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}, {"name":"1-bit Or", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}]}, {"name":"link_OpenCLIntel.h:69", "type":"resource", "data":[233, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":69}]], "children":[{"name":"64-bit Select", "type":"resource", "count":8, "data":[233, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"link_OpenCLIntel.h:73", "type":"resource", "data":[13, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":73}]], "children":[{"name":"4-bit Integer Add", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}, {"name":"4-bit Integer Compare", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"8-bit Integer Add", "type":"resource", "count":1, "data":[8, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"link_OpenCLIntel.h:74", "type":"resource", "data":[416, 8, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":74}]], "children":[{"name":"8-bit Integer Compare", "type":"resource", "count":8, "data":[24, 8, 0, 0, 0]}, {"name":"8-bit Select", "type":"resource", "count":56, "data":[392, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"link_OpenCLIntel.h:74 > hls.h:1075", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":74}]], "children":[{"name":"Stream Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}]}]}]}, {"name":"vxWriteDram_1", "compute_units":1, "type":"function", "total_percent":[0.596878, 0.290477, 0.32027, 0.162102, 0], "total_kernel_resources":[4181, 11954, 19, 0, 62], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Stream \'streamX_1_2\'", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 64 bits wide with a buffer size of 0 elements."}, {"type":"brief", "text":"64b wide with 0 elements."}]}, {"name":"Task call", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 64 bits wide with a buffer size of 0 elements."}, {"type":"brief", "text":"64b wide with 0 elements."}]}, {"name":"Task return", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 1 bit wide with a buffer size of 0 elements."}, {"type":"brief", "text":"1b wide with 0 elements."}]}, {"name":"Variable: \\n - \'data\' (link_OpenCLIntel.h:69)", "type":"resource", "data":[399, 740, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":69}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"56 registers of width 8 and depth 1"}, {"type":"text", "text":"1 register of width 64 and depth 1"}, {"type":"brief", "text":"Register,\\n56 regs, 8 width by 1 depth,\\n1 reg, 64 width by 1 depth"}]}, {"name":"Variable: \\n - \'i\' (link_OpenCLIntel.h:71)", "type":"resource", "data":[16, 100, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":71}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 18"}, {"type":"text", "text":"1 register of width 32"}, {"type":"brief", "text":"Register,\\n1 reg, 18 width,\\n1 reg, 32 width"}]}, {"name":"Variable: \\n - \'j\' (link_OpenCLIntel.h:73)", "type":"resource", "data":[14, 20, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":73}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 4 and depth 1"}, {"type":"text", "text":"1 register of width 8 and depth 1"}, {"type":"brief", "text":"Register,\\n1 reg, 4 width by 1 depth,\\n1 reg, 8 width by 1 depth"}]}, {"name":"vxWriteDram_1.B1.start", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[1, 135, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1, 135, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[23, 11, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[9, 2, 0, 0, 0]}, {"name":"link_OpenCLIntel.h:68", "type":"resource", "data":[14, 9, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[20, 14, 0, 0, 2], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}]}, {"name":"link_OpenCLIntel.h:68", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]], "children":[{"name":"Stream Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"vxWriteDram_1.B2", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[1, 7, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1, 7, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[41, 9, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"link_OpenCLIntel.h:69", "type":"resource", "data":[9, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":69}]]}, {"name":"link_OpenCLIntel.h:71", "type":"resource", "data":[32, 9, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":71}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[30, 42, 0, 0, 2], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"link_OpenCLIntel.h:71", "type":"resource", "data":[57, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":71}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"18-bit Integer Add", "type":"resource", "count":1, "data":[18, 0, 0, 0, 0]}, {"name":"18-bit Integer Compare", "type":"resource", "count":1, "data":[6, 0, 0, 0, 0]}, {"name":"32-bit Integer Add", "type":"resource", "count":1, "data":[32, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"vxWriteDram_1.B3", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[5, 8, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[5, 8, 0, 0, 0]}]}, {"name":"Computation", "type":"resource", "children":[{"name":"link_OpenCLIntel.h:82", "type":"resource", "data":[3, 2, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":82}]], "children":[{"name":"Stream Write", "type":"resource", "count":1, "data":[3, 2, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"vxWriteDram_1.B4", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[1049, 2180, 1, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1049, 2180, 1, 0, 0]}]}, {"name":"Cluster logic", "type":"resource", "data":[305, 589, 0, 0, 30], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"link_OpenCLIntel.h:78", "type":"resource", "data":[1039, 7048, 18, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":78}]], "children":[{"name":"Store", "type":"resource", "count":1, "data":[1039, 7048, 18, 0, 0], "details":[{"type":"text", "text":"Store uses a Burst-coalesced LSU"}, {"type":"brief", "text":"Burst-coalesced LSU"}]}], "replace_name":"true"}]}]}, {"name":"vxWriteDram_1.B5", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[119, 419, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[119, 419, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[98, 58, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"link_OpenCLIntel.h:69", "type":"resource", "data":[46, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":69}]]}, {"name":"link_OpenCLIntel.h:71", "type":"resource", "data":[32, 51, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":71}]]}, {"name":"link_OpenCLIntel.h:73", "type":"resource", "data":[8, 7, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":73}]]}, {"name":"link_OpenCLIntel.h:74", "type":"resource", "data":[12, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":74}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[294, 562, 0, 0, 28], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[2, 2, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}, {"name":"1-bit Or", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}]}, {"name":"link_OpenCLIntel.h:69", "type":"resource", "data":[233, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":69}]], "children":[{"name":"64-bit Select", "type":"resource", "count":8, "data":[233, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"link_OpenCLIntel.h:73", "type":"resource", "data":[13, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":73}]], "children":[{"name":"4-bit Integer Add", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}, {"name":"4-bit Integer Compare", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"8-bit Integer Add", "type":"resource", "count":1, "data":[8, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"link_OpenCLIntel.h:74", "type":"resource", "data":[416, 8, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":74}]], "children":[{"name":"8-bit Integer Compare", "type":"resource", "count":8, "data":[24, 8, 0, 0, 0]}, {"name":"8-bit Select", "type":"resource", "count":56, "data":[392, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"link_OpenCLIntel.h:74 > hls.h:1075", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":74}]], "children":[{"name":"Stream Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}]}]}]}]}';
var area_srcJSON='{"children":[{"children":[{"data":[162,239,0,0,14],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 192 bits wide with a buffer size of 0 elements.","type":"text"},{"text":"192b wide with 0 elements.","type":"brief"}],"name":"Component call","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 1 bit wide with a buffer size of 0 elements.","type":"text"},{"text":"1b wide with 0 elements.","type":"brief"}],"name":"Component return","type":"resource"},{"children":[{"count":1,"data":[5,16,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"1-bit And","type":"resource"}],"data":[6,16,0,0,0],"name":"No Source Line","type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":30}]],"name":"Stream Read","type":"resource"}],"data":[1,0,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":30}]],"name":"./graph_test/sobel.h:30","replace_name":"true","type":"resource"},{"children":[{"children":[{"count":6,"data":[1.36667,0.5,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":34}]],"name":"1-bit Or","type":"resource"},{"count":1,"data":[3,2,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":34}]],"name":"Stream Write","type":"resource"}],"data":[4.36667,2.5,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":34},{"filename":"./include/link_OpenCLIntel.h","line":144}]],"name":"sobel.h:34 > link_OpenCLIntel.h:144 > \\ntask.h:85 > task.h:54 > \\n_task_FPGA.h:43","replace_name":true,"type":"resource"}],"data":[4.36667,2.5,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":34}]],"name":"./graph_test/sobel.h:34","replace_name":"true","type":"resource"},{"children":[{"children":[{"count":7,"data":[2.36667,0.5,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":39}]],"name":"1-bit Or","type":"resource"},{"count":1,"data":[3,2,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":39}]],"name":"Stream Write","type":"resource"}],"data":[5.36667,2.5,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":39},{"filename":"./include/img_filter_base_intel.h","line":24}]],"name":"sobel.h:39 > img_filter_base_intel.h:24 > \\ntask.h:85 > task.h:54 > \\n_task_FPGA.h:43","replace_name":true,"type":"resource"}],"data":[5.36667,2.5,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":39}]],"name":"./graph_test/sobel.h:39","replace_name":"true","type":"resource"},{"children":[{"children":[{"count":7,"data":[2.36667,0.5,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":42}]],"name":"1-bit Or","type":"resource"},{"count":1,"data":[3,2,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":42}]],"name":"Stream Write","type":"resource"}],"data":[5.36667,2.5,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":42},{"filename":"./include/link_OpenCLIntel.h","line":156}]],"name":"sobel.h:42 > link_OpenCLIntel.h:156 > \\ntask.h:85 > task.h:54 > \\n_task_FPGA.h:43","replace_name":true,"type":"resource"}],"data":[5.36667,2.5,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":42}]],"name":"./graph_test/sobel.h:42","replace_name":"true","type":"resource"},{"children":[{"children":[{"count":5,"data":[1.7,0.166667,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":45}]],"name":"1-bit Or","type":"resource"},{"count":1,"data":[3,2,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":45}]],"name":"Stream Write","type":"resource"}],"data":[4.7,2.16667,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":45},{"filename":"./include/link_OpenCLIntel.h","line":156}]],"name":"sobel.h:45 > link_OpenCLIntel.h:156 > \\ntask.h:85 > task.h:54 > \\n_task_FPGA.h:43","replace_name":true,"type":"resource"}],"data":[4.7,2.16667,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":45}]],"name":"./graph_test/sobel.h:45","replace_name":"true","type":"resource"},{"children":[{"children":[{"count":4,"data":[0.7,0.166667,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":47}]],"name":"1-bit Or","type":"resource"},{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":47}]],"name":"Stream Read","type":"resource"}],"data":[4.7,0.166667,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":47},{"filename":"./include/img_filter_base_intel.h","line":30}]],"name":"sobel.h:47 > img_filter_base_intel.h:30 > \\ntask.h:95 > task.h:61 > \\n_task_FPGA.h:48","replace_name":true,"type":"resource"}],"data":[4.7,0.166667,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":47}]],"name":"./graph_test/sobel.h:47","replace_name":"true","type":"resource"},{"children":[{"children":[{"count":3,"data":[0.5,0.166667,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":49}]],"name":"1-bit Or","type":"resource"},{"count":1,"data":[3,0,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":49}]],"name":"Stream Read","type":"resource"}],"data":[3.5,0.166667,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":49},{"filename":"./include/link_OpenCLIntel.h","line":159}]],"name":"sobel.h:49 > link_OpenCLIntel.h:159 > \\ntask.h:95 > task.h:61 > \\n_task_FPGA.h:48","replace_name":true,"type":"resource"}],"data":[3.5,0.166667,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":49}]],"name":"./graph_test/sobel.h:49","replace_name":"true","type":"resource"},{"children":[{"children":[{"count":1,"data":[3,0,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":50}]],"name":"Stream Read","type":"resource"}],"data":[3,0,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":50},{"filename":"./include/link_OpenCLIntel.h","line":159}]],"name":"sobel.h:50 > link_OpenCLIntel.h:159 > \\ntask.h:95 > task.h:61 > \\n_task_FPGA.h:48","replace_name":true,"type":"resource"}],"data":[3,0,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":50}]],"name":"./graph_test/sobel.h:50","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[3,2,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":51}]],"name":"Stream Write","type":"resource"}],"data":[3,2,0,0,0],"debug":[[{"filename":"./graph_test/sobel.h","line":51}]],"name":"./graph_test/sobel.h:51","replace_name":"true","type":"resource"}],"compute_units":1,"data":[203.00001,267.000004,0,0,14],"details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"name":"ImgSobelFunc","total_kernel_resources":[203,267,0,0,14],"total_percent":[0.0296605,0.0258809,0.00715342,0,0],"type":"function"},{"children":[{"data":[734,746,0,0,30],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[62,140,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"6 registers of width 8 and depth 1","type":"text"},{"text":"Register,\\n6 regs, 8 width by 1 depth","type":"brief"}],"name":"Coalesced Variables: \\n - \'window\' (img_filter_core.h:1881)\\n - \'kernel_window\' (img_filter_core.h:1489)","type":"resource"},{"data":[46,38,1,0,0],"details":[{"text":"Stream implemented 64 bits wide with a buffer size of 256 elements.","type":"text"},{"text":"64b wide with 256 elements.","type":"brief"}],"name":"Stream \'streamX_1_2\'","type":"resource"},{"data":[46,38,1,0,0],"details":[{"text":"Stream implemented 64 bits wide with a buffer size of 256 elements.","type":"text"},{"text":"64b wide with 256 elements.","type":"brief"}],"name":"Stream \'streamY_1_2\'","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 64 bits wide with a buffer size of 0 elements.","type":"text"},{"text":"64b wide with 0 elements.","type":"brief"},{"details":[{"text":"instruction scheduling requirements","type":"text"}],"text":"Requested buffer size was 256. The buffer size differs from the value in the source code for the following reason:","type":"text"}],"name":"Stream \'stream_r_0\'","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 1 bit wide with a buffer size of 0 elements.","type":"text"},{"text":"1b wide with 0 elements.","type":"brief"}],"name":"Task call","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 1 bit wide with a buffer size of 0 elements.","type":"text"},{"text":"1b wide with 0 elements.","type":"brief"}],"name":"Task return","type":"resource"},{"data":[147,252,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"21 registers of width 8 and depth 1","type":"text"},{"text":"Register,\\n21 regs, 8 width by 1 depth","type":"brief"}],"name":"Variable: \\n - \'window\' (img_filter_core.h:1881)","type":"resource"},{"data":[23,67,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 10 and depth 1","type":"text"},{"text":"1 register of width 16 and depth 1","type":"text"},{"text":"Register,\\n1 reg, 10 width by 1 depth,\\n1 reg, 16 width by 1 depth","type":"brief"}],"name":"Variable: \\n - \'x\' (img_filter_core.h:1890)","type":"resource"},{"data":[16,58,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 13","type":"text"},{"text":"1 register of width 16","type":"text"},{"text":"Register,\\n1 reg, 13 width,\\n1 reg, 16 width","type":"brief"}],"name":"Variable: \\n - \'y\' (img_filter_core.h:1888)","type":"resource"},{"data":[0,0,8,0,0],"details":[{"Additional information":[{"details":[{"text":"Reduce the number of write accesses or fix banking to make this memory system stall-free. Banking may be improved by using compile-time known indexing on lowest array dimension.","type":"text"}],"text":"Requested size 7680 bytes, implemented size 8192 bytes, <b>stallable</b>, 4 reads and 4 writes. ","type":"text"},{"text":"Banked on bits 11, 12 into 4 separate banks.","type":"text"}],"Bank depth":"512 words","Bank width":"32 bits","Implemented size":"8192 bytes","Memory system":"Potentially inefficient configuration","Number of banks":"4 (banked on bits 11, 12)","Requested size":"7680 bytes","Total replication":1,"type":"table"},{"text":"Potentially inefficient configuration,\\n7680B requested,\\n8192B implemented.","type":"brief"}],"name":"img_filter_core.h:1874 (linebuffer)","type":"resource"},{"children":[{"count":3,"data":[408,3010,9,0,13],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"},{"count":2,"data":[2,1,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"1-bit Or","type":"resource"}],"data":[411,3012,9,0,13],"name":"No Source Line","type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":10}]],"name":"Stream Read","type":"resource"}],"data":[1,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":10}]],"name":"./include/img_filter_base_intel.h:10","replace_name":"true","type":"resource"},{"children":[{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[13,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"13-bit Integer Add","type":"resource"},{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"13-bit Integer Compare","type":"resource"},{"count":1,"data":[16,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"16-bit Integer Add","type":"resource"}],"data":[34,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1888}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1888","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[24,2,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"16-bit Integer Compare","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"1-bit And","type":"resource"}],"data":[25,2,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1917}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1917","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[19,1,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"16-bit Integer Compare","type":"resource"},{"count":8,"data":[32,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"8-bit Select","type":"resource"}],"data":[51,1,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1932},{"filename":"./include/img_filter_core.h","line":583},{"filename":"./include/img_filter_core.h","line":313}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1932 > \\nimg_filter_core.h:583 > img_filter_core.h:313","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[5,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"16-bit Integer Compare","type":"resource"},{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"1-bit Or","type":"resource"}],"data":[6,1,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1941}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1941","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[10,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"10-bit Integer Add","type":"resource"},{"count":1,"data":[3,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"10-bit Integer Compare","type":"resource"},{"count":1,"data":[16,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"16-bit Integer Add","type":"resource"}],"data":[29,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1890}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1890","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"Stream Read","type":"resource"}],"data":[1,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1918}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1918 > \\nhls.h:1075","replace_name":true,"type":"resource"},{"children":[{"count":16,"data":[8,4,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"1-bit Or","type":"resource"},{"count":4,"data":[988,876,0,0,16],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"Load","type":"resource"}],"data":[996,880,0,0,16],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1929},{"filename":"./include/img_filter_core.h","line":69}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1929 > \\nimg_filter_core.h:69","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[32,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"8-bit Select","type":"resource"}],"data":[32,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1932},{"filename":"./include/img_filter_core.h","line":583},{"filename":"./include/img_filter_core.h","line":331}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1932 > \\nimg_filter_core.h:583 > img_filter_core.h:331","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[5,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"16-bit Integer Compare","type":"resource"},{"count":2,"data":[16,16,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"8-bit Select","type":"resource"}],"data":[21,16,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1932},{"filename":"./include/img_filter_core.h","line":586},{"filename":"./include/img_filter_core.h","line":369}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1932 > \\nimg_filter_core.h:586 > img_filter_core.h:369","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[8,8,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"8-bit Select","type":"resource"}],"data":[8,8,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1932},{"filename":"./include/img_filter_core.h","line":586},{"filename":"./include/img_filter_core.h","line":370}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1932 > \\nimg_filter_core.h:586 > img_filter_core.h:370","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[19,1,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"16-bit Integer Compare","type":"resource"},{"count":12,"data":[48,0,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"8-bit Select","type":"resource"}],"data":[67,1,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1932},{"filename":"./include/img_filter_core.h","line":586},{"filename":"./include/img_filter_core.h","line":379}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1932 > \\nimg_filter_core.h:586 > img_filter_core.h:379","replace_name":true,"type":"resource"},{"children":[{"count":12,"data":[56,16,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"8-bit Select","type":"resource"}],"data":[56,16,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1932},{"filename":"./include/img_filter_core.h","line":586},{"filename":"./include/img_filter_core.h","line":380}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1932 > \\nimg_filter_core.h:586 > img_filter_core.h:380","replace_name":true,"type":"resource"},{"children":[{"count":25,"data":[17,11,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"1-bit Or","type":"resource"},{"count":4,"data":[316,1080,0,0,16],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"Store","type":"resource"}],"data":[333,1091,0,0,16],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1935},{"filename":"./include/img_filter_core.h","line":169}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1935 > \\nimg_filter_core.h:169","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[72,72,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"unsigned 8-bit x unsigned 8-bit to 9-bit Integer Add","type":"resource"}],"data":[72,72,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1938},{"filename":"./include/img_filter_core.h","line":1513},{"filename":"./include/img_filter_core.h","line":1087}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1513 > img_filter_core.h:1087","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[80,80,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"unsigned 9-bit x unsigned 8-bit to 10-bit Integer Subtract","type":"resource"}],"data":[80,80,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1938},{"filename":"./include/img_filter_core.h","line":1513},{"filename":"./include/img_filter_core.h","line":1088}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1513 > img_filter_core.h:1088","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[88,96,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"signed 10-bit x unsigned 8-bit to 12-bit Integer Subtract","type":"resource"}],"data":[88,96,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1938},{"filename":"./include/img_filter_core.h","line":1513},{"filename":"./include/img_filter_core.h","line":1089}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1513 > img_filter_core.h:1089","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[72,72,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"unsigned 8-bit x unsigned 8-bit to 9-bit Integer Subtract","type":"resource"}],"data":[72,72,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1938},{"filename":"./include/img_filter_core.h","line":1513},{"filename":"./include/img_filter_core.h","line":1092}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1513 > img_filter_core.h:1092","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[544,536,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"64-bit Integer Add","type":"resource"}],"data":[544,536,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1938},{"filename":"./include/img_filter_core.h","line":1513},{"filename":"./include/img_filter_core.h","line":1097}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1513 > img_filter_core.h:1097","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[136,134,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"64-bit Integer Add","type":"resource"}],"data":[136,134,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1938},{"filename":"./include/img_filter_core.h","line":1513},{"filename":"./include/img_filter_core.h","line":1103}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1513 > img_filter_core.h:1103","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[72,72,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"unsigned 8-bit x unsigned 8-bit to 9-bit Integer Add","type":"resource"}],"data":[72,72,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1938},{"filename":"./include/img_filter_core.h","line":1516},{"filename":"./include/img_filter_core.h","line":1149}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1516 > img_filter_core.h:1149","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[80,80,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"unsigned 9-bit x unsigned 8-bit to 10-bit Integer Subtract","type":"resource"}],"data":[80,80,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1938},{"filename":"./include/img_filter_core.h","line":1516},{"filename":"./include/img_filter_core.h","line":1150}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1516 > img_filter_core.h:1150","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[88,96,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"signed 10-bit x unsigned 8-bit to 12-bit Integer Subtract","type":"resource"}],"data":[88,96,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1938},{"filename":"./include/img_filter_core.h","line":1516},{"filename":"./include/img_filter_core.h","line":1151}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1516 > img_filter_core.h:1151","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[72,72,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"unsigned 8-bit x unsigned 8-bit to 9-bit Integer Subtract","type":"resource"}],"data":[72,72,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1938},{"filename":"./include/img_filter_core.h","line":1516},{"filename":"./include/img_filter_core.h","line":1154}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1516 > img_filter_core.h:1154","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[544,536,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"64-bit Integer Add","type":"resource"}],"data":[544,536,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1938},{"filename":"./include/img_filter_core.h","line":1516},{"filename":"./include/img_filter_core.h","line":1159}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1516 > img_filter_core.h:1159","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[136,134,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"64-bit Integer Add","type":"resource"}],"data":[136,134,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1938},{"filename":"./include/img_filter_core.h","line":1516},{"filename":"./include/img_filter_core.h","line":1165}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1516 > img_filter_core.h:1165","replace_name":true,"type":"resource"},{"children":[{"count":6,"data":[250,245,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"64-bit Integer Add","type":"resource"}],"data":[250,245,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1938},{"filename":"./include/img_filter_core.h","line":1543}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1543","replace_name":true,"type":"resource"},{"children":[{"count":6,"data":[252,246,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"64-bit Integer Add","type":"resource"}],"data":[252,246,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1938},{"filename":"./include/img_filter_core.h","line":1547}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1938 > \\nimg_filter_core.h:1547","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[8,7,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"Stream Write","type":"resource"}],"data":[8,7,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1946}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1946 > \\nhls.h:1080","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[8,7,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"Stream Write","type":"resource"}],"data":[8,7,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11},{"filename":"./include/img_filter_core.h","line":2749},{"filename":"./include/img_filter_core.h","line":2215},{"filename":"./include/img_filter_core.h","line":1952}]],"name":"img_filter_base_intel.h:11 > img_filter_core.h:2749 > \\nimg_filter_core.h:2215 > img_filter_core.h:1952 > \\nhls.h:1080","replace_name":true,"type":"resource"}],"data":[4161,4501,0,0,32],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":11}]],"name":"./include/img_filter_base_intel.h:11","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[3,2,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":12}]],"name":"Stream Write","type":"resource"}],"data":[3,2,0,0,0],"debug":[[{"filename":"./include/img_filter_base_intel.h","line":12}]],"name":"./include/img_filter_base_intel.h:12","replace_name":"true","type":"resource"}],"compute_units":1,"data":[5650,8854,19,0,75],"debug":[[{"filename":"./include/img_filter_core.h","line":1489}]],"details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"name":"ImgSobelIntel","total_kernel_resources":[5650,8854,19,0,75],"total_percent":[0.583526,0.383123,0.237215,0.162102,0],"type":"function"},{"children":[{"data":[5031,11157,0,0,194],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[46,38,1,0,0],"details":[{"text":"Stream implemented 64 bits wide with a buffer size of 256 elements.","type":"text"},{"text":"64b wide with 256 elements.","type":"brief"}],"name":"Stream \'stream_r_0\'","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 64 bits wide with a buffer size of 0 elements.","type":"text"},{"text":"64b wide with 0 elements.","type":"brief"}],"name":"Task call","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 1 bit wide with a buffer size of 0 elements.","type":"text"},{"text":"1b wide with 0 elements.","type":"brief"}],"name":"Task return","type":"resource"},{"data":[16,100,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 18","type":"text"},{"text":"1 register of width 32","type":"text"},{"text":"Register,\\n1 reg, 18 width,\\n1 reg, 32 width","type":"brief"}],"name":"Variable: \\n - \'i\' (link_OpenCLIntel.h:26)","type":"resource"},{"data":[16,24,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 4","type":"text"},{"text":"1 register of width 8","type":"text"},{"text":"Register,\\n1 reg, 4 width,\\n1 reg, 8 width","type":"brief"}],"name":"Variable: \\n - \'j\' (link_OpenCLIntel.h:38)","type":"resource"},{"children":[{"count":3,"data":[1858,14251,1,0,0],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"1-bit And","type":"resource"},{"count":8,"data":[1664,0,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"llvm.fpga.case","type":"resource"}],"data":[3523,14251,1,0,0],"name":"No Source Line","type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":20}]],"name":"Stream Read","type":"resource"}],"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":20}]],"name":"./include/link_OpenCLIntel.h:20","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":26}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[18,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":26}]],"name":"18-bit Integer Add","type":"resource"},{"count":1,"data":[6,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":26}]],"name":"18-bit Integer Compare","type":"resource"},{"count":1,"data":[32,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":26}]],"name":"32-bit Integer Add","type":"resource"}],"data":[57,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":26}]],"name":"./include/link_OpenCLIntel.h:26","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[1858,13948,15,0,26],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":34}]],"name":"Load","type":"resource"}],"data":[1858,13948,15,0,26],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":34}]],"name":"./include/link_OpenCLIntel.h:34","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[3,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":41}]],"name":"Non-Blocking Stream Write","type":"resource"}],"data":[3,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":41}]],"name":"./include/link_OpenCLIntel.h:41","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":38}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":38}]],"name":"4-bit Integer Add","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":38}]],"name":"4-bit Integer Compare","type":"resource"},{"count":1,"data":[8,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":38}]],"name":"8-bit Integer Add","type":"resource"}],"data":[14,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":38}]],"name":"./include/link_OpenCLIntel.h:38","replace_name":"true","type":"resource"},{"children":[{"children":[{"count":1,"data":[4,2,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":39}]],"name":"Stream Write","type":"resource"}],"data":[4,2,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":39}]],"name":"link_OpenCLIntel.h:39 > hls.h:1080","replace_name":true,"type":"resource"}],"data":[4,2,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":39}]],"name":"./include/link_OpenCLIntel.h:39","replace_name":"true","type":"resource"}],"compute_units":1,"data":[10569,39520,17,0,220],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":26}]],"details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"name":"vxReadDram","total_kernel_resources":[10569,39520,17,0,220],"total_percent":[1.84006,0.802094,1.05881,0.145039,0],"type":"function"},{"children":[{"data":[816,1293,0,0,62],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 64 bits wide with a buffer size of 0 elements.","type":"text"},{"text":"64b wide with 0 elements.","type":"brief"}],"name":"Stream \'streamY_1_2\'","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 64 bits wide with a buffer size of 0 elements.","type":"text"},{"text":"64b wide with 0 elements.","type":"brief"}],"name":"Task call","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 1 bit wide with a buffer size of 0 elements.","type":"text"},{"text":"1b wide with 0 elements.","type":"brief"}],"name":"Task return","type":"resource"},{"data":[399,740,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"56 registers of width 8 and depth 1","type":"text"},{"text":"1 register of width 64 and depth 1","type":"text"},{"text":"Register,\\n56 regs, 8 width by 1 depth,\\n1 reg, 64 width by 1 depth","type":"brief"}],"name":"Variable: \\n - \'data\' (link_OpenCLIntel.h:69)","type":"resource"},{"data":[16,100,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 18","type":"text"},{"text":"1 register of width 32","type":"text"},{"text":"Register,\\n1 reg, 18 width,\\n1 reg, 32 width","type":"brief"}],"name":"Variable: \\n - \'i\' (link_OpenCLIntel.h:71)","type":"resource"},{"data":[14,20,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 4 and depth 1","type":"text"},{"text":"1 register of width 8 and depth 1","type":"text"},{"text":"Register,\\n1 reg, 4 width by 1 depth,\\n1 reg, 8 width by 1 depth","type":"brief"}],"name":"Variable: \\n - \'j\' (link_OpenCLIntel.h:73)","type":"resource"},{"children":[{"count":4,"data":[1170,2741,1,0,0],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"},{"count":2,"data":[2,1,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"1-bit Or","type":"resource"}],"data":[1173,2743,1,0,0],"name":"No Source Line","type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":68}]],"name":"Stream Read","type":"resource"}],"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":68}]],"name":"./include/link_OpenCLIntel.h:68","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":71}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[18,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":71}]],"name":"18-bit Integer Add","type":"resource"},{"count":1,"data":[6,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":71}]],"name":"18-bit Integer Compare","type":"resource"},{"count":1,"data":[32,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":71}]],"name":"32-bit Integer Add","type":"resource"}],"data":[57,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":71}]],"name":"./include/link_OpenCLIntel.h:71","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[3,2,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":82}]],"name":"Stream Write","type":"resource"}],"data":[3,2,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":82}]],"name":"./include/link_OpenCLIntel.h:82","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[1039,7048,18,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":78}]],"name":"Store","type":"resource"}],"data":[1039,7048,18,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":78}]],"name":"./include/link_OpenCLIntel.h:78","replace_name":"true","type":"resource"},{"children":[{"count":8,"data":[233,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":69}]],"name":"64-bit Select","type":"resource"}],"data":[233,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":69}]],"name":"./include/link_OpenCLIntel.h:69","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":73}]],"name":"4-bit Integer Add","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":73}]],"name":"4-bit Integer Compare","type":"resource"},{"count":1,"data":[8,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":73}]],"name":"8-bit Integer Add","type":"resource"}],"data":[13,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":73}]],"name":"./include/link_OpenCLIntel.h:73","replace_name":"true","type":"resource"},{"children":[{"count":8,"data":[24,8,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":74}]],"name":"8-bit Integer Compare","type":"resource"},{"count":56,"data":[392,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":74}]],"name":"8-bit Select","type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":74}]],"name":"Stream Read","type":"resource"}],"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":74}]],"name":"link_OpenCLIntel.h:74 > hls.h:1075","replace_name":true,"type":"resource"}],"data":[417,8,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":74}]],"name":"./include/link_OpenCLIntel.h:74","replace_name":"true","type":"resource"}],"compute_units":1,"data":[4181,11954,19,0,62],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":69}]],"details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"name":"vxWriteDram","total_kernel_resources":[4181,11954,19,0,62],"total_percent":[0.596878,0.290477,0.32027,0.162102,0],"type":"function"},{"children":[{"data":[816,1293,0,0,62],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 64 bits wide with a buffer size of 0 elements.","type":"text"},{"text":"64b wide with 0 elements.","type":"brief"}],"name":"Stream \'streamX_1_2\'","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 64 bits wide with a buffer size of 0 elements.","type":"text"},{"text":"64b wide with 0 elements.","type":"brief"}],"name":"Task call","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 1 bit wide with a buffer size of 0 elements.","type":"text"},{"text":"1b wide with 0 elements.","type":"brief"}],"name":"Task return","type":"resource"},{"data":[399,740,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"56 registers of width 8 and depth 1","type":"text"},{"text":"1 register of width 64 and depth 1","type":"text"},{"text":"Register,\\n56 regs, 8 width by 1 depth,\\n1 reg, 64 width by 1 depth","type":"brief"}],"name":"Variable: \\n - \'data\' (link_OpenCLIntel.h:69)","type":"resource"},{"data":[16,100,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 18","type":"text"},{"text":"1 register of width 32","type":"text"},{"text":"Register,\\n1 reg, 18 width,\\n1 reg, 32 width","type":"brief"}],"name":"Variable: \\n - \'i\' (link_OpenCLIntel.h:71)","type":"resource"},{"data":[14,20,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 4 and depth 1","type":"text"},{"text":"1 register of width 8 and depth 1","type":"text"},{"text":"Register,\\n1 reg, 4 width by 1 depth,\\n1 reg, 8 width by 1 depth","type":"brief"}],"name":"Variable: \\n - \'j\' (link_OpenCLIntel.h:73)","type":"resource"},{"children":[{"count":4,"data":[1170,2741,1,0,0],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"},{"count":2,"data":[2,1,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"1-bit Or","type":"resource"}],"data":[1173,2743,1,0,0],"name":"No Source Line","type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":68}]],"name":"Stream Read","type":"resource"}],"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":68}]],"name":"./include/link_OpenCLIntel.h:68","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":71}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[18,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":71}]],"name":"18-bit Integer Add","type":"resource"},{"count":1,"data":[6,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":71}]],"name":"18-bit Integer Compare","type":"resource"},{"count":1,"data":[32,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":71}]],"name":"32-bit Integer Add","type":"resource"}],"data":[57,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":71}]],"name":"./include/link_OpenCLIntel.h:71","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[3,2,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":82}]],"name":"Stream Write","type":"resource"}],"data":[3,2,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":82}]],"name":"./include/link_OpenCLIntel.h:82","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[1039,7048,18,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":78}]],"name":"Store","type":"resource"}],"data":[1039,7048,18,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":78}]],"name":"./include/link_OpenCLIntel.h:78","replace_name":"true","type":"resource"},{"children":[{"count":8,"data":[233,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":69}]],"name":"64-bit Select","type":"resource"}],"data":[233,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":69}]],"name":"./include/link_OpenCLIntel.h:69","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":73}]],"name":"4-bit Integer Add","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":73}]],"name":"4-bit Integer Compare","type":"resource"},{"count":1,"data":[8,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":73}]],"name":"8-bit Integer Add","type":"resource"}],"data":[13,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":73}]],"name":"./include/link_OpenCLIntel.h:73","replace_name":"true","type":"resource"},{"children":[{"count":8,"data":[24,8,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":74}]],"name":"8-bit Integer Compare","type":"resource"},{"count":56,"data":[392,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":74}]],"name":"8-bit Select","type":"resource"},{"children":[{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":74}]],"name":"Stream Read","type":"resource"}],"data":[1,0,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":74}]],"name":"link_OpenCLIntel.h:74 > hls.h:1075","replace_name":true,"type":"resource"}],"data":[417,8,0,0,0],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":74}]],"name":"./include/link_OpenCLIntel.h:74","replace_name":"true","type":"resource"}],"compute_units":1,"data":[4181,11954,19,0,62],"debug":[[{"filename":"./include/link_OpenCLIntel.h","line":69}]],"details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"name":"vxWriteDram_1","total_kernel_resources":[4181,11954,19,0,62],"total_percent":[0.596878,0.290477,0.32027,0.162102,0],"type":"function"}],"columns":["","ALUTs","FFs","RAMs","DSPs","MLABs","Details"],"data":[24784.00001,72549.000004,74,0,433],"debug_enabled":"true","max_resources":[1866240,3732480,11721,5760,93312],"name":"System","total":[24784,72549,74,0,433],"total_percent":[3.647,1.79205,1.94372,0.631345,0],"type":"module"}';
var mavJSON='{"nodes":[{"type":"component", "id":2, "name":"ImgSobelFunc", "children":[{"type":"bb", "id":3, "name":"ImgSobelFunc.B0.runOnce", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":4, "name":"ImgSobelFunc.B1.start", "children":[{"type":"inst", "id":5, "name":"Stream Read", "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]], "details":[{"type":"table", "Width":"192 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"8", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":7, "name":"Stream Write", "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":24}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Stall-free":"No", "Start Cycle":"12", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":9, "name":"Stream Write", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":144}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"12", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":11, "name":"Stream Write", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":156}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"12", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":13, "name":"Stream Write", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":156}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"12", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":15, "name":"Stream Read", "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":30}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Stall-free":"No", "Start Cycle":"16", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":17, "name":"Stream Read", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":159}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Stall-free":"No", "Start Cycle":"16", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":19, "name":"Stream Read", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":159}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Stall-free":"No", "Start Cycle":"16", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":21, "name":"Stream Write", "debug":[[{"filename":"./graph_test/sobel.h", "line":51}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Stall-free":"No", "Start Cycle":"21", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":23, "name":"Loop Input", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"24"}]}, {"type":"inst", "id":24, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"16", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"16", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}]}, {"type":"component", "id":28, "name":"ImgSobelIntel", "children":[{"type":"bb", "id":29, "name":"ImgSobelIntel.B0.runOnce", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":30, "name":"ImgSobelIntel.B1.start", "children":[{"type":"inst", "id":35, "name":"Stream Read", "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":10}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Stall-free":"No", "Start Cycle":"9", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":53, "name":"Loop Input", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"58"}]}, {"type":"inst", "id":54, "name":"End", "details":[{"type":"table", "Start Cycle":"9", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"9", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. "}]}, {"type":"bb", "id":31, "name":"ImgSobelIntel.B2", "details":[{"type":"table", "Latency":"9", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"32"}]}, {"type":"bb", "id":32, "name":"ImgSobelIntel.B3", "details":[{"type":"table", "Latency":"0", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":33, "name":"ImgSobelIntel.B4", "children":[{"type":"inst", "id":37, "name":"Stream Read", "debug":[[{"filename":"./include/img_filter_core.h", "line":1918}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"44", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":39, "name":"Load", "debug":[[{"filename":"./include/img_filter_core.h", "line":69}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"linebuffer", "Start Cycle":"12", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":40, "name":"Load", "debug":[[{"filename":"./include/img_filter_core.h", "line":69}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"linebuffer", "Start Cycle":"12", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":41, "name":"Load", "debug":[[{"filename":"./include/img_filter_core.h", "line":69}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"linebuffer", "Start Cycle":"12", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":42, "name":"Load", "debug":[[{"filename":"./include/img_filter_core.h", "line":69}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Loads from":"linebuffer", "Start Cycle":"12", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":43, "name":"Store", "debug":[[{"filename":"./include/img_filter_core.h", "line":169}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Stores to":"linebuffer", "Start Cycle":"57", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":44, "name":"Store", "debug":[[{"filename":"./include/img_filter_core.h", "line":169}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Stores to":"linebuffer", "Start Cycle":"57", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":45, "name":"Store", "debug":[[{"filename":"./include/img_filter_core.h", "line":169}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Stores to":"linebuffer", "Start Cycle":"57", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":46, "name":"Store", "debug":[[{"filename":"./include/img_filter_core.h", "line":169}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Pipelined", "Stall-free":"No", "Stores to":"linebuffer", "Start Cycle":"57", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":47, "name":"Stream Write", "debug":[[{"filename":"./include/img_filter_core.h", "line":1946}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"57", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":49, "name":"Stream Write", "debug":[[{"filename":"./include/img_filter_core.h", "line":1952}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"57", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":55, "name":"Loop Input", "debug":[[{"filename":"./include/img_filter_core.h", "line":1890}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"56"}]}, {"type":"inst", "id":56, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"88", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"88", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}, {"type":"bb", "id":34, "name":"ImgSobelIntel.B5", "children":[{"type":"inst", "id":51, "name":"Stream Write", "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":12}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Stall-free":"No", "Start Cycle":"0", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":57, "name":"Begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":58, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"0", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"memtype", "id":59, "name":"Local Memory", "children":[{"type":"memsys", "id":60, "name":"linebuffer", "debug":[[{"filename":"./include/img_filter_core.h", "line":1874}]], "details":[{"type":"table", "details":[{"type":"brief", "text":"7680B requested\\n8192B implemented"}], "Requested size":"7680 bytes", "Implemented size":"8192 bytes", "Number of banks":"4", "Bank width":"32 bits", "Bank depth":"512 words", "Total replication":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Local Variables in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#xzx1468871996419"}]}]}]}]}]}, {"type":"component", "id":81, "name":"vxReadDram", "children":[{"type":"bb", "id":82, "name":"vxReadDram.B0.runOnce", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":83, "name":"vxReadDram.B1.start", "children":[{"type":"inst", "id":88, "name":"Stream Read", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":20}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"9", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":95, "name":"Loop Input", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"100"}]}, {"type":"inst", "id":96, "name":"End", "details":[{"type":"table", "Start Cycle":"14", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"14", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. "}]}, {"type":"bb", "id":84, "name":"vxReadDram.B2", "children":[{"type":"inst", "id":90, "name":"Load", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":34}]], "details":[{"type":"table", "Width":"512 bits", "Type":"Burst-coalesced", "Stall-free":"No", "Loads from":"dram_in", "Start Cycle":"13", "Latency":"69", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":97, "name":"Loop Input", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":26}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"86"}]}, {"type":"inst", "id":98, "name":"End", "details":[{"type":"table", "Start Cycle":"87", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"87", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. "}]}, {"type":"bb", "id":85, "name":"vxReadDram.B3", "children":[{"type":"inst", "id":91, "name":"Non-Blocking Stream Write", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":41}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Stall-free":"Yes", "Start Cycle":"1", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":99, "name":"Begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":100, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"5", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"5", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":86, "name":"vxReadDram.B4", "details":[{"type":"table", "Latency":"0", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":87, "name":"vxReadDram.B5", "children":[{"type":"inst", "id":93, "name":"Stream Write", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":39}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"9", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":101, "name":"Loop Input", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":38}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"102"}]}, {"type":"inst", "id":102, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"9", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"9", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}]}, {"type":"component", "id":105, "name":"vxWriteDram", "children":[{"type":"bb", "id":106, "name":"vxWriteDram.B0.runOnce", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":107, "name":"vxWriteDram.B1.start", "children":[{"type":"inst", "id":112, "name":"Stream Read", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"9", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":119, "name":"Loop Input", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"122"}]}, {"type":"inst", "id":120, "name":"End", "details":[{"type":"table", "Start Cycle":"14", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"14", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. "}]}, {"type":"bb", "id":108, "name":"vxWriteDram.B2", "details":[{"type":"table", "Latency":"8", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"124"}]}, {"type":"bb", "id":109, "name":"vxWriteDram.B3", "children":[{"type":"inst", "id":114, "name":"Stream Write", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":82}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Stall-free":"No", "Start Cycle":"0", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":121, "name":"Begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":122, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"0", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":110, "name":"vxWriteDram.B4", "children":[{"type":"inst", "id":116, "name":"Store", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":78}]], "details":[{"type":"table", "Width":"512 bits", "Type":"Burst-coalesced", "Stall-free":"No", "Stores to":"dram_out", "Start Cycle":"8", "Latency":"26", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":123, "name":"Begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":124, "name":"End", "details":[{"type":"table", "Start Cycle":"34", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"34", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":111, "name":"vxWriteDram.B5", "children":[{"type":"inst", "id":117, "name":"Stream Read", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":74}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"6", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":125, "name":"Loop Input", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":73}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"126"}]}, {"type":"inst", "id":126, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"13", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"13", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}]}, {"type":"component", "id":129, "name":"vxWriteDram_1", "children":[{"type":"bb", "id":130, "name":"vxWriteDram_1.B0.runOnce", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":131, "name":"vxWriteDram_1.B1.start", "children":[{"type":"inst", "id":136, "name":"Stream Read", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"9", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":143, "name":"Loop Input", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"146"}]}, {"type":"inst", "id":144, "name":"End", "details":[{"type":"table", "Start Cycle":"14", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"14", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. "}]}, {"type":"bb", "id":132, "name":"vxWriteDram_1.B2", "details":[{"type":"table", "Latency":"8", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"148"}]}, {"type":"bb", "id":133, "name":"vxWriteDram_1.B3", "children":[{"type":"inst", "id":138, "name":"Stream Write", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":82}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Stall-free":"No", "Start Cycle":"0", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":145, "name":"Begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":146, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"0", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":134, "name":"vxWriteDram_1.B4", "children":[{"type":"inst", "id":140, "name":"Store", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":78}]], "details":[{"type":"table", "Width":"512 bits", "Type":"Burst-coalesced", "Stall-free":"No", "Stores to":"dram_out", "Start Cycle":"8", "Latency":"26", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":147, "name":"Begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":148, "name":"End", "details":[{"type":"table", "Start Cycle":"34", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"34", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":135, "name":"vxWriteDram_1.B5", "children":[{"type":"inst", "id":141, "name":"Stream Read", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":74}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"256", "Stall-free":"No", "Start Cycle":"6", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":149, "name":"Loop Input", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":73}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"150"}]}, {"type":"inst", "id":150, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"13", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"13", "II":"1", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":""}]}]}, {"type":"memtype", "id":1, "name":"System Memory", "children":[{"type":"memsys", "id":104, "name":"1", "details":[{"type":"table", "Number of banks":"1", "Arguments from vxReadDram":"dram_in"}]}, {"type":"memsys", "id":128, "name":"3", "details":[{"type":"table", "Number of banks":"1", "Arguments from vxWriteDram":"dram_out"}]}, {"type":"memsys", "id":152, "name":"2", "details":[{"type":"table", "Number of banks":"1", "Arguments from vxWriteDram_1":"dram_out"}]}]}, {"type":"stream", "id":6, "name":"call.ImgSobelFunc", "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]], "details":[{"type":"table", "Width":"192 bits", "Depth":"0", "Bits per symbol":"192 bits", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Valid":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":8, "name":"call.ImgSobelIntel", "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]]}, {"type":"stream", "id":36, "name":"call.ImgSobelIntel", "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":10}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Bits per symbol":"1 bit", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Valid":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":10, "name":"call.vxReadDram", "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]]}, {"type":"stream", "id":89, "name":"call.vxReadDram", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":20}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"0", "Bits per symbol":"64 bits", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Valid":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":113, "name":"call.vxWriteDram", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"0", "Bits per symbol":"64 bits", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Valid":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":14, "name":"call.vxWriteDram", "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]]}, {"type":"stream", "id":137, "name":"call.vxWriteDram_1", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"0", "Bits per symbol":"64 bits", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Valid":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":12, "name":"call.vxWriteDram_1", "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]]}, {"type":"stream", "id":22, "name":"return.ImgSobelFunc", "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Bits per symbol":"1 bit", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Ready":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":16, "name":"return.ImgSobelIntel", "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]]}, {"type":"stream", "id":52, "name":"return.ImgSobelIntel", "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":10}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Bits per symbol":"1 bit", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Ready":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":92, "name":"return.vxReadDram", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":20}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Bits per symbol":"1 bit", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Ready":"No", "Ready Latency":"0"}]}, {"type":"stream", "id":115, "name":"return.vxWriteDram", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Bits per symbol":"1 bit", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Ready":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":20, "name":"return.vxWriteDram", "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]]}, {"type":"stream", "id":139, "name":"return.vxWriteDram_1", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Bits per symbol":"1 bit", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Ready":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":18, "name":"return.vxWriteDram_1", "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]]}, {"type":"stream", "id":142, "name":"streamX_1_2", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"256", "Bits per symbol":"64 bits", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Ready":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":48, "name":"streamX_1_2", "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":10}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"256", "Bits per symbol":"64 bits", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Ready":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":118, "name":"streamY_1_2", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"256", "Bits per symbol":"64 bits", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Ready":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":50, "name":"streamY_1_2", "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":10}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"256", "Bits per symbol":"64 bits", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Ready":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":38, "name":"stream_r_0", "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":10}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"256", "Bits per symbol":"64 bits", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Valid":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":94, "name":"stream_r_0", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":20}]], "details":[{"type":"table", "Width":"64 bits", "Depth":"256", "Bits per symbol":"64 bits", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Valid":"Yes", "Ready Latency":"0"}]}, {"type":"interface", "id":25, "name":"InputImg", "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]], "details":[{"type":"table", "Stable":"No", "Data width":"512", "Address width":"32", "Address Space":"1", "Latency":"0", "ReadWrite Mode":"readwrite", "Maximum burst":"16", "Wait request":"1", "Alignment":"64", "Component":"ImgSobelFunc"}]}, {"type":"interface", "id":26, "name":"OutputImg", "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]], "details":[{"type":"table", "Stable":"No", "Data width":"512", "Address width":"32", "Address Space":"2", "Latency":"0", "ReadWrite Mode":"readwrite", "Maximum burst":"16", "Wait request":"1", "Alignment":"64", "Component":"ImgSobelFunc"}]}, {"type":"interface", "id":27, "name":"OutputImg1", "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]], "details":[{"type":"table", "Stable":"No", "Data width":"512", "Address width":"32", "Address Space":"3", "Latency":"0", "ReadWrite Mode":"readwrite", "Maximum burst":"16", "Wait request":"1", "Alignment":"64", "Component":"ImgSobelFunc"}]}, {"type":"interface", "id":103, "name":"dram_in", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":20}]], "details":[{"type":"table", "Stable":"No", "Data width":"512", "Address width":"32", "Address Space":"1", "Latency":"0", "ReadWrite Mode":"readwrite", "Maximum burst":"16", "Wait request":"1", "Alignment":"64", "Component":"vxReadDram"}]}, {"type":"interface", "id":127, "name":"dram_out", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]], "details":[{"type":"table", "Stable":"No", "Data width":"512", "Address width":"32", "Address Space":"3", "Latency":"0", "ReadWrite Mode":"readwrite", "Maximum burst":"16", "Wait request":"1", "Alignment":"64", "Component":"vxWriteDram"}]}, {"type":"interface", "id":151, "name":"dram_out", "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]], "details":[{"type":"table", "Stable":"No", "Data width":"512", "Address width":"32", "Address Space":"2", "Latency":"0", "ReadWrite Mode":"readwrite", "Maximum burst":"16", "Wait request":"1", "Alignment":"64", "Component":"vxWriteDram_1"}]}], "links":[{"from":6, "to":5}, {"from":7, "to":8}, {"from":9, "to":10}, {"from":11, "to":12}, {"from":13, "to":14}, {"from":16, "to":15}, {"from":18, "to":17}, {"from":20, "to":19}, {"from":21, "to":22}, {"from":25, "to":5}, {"from":26, "to":5}, {"from":27, "to":5}, {"from":24, "to":23}, {"from":3, "to":23}, {"from":5, "to":24}, {"from":7, "to":24}, {"from":9, "to":24}, {"from":11, "to":24}, {"from":13, "to":24}, {"from":15, "to":24}, {"from":17, "to":24}, {"from":19, "to":24}, {"from":21, "to":24}, {"from":23, "to":5}, {"from":5, "to":7}, {"from":5, "to":9}, {"from":5, "to":11}, {"from":5, "to":13}, {"from":5, "to":15}, {"from":7, "to":15}, {"from":11, "to":15}, {"from":13, "to":15}, {"from":5, "to":17}, {"from":7, "to":17}, {"from":11, "to":17}, {"from":13, "to":17}, {"from":5, "to":19}, {"from":7, "to":19}, {"from":11, "to":19}, {"from":13, "to":19}, {"from":9, "to":21}, {"from":13, "to":21}, {"from":7, "to":21}, {"from":11, "to":21}, {"from":15, "to":21}, {"from":17, "to":21}, {"from":19, "to":21}, {"from":36, "to":35}, {"from":38, "to":37}, {"from":47, "to":48}, {"from":49, "to":50}, {"from":51, "to":52}, {"from":60, "to":39}, {"from":60, "to":41}, {"from":43, "to":60}, {"from":45, "to":60}, {"from":60, "to":40}, {"from":60, "to":42}, {"from":44, "to":60}, {"from":46, "to":60}, {"from":58, "to":53}, {"from":29, "to":53}, {"from":35, "to":54}, {"from":32, "to":31}, {"from":54, "to":31}, {"from":56, "to":32}, {"from":56, "to":55}, {"from":31, "to":55}, {"from":37, "to":56}, {"from":39, "to":56}, {"from":40, "to":56}, {"from":41, "to":56}, {"from":42, "to":56}, {"from":43, "to":56}, {"from":44, "to":56}, {"from":45, "to":56}, {"from":46, "to":56}, {"from":47, "to":56}, {"from":49, "to":56}, {"from":32, "to":57}, {"from":51, "to":58}, {"from":53, "to":35}, {"from":55, "to":37}, {"from":55, "to":39}, {"from":55, "to":40}, {"from":55, "to":41}, {"from":55, "to":42}, {"from":41, "to":43}, {"from":37, "to":43}, {"from":39, "to":43}, {"from":40, "to":43}, {"from":42, "to":43}, {"from":42, "to":44}, {"from":37, "to":44}, {"from":39, "to":44}, {"from":40, "to":44}, {"from":41, "to":44}, {"from":37, "to":45}, {"from":39, "to":45}, {"from":40, "to":45}, {"from":41, "to":45}, {"from":42, "to":45}, {"from":37, "to":46}, {"from":39, "to":46}, {"from":40, "to":46}, {"from":41, "to":46}, {"from":42, "to":46}, {"from":37, "to":47}, {"from":39, "to":47}, {"from":40, "to":47}, {"from":41, "to":47}, {"from":42, "to":47}, {"from":37, "to":49}, {"from":39, "to":49}, {"from":40, "to":49}, {"from":41, "to":49}, {"from":42, "to":49}, {"from":57, "to":51}, {"from":89, "to":88}, {"from":91, "to":92}, {"from":93, "to":94}, {"from":103, "to":88}, {"from":100, "to":95}, {"from":82, "to":95}, {"from":88, "to":96}, {"from":86, "to":97}, {"from":96, "to":97}, {"from":90, "to":98}, {"from":86, "to":99}, {"from":91, "to":100}, {"from":102, "to":86}, {"from":102, "to":101}, {"from":98, "to":101}, {"from":93, "to":102}, {"from":95, "to":88}, {"from":97, "to":90}, {"from":99, "to":91}, {"from":101, "to":93}, {"from":104, "to":90}, {"from":113, "to":112}, {"from":114, "to":115}, {"from":118, "to":117}, {"from":127, "to":112}, {"from":122, "to":119}, {"from":106, "to":119}, {"from":112, "to":120}, {"from":124, "to":108}, {"from":120, "to":108}, {"from":124, "to":121}, {"from":114, "to":122}, {"from":126, "to":123}, {"from":116, "to":124}, {"from":126, "to":125}, {"from":108, "to":125}, {"from":117, "to":126}, {"from":119, "to":112}, {"from":121, "to":114}, {"from":123, "to":116}, {"from":125, "to":117}, {"from":116, "to":128}, {"from":137, "to":136}, {"from":138, "to":139}, {"from":142, "to":141}, {"from":151, "to":136}, {"from":146, "to":143}, {"from":130, "to":143}, {"from":136, "to":144}, {"from":148, "to":132}, {"from":144, "to":132}, {"from":148, "to":145}, {"from":138, "to":146}, {"from":150, "to":147}, {"from":140, "to":148}, {"from":150, "to":149}, {"from":132, "to":149}, {"from":141, "to":150}, {"from":143, "to":136}, {"from":145, "to":138}, {"from":147, "to":140}, {"from":149, "to":141}, {"from":140, "to":152}]}';
var loopsJSON='{"columns":["", "Pipelined", "II", "Speculated iterations", "Details"], "children":[{"name":"Component: ImgSobelFunc", "data":["", "", ""], "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]], "details":[{"type":"brief", "text":"Task function"}, {"type":"text", "text":"Task function"}, {"type":"text", "text":"Fmax bottlenck block: None"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Component", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462820640727"}]}], "children":[{"name":"ImgSobelFunc.B1.start", "data":["Yes", "~1", "4"], "debug":[[{"filename":"Component invocation", "line":0}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: enabled."}, {"type":"text", "text":"II is an approximation due to the following stallable instructions:", "details":[{"type":"text", "text":"Stream Read Operation (%L)", "links":[{"filename":"./graph_test/sobel.h", "line":"30"}]}, {"type":"text", "text":"Stream Write Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./graph_test/sobel.h", "line":"39"}, {"filename":"./include/img_filter_base_intel.h", "line":"24"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/task.h", "line":"85"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/task.h", "line":"54"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/internal/_task_FPGA.h", "line":"43"}]}, {"type":"text", "text":"Stream Write Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./graph_test/sobel.h", "line":"34"}, {"filename":"./include/link_OpenCLIntel.h", "line":"144"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/task.h", "line":"85"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/task.h", "line":"54"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/internal/_task_FPGA.h", "line":"43"}]}, {"type":"text", "text":"Stream Write Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./graph_test/sobel.h", "line":"42"}, {"filename":"./include/link_OpenCLIntel.h", "line":"156"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/task.h", "line":"85"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/task.h", "line":"54"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/internal/_task_FPGA.h", "line":"43"}]}, {"type":"text", "text":"Stream Write Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./graph_test/sobel.h", "line":"45"}, {"filename":"./include/link_OpenCLIntel.h", "line":"156"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/task.h", "line":"85"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/task.h", "line":"54"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/internal/_task_FPGA.h", "line":"43"}]}, {"type":"text", "text":"Stream Read Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./graph_test/sobel.h", "line":"47"}, {"filename":"./include/img_filter_base_intel.h", "line":"30"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/task.h", "line":"95"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/task.h", "line":"61"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/internal/_task_FPGA.h", "line":"48"}]}, {"type":"text", "text":"Stream Read Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./graph_test/sobel.h", "line":"49"}, {"filename":"./include/link_OpenCLIntel.h", "line":"159"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/task.h", "line":"95"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/task.h", "line":"61"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/internal/_task_FPGA.h", "line":"48"}]}, {"type":"text", "text":"Stream Read Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./graph_test/sobel.h", "line":"50"}, {"filename":"./include/link_OpenCLIntel.h", "line":"159"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/task.h", "line":"95"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/task.h", "line":"61"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/internal/_task_FPGA.h", "line":"48"}]}, {"type":"text", "text":"Stream Write Operation (%L)", "links":[{"filename":"./graph_test/sobel.h", "line":"51"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[]}]}, {"name":"Task: ImgSobelIntel", "data":["", "", ""], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":10}]], "details":[{"type":"brief", "text":"Task function"}, {"type":"text", "text":"Task function"}, {"type":"text", "text":"Fmax bottlenck block: ImgSobelIntel.B4"}, {"type":"text", "text":"Use the %L report to view more details", "links":[{"view":"Fmax II Report"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Component", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462820640727"}]}], "children":[{"name":"ImgSobelIntel.B1.start", "data":["Yes", ">=1", "4"], "debug":[[{"filename":"Component invocation", "line":0}]], "details":[{"type":"brief", "text":"Serial exe: Memory dependency"}, {"type":"text", "text":"Iteration executed serially across ImgSobelIntel.B2. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobelIntel.B2. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobelIntel.B2. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobelIntel.B2. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobelIntel.B2. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1935"}, {"filename":"./include/img_filter_core.h", "line":"169"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobelIntel.B2. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1935"}, {"filename":"./include/img_filter_core.h", "line":"169"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobelIntel.B2. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1935"}, {"filename":"./include/img_filter_core.h", "line":"169"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobelIntel.B2. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1935"}, {"filename":"./include/img_filter_core.h", "line":"169"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}]}, {"type":"text", "text":"Hyper-Optimized loop structure: enabled."}, {"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[{"name":"ImgSobelIntel.B2", "data":["Yes", ">=1", "4"], "debug":[[{"filename":"./include/img_filter_core.h", "line":1888}]], "details":[{"type":"brief", "text":"Serial exe: Memory dependency"}, {"type":"text", "text":"User-constrained II."}, {"type":"text", "text":"Iteration executed serially across ImgSobelIntel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobelIntel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobelIntel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobelIntel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobelIntel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1935"}, {"filename":"./include/img_filter_core.h", "line":"169"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobelIntel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1935"}, {"filename":"./include/img_filter_core.h", "line":"169"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobelIntel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1935"}, {"filename":"./include/img_filter_core.h", "line":"169"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobelIntel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1935"}, {"filename":"./include/img_filter_core.h", "line":"169"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}]}, {"type":"text", "text":"Hyper-Optimized loop structure: enabled."}, {"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[{"name":"ImgSobelIntel.B4", "data":["Yes", "~1", "0"], "debug":[[{"filename":"./include/img_filter_core.h", "line":1890}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: disabled."}, {"type":"text", "text":"II is an approximation due to the following stallable instructions:", "details":[{"type":"text", "text":"Stream Read Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1918"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/hls.h", "line":"1075"}]}, {"type":"text", "text":"Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}, {"type":"text", "text":"Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}, {"type":"text", "text":"Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}, {"type":"text", "text":"Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}, {"type":"text", "text":"Store Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1935"}, {"filename":"./include/img_filter_core.h", "line":"169"}]}, {"type":"text", "text":"Store Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1935"}, {"filename":"./include/img_filter_core.h", "line":"169"}]}, {"type":"text", "text":"Store Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1935"}, {"filename":"./include/img_filter_core.h", "line":"169"}]}, {"type":"text", "text":"Store Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1935"}, {"filename":"./include/img_filter_core.h", "line":"169"}]}, {"type":"text", "text":"Stream Write Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1946"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/hls.h", "line":"1080"}]}, {"type":"text", "text":"Stream Write Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1952"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/hls.h", "line":"1080"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":67}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":74}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":77}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":89}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":92}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":98}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":142}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":145}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":153}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":157}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":167}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":308}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":311}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":319}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":326}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":329}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":355}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":360}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":367}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":377}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":1478}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":1481}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":680}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":683}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":720}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":723}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":1071}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":1134}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":1494}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":1497}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/img_filter_core.h", "line":1923}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}]}]}]}, {"name":"Task: vxReadDram", "data":["", "", ""], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":20}]], "details":[{"type":"brief", "text":"Task function"}, {"type":"text", "text":"Task function"}, {"type":"text", "text":"Fmax bottlenck block: None"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Component", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462820640727"}]}], "children":[{"name":"vxReadDram.B1.start", "data":["Yes", ">=1", "4"], "debug":[[{"filename":"Component invocation", "line":0}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: enabled."}, {"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: 1 is the default for component invocation loop"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[{"name":"vxReadDram.B2", "data":["Yes", ">=1", "4"], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":26}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: enabled."}, {"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":29}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"vxReadDram.B5", "data":["Yes", "~1", "4"], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":38}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: enabled."}, {"type":"text", "text":"II is an approximation due to the following stallable instruction:", "details":[{"type":"text", "text":"Stream Write Operation (%L > %L)", "links":[{"filename":"./include/link_OpenCLIntel.h", "line":"39"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/hls.h", "line":"1080"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[]}]}]}]}, {"name":"Task: vxWriteDram", "data":["", "", ""], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]], "details":[{"type":"brief", "text":"Task function"}, {"type":"text", "text":"Task function"}, {"type":"text", "text":"Fmax bottlenck block: vxWriteDram.B5"}, {"type":"text", "text":"Use the %L report to view more details", "links":[{"view":"Fmax II Report"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Component", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462820640727"}]}], "children":[{"name":"vxWriteDram.B1.start", "data":["Yes", ">=1", "4"], "debug":[[{"filename":"Component invocation", "line":0}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: enabled."}, {"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: 1 is the default for component invocation loop"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[{"name":"vxWriteDram.B2", "data":["Yes", ">=1", "4"], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":71}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: enabled."}, {"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[{"name":"vxWriteDram.B5", "data":["Yes", "~1", "0"], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":73}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: disabled."}, {"type":"text", "text":"II is an approximation due to the following stallable instruction:", "details":[{"type":"text", "text":"Stream Read Operation (%L > %L)", "links":[{"filename":"./include/link_OpenCLIntel.h", "line":"74"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/hls.h", "line":"1075"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":77}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":77}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}]}]}, {"name":"Task: vxWriteDram_1", "data":["", "", ""], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]], "details":[{"type":"brief", "text":"Task function"}, {"type":"text", "text":"Task function"}, {"type":"text", "text":"Fmax bottlenck block: vxWriteDram_1.B5"}, {"type":"text", "text":"Use the %L report to view more details", "links":[{"view":"Fmax II Report"}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Component", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462820640727"}]}], "children":[{"name":"vxWriteDram_1.B1.start", "data":["Yes", ">=1", "4"], "debug":[[{"filename":"Component invocation", "line":0}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: enabled."}, {"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: 1 is the default for component invocation loop"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[{"name":"vxWriteDram_1.B2", "data":["Yes", ">=1", "4"], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":71}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: enabled."}, {"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[{"name":"vxWriteDram_1.B5", "data":["Yes", "~1", "0"], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":73}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: disabled."}, {"type":"text", "text":"II is an approximation due to the following stallable instruction:", "details":[{"type":"text", "text":"Stream Read Operation (%L > %L)", "links":[{"filename":"./include/link_OpenCLIntel.h", "line":"74"}, {"filename":"/opt/intelFPGA_pro/19.4/hls/include/HLS/hls.h", "line":"1075"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[]}]}]}]}]}';
var fmax_iiJSON='{"basicblocks":{"ImgSobelFunc.B0.runOnce":{"name":"ImgSobelFunc.B0.runOnce", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":2, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":0, "loop_location":{}}, "ImgSobelFunc.B1.start":{"name":"ImgSobelFunc.B1.start", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":16, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"Yes", "is_single_block_loop":"Yes", "loop_layer":1, "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"Unknown location", "line":"0"}]}]}}, "ImgSobelIntel.B0.runOnce":{"name":"ImgSobelIntel.B0.runOnce", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":2, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":0, "loop_location":{}}, "ImgSobelIntel.B1.start":{"name":"ImgSobelIntel.B1.start", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":9, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"Yes", "is_single_block_loop":"No", "loop_layer":1, "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"Unknown location", "line":"0"}]}]}}, "ImgSobelIntel.B2":{"name":"ImgSobelIntel.B2", "target_fmax":"Not specified", "target_ii":"1", "achieved_fmax":"480.0", "achieved_ii":1, "latency":9, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"Yes", "is_single_block_loop":"No", "loop_layer":2, "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"./include/img_filter_core.h", "line":"1888"}]}]}}, "ImgSobelIntel.B3":{"name":"ImgSobelIntel.B3", "target_fmax":"Not specified", "target_ii":"1", "achieved_fmax":"480.0", "achieved_ii":1, "latency":0, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":2, "loop_location":{}}, "ImgSobelIntel.B4":{"name":"ImgSobelIntel.B4", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"388.8", "achieved_ii":1, "latency":88, "max_interleaving":1, "is_fmax_bottleneck":"Yes", "is_loop_header":"Yes", "is_single_block_loop":"Yes", "loop_layer":3, "details":[{"type":"text", "text":"Variable on loop carried feedback path", "details":[{"type":"text", "text":"From: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}, {"type":"text", "text":"To: Load Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1929"}, {"filename":"./include/img_filter_core.h", "line":"69"}]}, {"type":"text", "text":"From: Store Operation (%L > %L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1935"}, {"filename":"./include/img_filter_core.h", "line":"169"}]}]}, {"type":"text", "text":"Loop feedback path that lowered Fmax ", "details":[{"type":"text", "text":"Node: 16-bit Integer Add Operation (%L > %L > %L > %L)", "links":[{"filename":"./include/img_filter_base_intel.h", "line":"11"}, {"filename":"./include/img_filter_core.h", "line":"2749"}, {"filename":"./include/img_filter_core.h", "line":"2215"}, {"filename":"./include/img_filter_core.h", "line":"1890"}]}]}], "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"./include/img_filter_core.h", "line":"1890"}]}]}}, "ImgSobelIntel.B5":{"name":"ImgSobelIntel.B5", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":0, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":1, "loop_location":{}}, "vxReadDram.B0.runOnce":{"name":"vxReadDram.B0.runOnce", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":2, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":0, "loop_location":{}}, "vxReadDram.B1.start":{"name":"vxReadDram.B1.start", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":14, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"Yes", "is_single_block_loop":"No", "loop_layer":1, "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"Unknown location", "line":"0"}]}]}}, "vxReadDram.B2":{"name":"vxReadDram.B2", "target_fmax":"Not specified", "target_ii":"1", "achieved_fmax":"480.0", "achieved_ii":1, "latency":87, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"Yes", "is_single_block_loop":"No", "loop_layer":2, "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"./include/link_OpenCLIntel.h", "line":"26"}]}]}}, "vxReadDram.B3":{"name":"vxReadDram.B3", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":5, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":1, "loop_location":{}}, "vxReadDram.B4":{"name":"vxReadDram.B4", "target_fmax":"Not specified", "target_ii":"1", "achieved_fmax":"480.0", "achieved_ii":1, "latency":0, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":2, "loop_location":{}}, "vxReadDram.B5":{"name":"vxReadDram.B5", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":9, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"Yes", "is_single_block_loop":"Yes", "loop_layer":3, "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"./include/link_OpenCLIntel.h", "line":"38"}]}]}}, "vxWriteDram.B0.runOnce":{"name":"vxWriteDram.B0.runOnce", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":2, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":0, "loop_location":{}}, "vxWriteDram.B1.start":{"name":"vxWriteDram.B1.start", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":14, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"Yes", "is_single_block_loop":"No", "loop_layer":1, "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"Unknown location", "line":"0"}]}]}}, "vxWriteDram.B2":{"name":"vxWriteDram.B2", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":8, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"Yes", "is_single_block_loop":"No", "loop_layer":2, "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"./include/link_OpenCLIntel.h", "line":"71"}]}]}}, "vxWriteDram.B3":{"name":"vxWriteDram.B3", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":0, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":1, "loop_location":{}}, "vxWriteDram.B4":{"name":"vxWriteDram.B4", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":34, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":2, "loop_location":{}}, "vxWriteDram.B5":{"name":"vxWriteDram.B5", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"432.0", "achieved_ii":1, "latency":13, "max_interleaving":1, "is_fmax_bottleneck":"Yes", "is_loop_header":"Yes", "is_single_block_loop":"Yes", "loop_layer":3, "details":[{"type":"text", "text":"Variable on loop carried feedback path"}], "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"./include/link_OpenCLIntel.h", "line":"73"}]}]}}, "vxWriteDram_1.B0.runOnce":{"name":"vxWriteDram_1.B0.runOnce", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":2, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":0, "loop_location":{}}, "vxWriteDram_1.B1.start":{"name":"vxWriteDram_1.B1.start", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":14, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"Yes", "is_single_block_loop":"No", "loop_layer":1, "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"Unknown location", "line":"0"}]}]}}, "vxWriteDram_1.B2":{"name":"vxWriteDram_1.B2", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":8, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"Yes", "is_single_block_loop":"No", "loop_layer":2, "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"./include/link_OpenCLIntel.h", "line":"71"}]}]}}, "vxWriteDram_1.B3":{"name":"vxWriteDram_1.B3", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":0, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":1, "loop_location":{}}, "vxWriteDram_1.B4":{"name":"vxWriteDram_1.B4", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":34, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":2, "loop_location":{}}, "vxWriteDram_1.B5":{"name":"vxWriteDram_1.B5", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"432.0", "achieved_ii":1, "latency":13, "max_interleaving":1, "is_fmax_bottleneck":"Yes", "is_loop_header":"Yes", "is_single_block_loop":"Yes", "loop_layer":3, "details":[{"type":"text", "text":"Variable on loop carried feedback path"}], "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"./include/link_OpenCLIntel.h", "line":"73"}]}]}}}, "functions":{"ImgSobelFunc":{"debug":[{"filename":"./graph_test/sobel.h", "line":30}], "loop_hierachy":{"ImgSobelFunc__no_loop":["ImgSobelFunc.B0.runOnce"], "ImgSobelFunc.B1.start":["ImgSobelFunc.B1.start"]}}, "ImgSobelIntel":{"debug":[{"filename":"./include/img_filter_base_intel.h", "line":10}], "loop_hierachy":{"ImgSobelIntel__no_loop":["ImgSobelIntel.B0.runOnce"], "ImgSobelIntel.B1.start":["ImgSobelIntel.B1.start", "ImgSobelIntel.B2", "ImgSobelIntel.B5"], "ImgSobelIntel.B2":["ImgSobelIntel.B2", "ImgSobelIntel.B4", "ImgSobelIntel.B3"], "ImgSobelIntel.B4":["ImgSobelIntel.B4"]}}, "vxReadDram":{"debug":[{"filename":"./include/link_OpenCLIntel.h", "line":20}], "loop_hierachy":{"vxReadDram__no_loop":["vxReadDram.B0.runOnce"], "vxReadDram.B1.start":["vxReadDram.B1.start", "vxReadDram.B2", "vxReadDram.B3"], "vxReadDram.B2":["vxReadDram.B2", "vxReadDram.B5", "vxReadDram.B4"], "vxReadDram.B5":["vxReadDram.B5"]}}, "vxWriteDram":{"debug":[{"filename":"./include/link_OpenCLIntel.h", "line":68}], "loop_hierachy":{"vxWriteDram__no_loop":["vxWriteDram.B0.runOnce"], "vxWriteDram.B1.start":["vxWriteDram.B1.start", "vxWriteDram.B2", "vxWriteDram.B3"], "vxWriteDram.B2":["vxWriteDram.B2", "vxWriteDram.B5", "vxWriteDram.B4"], "vxWriteDram.B5":["vxWriteDram.B5"]}}, "vxWriteDram_1":{"debug":[{"filename":"./include/link_OpenCLIntel.h", "line":68}], "loop_hierachy":{"vxWriteDram_1__no_loop":["vxWriteDram_1.B0.runOnce"], "vxWriteDram_1.B1.start":["vxWriteDram_1.B1.start", "vxWriteDram_1.B2", "vxWriteDram_1.B3"], "vxWriteDram_1.B2":["vxWriteDram_1.B2", "vxWriteDram_1.B5", "vxWriteDram_1.B4"], "vxWriteDram_1.B5":["vxWriteDram_1.B5"]}}}}';
var summaryJSON='{"performanceSummary":{"name":"Function Summary", "columns":["Function Name", "Hyper-Optimized Handshaking"], "children":[{"name":"ImgSobelFunc", "data":["Off"], "details":[{"type":"text", "text":"Hyper-optimized handshaking disabled due to instruction in Kernel vxWriteDram"}], "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]]}, {"name":"ImgSobelIntel", "data":["Off"], "details":[{"type":"text", "text":"Hyper-optimized handshaking disabled due to instruction in Kernel vxWriteDram"}], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":10}]]}, {"name":"vxReadDram", "data":["Off"], "details":[{"type":"text", "text":"Hyper-optimized handshaking disabled due to instruction in Kernel vxWriteDram"}], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":20}]]}, {"name":"vxWriteDram", "data":["Off"], "details":[{"type":"text", "text":"Hyper-optimized handshaking disabled due to loop orchestration compiler optimization being disabled in loop vxWriteDram.B5."}], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]]}, {"name":"vxWriteDram_1", "data":["Off"], "details":[{"type":"text", "text":"Hyper-optimized handshaking disabled due to instruction in Kernel vxWriteDram"}], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]]}]}, "functionNameMapping":{"name":"Synthesized Function Name Mapping", "columns":["User-defined Function Name", "Mapped Function Name"], "children":[{"name":"void ImgSobelFunc<unsigned char, signed char, (unsigned char)8, (unsigned short)3840, (unsigned short)2160, (unsigned char)3, (vx_border_e)49153>(ihc::mm_master<vx_image_t<unsigned char, 8ul>, ihc::aspace<1>, ihc::awidth<32>, ihc::dwidth<512>, ihc::latency<0>, ihc::maxburst<16>, ihc::align<64>, ihc::waitrequest<1> >&, ihc::mm_master<vx_image_t<signed char, 8ul>, ihc::aspace<2>, ihc::awidth<32>, ihc::dwidth<512>, ihc::latency<0>, ihc::maxburst<16>, ihc::align<64>, ihc::waitrequest<1> >&, ihc::mm_master<vx_image_t<signed char, 8ul>, ihc::aspace<3>, ihc::awidth<32>, ihc::dwidth<512>, ihc::latency<0>, ihc::maxburst<16>, ihc::align<64>, ihc::waitrequest<1> >&)", "data":["ImgSobelFunc"], "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]]}, {"name":"void ImgSobelIntel<unsigned char, signed char, (unsigned char)8, (unsigned short)3840, (unsigned short)2160, (unsigned char)3, (vx_border_e)49153, 2, 2, 2, ihc::stream<vx_image_t<unsigned char, 8ul>, ihc::buffer<256> >&, ihc::stream<vx_image_t<signed char, 8ul>, ihc::buffer<256> >&, ihc::stream<vx_image_t<signed char, 8ul>, ihc::buffer<256> >&, stream_r_0, streamX_1_2, streamY_1_2>()", "data":["ImgSobelIntel"], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":10}]]}, {"name":"void vxReadDram<unsigned char, ihc::stream<vx_image_t<unsigned char, 8ul>, ihc::buffer<256> >&, stream_r_0, ihc::mm_master<vx_image_t<unsigned char, 8ul>, ihc::aspace<1>, ihc::awidth<32>, ihc::dwidth<512>, ihc::latency<0>, ihc::maxburst<16>, ihc::align<64>, ihc::waitrequest<1> >, (unsigned char)8, (unsigned short)3840, (unsigned short)2160, 8u>(ihc::mm_master<vx_image_t<unsigned char, 8ul>, ihc::aspace<1>, ihc::awidth<32>, ihc::dwidth<512>, ihc::latency<0>, ihc::maxburst<16>, ihc::align<64>, ihc::waitrequest<1> >*)", "data":["vxReadDram"], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":20}]]}, {"name":"void vxWriteDram<signed char, ihc::stream<vx_image_t<signed char, 8ul>, ihc::buffer<256> >&, streamY_1_2, ihc::mm_master<vx_image_t<signed char, 8ul>, ihc::aspace<3>, ihc::awidth<32>, ihc::dwidth<512>, ihc::latency<0>, ihc::maxburst<16>, ihc::align<64>, ihc::waitrequest<1> >, (unsigned char)8, (unsigned short)3840, (unsigned short)2160, 8u>(ihc::mm_master<vx_image_t<signed char, 8ul>, ihc::aspace<3>, ihc::awidth<32>, ihc::dwidth<512>, ihc::latency<0>, ihc::maxburst<16>, ihc::align<64>, ihc::waitrequest<1> >*)", "data":["vxWriteDram"], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]]}, {"name":"void vxWriteDram<signed char, ihc::stream<vx_image_t<signed char, 8ul>, ihc::buffer<256> >&, streamX_1_2, ihc::mm_master<vx_image_t<signed char, 8ul>, ihc::aspace<2>, ihc::awidth<32>, ihc::dwidth<512>, ihc::latency<0>, ihc::maxburst<16>, ihc::align<64>, ihc::waitrequest<1> >, (unsigned char)8, (unsigned short)3840, (unsigned short)2160, 8u>(ihc::mm_master<vx_image_t<signed char, 8ul>, ihc::aspace<2>, ihc::awidth<32>, ihc::dwidth<512>, ihc::latency<0>, ihc::maxburst<16>, ihc::align<64>, ihc::waitrequest<1> >*)", "data":["vxWriteDram_1"], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]]}]}, "estimatedResources":{"name":"Estimated Resource Usage", "columns":["Function Name", "ALUTs ", "FFs  ", "RAMs ", "DSPs ", "MLABs"], "children":[{"name":"ImgSobelFunc", "data":[203, 267, 0, 0, 14], "debug":[[{"filename":"./graph_test/sobel.h", "line":30}]]}, {"name":"ImgSobelIntel", "data":[5650, 8854, 19, 0, 75], "debug":[[{"filename":"./include/img_filter_base_intel.h", "line":10}]]}, {"name":"vxReadDram", "data":[10569, 39520, 17, 0, 220], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":20}]]}, {"name":"vxWriteDram", "data":[4181, 11954, 19, 0, 62], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]]}, {"name":"vxWriteDram_1", "data":[4181, 11954, 19, 0, 62], "debug":[[{"filename":"./include/link_OpenCLIntel.h", "line":68}]]}, {"name":"Total", "classes":["summary-highlight", "nohover"], "data":[24784, 72549, 74, 0, 433], "data_percent":[1.32802, 1.94372, 0.631345, 0]}, {"name":"Available", "classes":["summary-highlight", "nohover"], "data":[1866240, 3732480, 11721, 5760, 0]}]}, "compileWarnings":{"name":"Compile Warnings", "children":[]}}';
var infoJSON='{"name":"Info","rows":[{"classes":["info-table"],"data":["./HiFlipVX_Intel"],"name":"Project Name"},{"data":["Stratix10, 1SM21BHU2F53E2VGS1"],"name":"Target Family, Device"},{"data":["19.4.0 Build 64"],"name":"i++ Version"},{"data":["19.4.0 Build 64 Pro"],"name":"Quartus Version"},{"data":["i++ ./include/bmp_tool/bmp_tools.cpp ./graph_test/sobel.cpp -D Intel -I./include -I./include/bmp_tool -I./graph_test -march=1sm21bhu2f53e2vgs1 --simulator none -v -o HiFlipVX_Intel"],"name":"Command"},{"data":["Tue Jun 30 12:32:50 2020"],"name":"Reports Generated At"}]}';
var warningsJSON='{"rows":[]}';
var quartusJSON='{"quartusFitClockSummary":{"children":[{"details":[{"text":"This section contains a summary of the area and f<sub>MAX</sub> data generated by compiling the components through Quartus. \\nTo generate the data, run a Quartus compile on the project created for this design. To run the Quartus compile:\\n  1) Change to the quartus directory (./HiFlipVX_Intel.prj/quartus)\\n  2) quartus_sh --flow compile quartus_compile\\n","type":"text"}],"name":"Run Quartus compile to populate this section. See details for more information."}],"name":"Quartus Fit Summary"}}';
var fileJSON=[{"path":"/opt/intelFPGA_pro/19.4/hls/include/HLS/internal/_task_FPGA.h", "name":"_task_FPGA.h", "has_active_debug_locs":false, "absName":"/opt/intelFPGA_pro/19.4/hls/include/HLS/internal/_task_FPGA.h", "content":"#ifndef _INTEL_IHC_HLS_INTERNAL__TASK_FPGA\012#define _INTEL_IHC_HLS_INTERNAL__TASK_FPGA\012#include \"HLS/function_traits.h\"\012\012namespace ihc {\012  namespace internal {\012    // The task is a singleton that is shared between\012    // a calculation and its result:\012    // * Identify the functionality\012    //   task<function>::instance()\012    // * Launch the calculations\012    //   task<function>::instance().launch(args...);\012    // * Get the results\012    //   [ret = ]task<function>::instance().collect();\012    //      > blocking until launch is finished\012    //      > returns result for non-void function\012    //\012    // When the main program exits, any pending\012    // launches will still be processed in their\012    // respective thread\012    template<typename X, X& f, bool detach = false>\012    class _task {\012    public:\012      // using F: typename X is different between compilers!\012      using F = decltype(f);\012      using T = typename ihc::function_traits<F>::return_type;\012\012      // Constructor\012      _task() {}\012\012      // Disable copy-assignment operator\012      _task& operator=(const _task& rhs) = delete;\012\012      // Disable copy constructor\012      _task(const _task& other) = delete;\012\012      // Destructor\012      // Can't be explicit for FPGA target in Intel(R) HLS Compiler\012      //~_task() {}\012\012      template<int capacity, typename ... Args>\012      void launch(Args&&... args) {\012        __builtin_intel_hls_enqueue(capacity, f, std::forward<Args>(args)...);\012      } // launch\012\012      template<int capacity>\012      T collect() {\012        return static_cast<T>(__builtin_intel_hls_get(capacity, f));\012      }\012\012    }; // class _task\012\012  } //namespace internal\012} // namespace ihc\012\012#endif // _INTEL_IHC_HLS_INTERNAL__TASK_FPGA\012"}, {"path":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/bmp_tool/bmp_tools.cpp", "name":"bmp_tools.cpp", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/bmp_tool/bmp_tools.cpp", "content":"// Copyright (C) 2013-2019 Altera Corporation, San Jose, California, USA. All rights reserved.\012// Permission is hereby granted, free of charge, to any person obtaining a copy of this\012// software and associated documentation files (the \"Software\"), to deal in the Software\012// without restriction, including without limitation the rights to use, copy, modify, merge,\012// publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to\012// whom the Software is furnished to do so, subject to the following conditions:\012// The above copyright notice and this permission notice shall be included in all copies or\012// substantial portions of the Software.\012// \012// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\012// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\012// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\012// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\012// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\012// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\012// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\012// OTHER DEALINGS IN THE SOFTWARE.\012// \012// This agreement shall be governed in all respects by the laws of the State of California and\012// by the laws of the United States of America.\012\012// bmp_tools.cpp\012\012#include \"bmp_tools.h\"\012#include <stdio.h>\012#include <stdlib.h>\012\012// Bitmap header size in bytes\012static const int BMP_HEADER_SIZE = 54;\012\012void read_bmp (const char* filename, unsigned int** img_data, int& height, int& width) {\012  FILE *fp;\012#if defined(_WIN32) || defined(_WIN64)\012  if (fopen_s(&fp, filename, \"rb\") !=0) {\012#else\012  if ((fp=fopen(filename,\"rb\"))==NULL) {\012#endif\012    printf(\"can't open file %s for binary reading\\n\", filename);\012    exit(1);\012  }\012\012  // Skip over unimportant parts of header\012  for (int i=0; i<18; i++) fgetc(fp); \012  \012  //read width and height\012  fread(&width, sizeof(int), 1, fp);\012  fread(&height, sizeof(int), 1, fp);\012  if (height < 0 || width < 0) {\012    printf(\"error got height %d, width %d\\n\", height, width);\012    exit(1);\012  }\012  printf(\"image size is %d (width) by %d (height) pixels\\n\", width, height);\012  *img_data = (unsigned int*) malloc(width * height * sizeof(unsigned int));\012\012  // Skip remaining part of header\012  for (int i=0; i<28; i++) fgetc(fp);\012  \012  // BMP: Each line must be a multiple of 4 bytes\012  int padding = (4-((width*3)&3))&3;\012  int idx=0;      \012  // Color order is BGR, read across bottom row, then repeat going up rows\012  for (int i=0; i< height; ++i) {\012	  for (int j=0; j< width; ++j) {\012      unsigned char b = fgetc(fp); //B\012      unsigned char g = fgetc(fp); //G\012      unsigned char r = fgetc(fp); //R\012      (*img_data)[idx] = (((unsigned int ) r << 16) | ((unsigned int ) g << 8) | ((unsigned int ) b << 0));\012      idx++;\012	  }\012	  // Discard the padding bytes\012	  for (int j=0; j< padding; ++j) {\012	  	unsigned char b = fgetc(fp);\012	  }\012  }\012  fclose(fp);\012}\012\012void write_bmp (const char* filename, unsigned int* img_data, int& height, int& width) {\012  FILE *fp;\012  unsigned int file_size = width * height * 3 + BMP_HEADER_SIZE;\012  unsigned char header[BMP_HEADER_SIZE] = { 0x42, 0x4d,         // BMP & DIB\012                                        (static_cast<unsigned char>(file_size & 0xff)), (static_cast<unsigned char>((file_size >> 8) & 0xff)), (static_cast<unsigned char>((file_size >> 16) & 0xff)), (static_cast<unsigned char>((file_size >> 24) & 0xff)), // size of file in bytes\012                                        0x00, 0x00, 0x00, 0x00, // reserved\012                                        0x36, 0x00, 0x00, 0x00, // offset of start of image data\012                                        0x28, 0x00, 0x00, 0x00, // size of the DIB header\012                                        (static_cast<unsigned char>(width & 0xff)), (static_cast<unsigned char>((width >> 8) & 0xff)), (static_cast<unsigned char>((width >> 16) & 0xff)), (static_cast<unsigned char>((width >> 24) & 0xff)),     // width in pixels\012                                        (static_cast<unsigned char>(height & 0xff)), (static_cast<unsigned char>((height >> 8) & 0xff)), (static_cast<unsigned char>((height >> 16) & 0xff)), (static_cast<unsigned char>((height >> 24) & 0xff)), // height in pixels\012                                        0x01, 0x00, // number of color planes\012                                        0x18, 0x00, // number of bits per pixel\012                                        0x00, 0x00, 0x00, 0x00, // no compression - BI_RGB\012                                        0x00, 0x00, 0x00, 0x00, // image size - dummy 0 for BI_RGB\012                                        0x13, 0x0b, 0x00, 0x00, // horizontal ppm\012                                        0x13, 0x0b, 0x00, 0x00, // vertical ppm\012                                        0x00, 0x00, 0x00, 0x00, // default 2^n colors in palatte\012                                        0x00, 0x00, 0x00, 0x00  // every color is important\012                                      };\012  // Open file for write\012#if defined(_WIN32) || defined(_WIN64)\012  if (fopen_s(&fp, filename, \"wb\") !=0) {\012#else\012  if ((fp=fopen(filename,\"wb\"))==NULL) {\012#endif\012    printf(\"can't open file %s for binary writing\\n\", filename); \012    exit(1);\012  }\012\012  // Write header\012  fwrite(header, 1, BMP_HEADER_SIZE, fp);\012\012  // Write data: Line size must be a multiple of 4 bytes\012  int padding = (4-((width*3)&3))&3;\012  int idx = 0;\012  for (int i = 0; i <  height; ++i) {\012    unsigned char p[3];\012    for (int j = 0; j < width ; ++j) {\012      // written in B, G, R order\012      p[0] = (img_data[idx] >>  0) & 0xff; //B\012      p[1] = (img_data[idx] >>  0) & 0xff; //G\012      p[2] = (img_data[idx] >>  0) & 0xff; //R\012      idx++;\012      fwrite(p, 1, 3, fp);\012    }\012    // Pad to multiple of 4 bytes\012    if (padding) {\012    	p[0]=p[1]=p[2]=0;\012    	fwrite(p,1,padding,fp);\012    }\012  }\012  fclose(fp);\012}\012"}, {"path":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/bmp_tool/bmp_tools.h", "name":"bmp_tools.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/bmp_tool/bmp_tools.h", "content":"// Copyright (C) 2013-2019 Altera Corporation, San Jose, California, USA. All rights reserved.\012// Permission is hereby granted, free of charge, to any person obtaining a copy of this\012// software and associated documentation files (the \"Software\"), to deal in the Software\012// without restriction, including without limitation the rights to use, copy, modify, merge,\012// publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to\012// whom the Software is furnished to do so, subject to the following conditions:\012// The above copyright notice and this permission notice shall be included in all copies or\012// substantial portions of the Software.\012// \012// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\012// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\012// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\012// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\012// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\012// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\012// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\012// OTHER DEALINGS IN THE SOFTWARE.\012// \012// This agreement shall be governed in all respects by the laws of the State of California and\012// by the laws of the United States of America.\012\012// bmp_tools.h\012#ifndef BMP_TOOLS_H\012#define BMP_TOOLS_H\012\012void read_bmp (const char* filename, unsigned int** img_data, int& height, int& width);\012void write_bmp (const char* filename, unsigned int* img_data, int& height, int& width);\012\012#endif // BMP_TOOLS_H\012"}, {"path":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/graph_test/definitions.h", "name":"definitions.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/graph_test/definitions.h", "content":"//// Conversion from Xilinx to intel follow this rules:\012//https://www.intel.com/content/www/us/en/programmable/documentation/mtr1422491996806.html#mtr1422491925947 to intel follow this rules:\012\012// Image Size\012#ifndef SRC_IMG_CONSTANTS_H_\012#define SRC_IMG_CONSTANTS_H_ \012\012const vx_uint16 COLS_FHD = 1920*2;\012const vx_uint16 ROWS_FHD =  1080*2;\012//const vx_uint16 COLS_FHD = 1920;\012//const vx_uint16 ROWS_FHD =  1080;\012//const vx_uint16 COLS_FHD = 680;\012//const vx_uint16 ROWS_FHD = 480;\012//const vx_uint16 COLS_FHD = 680;\012//const vx_uint16 ROWS_FHD = 480;\012//const vx_uint16 COLS_FHD = 528;\012//const vx_uint16 ROWS_FHD =  352;\012const auto PIXELS_FHD = COLS_FHD*ROWS_FHD;\012//const vx_uint16 COLS_HD = 1280;\012//const vx_uint16 ROWS_HD = 720;\012//const auto PIXELS_HD = COLS_HD*ROWS_HD;\012\012// Vectorization\012const vx_uint8 VEC_NUM = 8;\012//const vx_uint8 VEC_NUM = 8;\012const vx_uint16 VEC_PIX = static_cast<vx_uint16>(PIXELS_FHD / VEC_NUM);\012\012// Defines\012const vx_uint8 FILTER_SIZE = 3;\012#define SEPARABLE_FILTER   (vx_bool)vx_true_e\012#define CONVOLVE_FILTER_SIZE 3\012#define BOX_BORDER      VX_BORDER_CONSTANT\012#define CONVOLVE_BORDER VX_BORDER_CONSTANT\012#define DILATE_BORDER   VX_BORDER_CONSTANT\012#define ERODE_BORDER    VX_BORDER_CONSTANT\012#define GAUSSIAN_BORDER VX_BORDER_CONSTANT\012#define MEDIAN_BORDER   VX_BORDER_REPLICATE\012#define SCHARR_BORDER   VX_BORDER_CONSTANT\012#define SOBEL_BORDER    VX_BORDER_CONSTANT\012\012//histogram\012#define HIST_BINS   256\012#define HIST_OFFSET 0\012#define HIST_RANGE  (1 << 8)            // (1 << 8), (1 << 16)\012//autoc\012#define EXTRACT_CHANNELY 0  \012#define EXTRACT_CHANNELU 1  \012#define EXTRACT_CHANNELV 2  \012\012#define COMB_CHANNEL 3  \012\012\012#define EXTRACT_TYPE    VX_DF_IMAGE_NV12\012\012\012#endif\012\012"}, {"path":"/opt/intelFPGA_pro/19.4/hls/include/HLS/function_traits.h", "name":"function_traits.h", "has_active_debug_locs":false, "absName":"/opt/intelFPGA_pro/19.4/hls/include/HLS/function_traits.h", "content":"#ifndef _INTEL_IHC_HLS_FUNCTION_TRAITS\012#define _INTEL_IHC_HLS_FUNCTION_TRAITS\012\012namespace ihc {\012  // Some metaprogramming to extract the return type\012  // from a function type\012  template<typename F>\012  struct function_traits {\012    using return_type = F;\012  };\012\012  template<typename R, typename... Args>\012  struct function_traits<R(*)(Args...)>\012  {\012    using return_type = R;\012  };\012\012  template<typename R, typename... Args>\012  struct function_traits<R(&)(Args...)>\012  {\012    using return_type = R;\012  };\012}\012\012#endif // _INTEL_IHC_HLS_FUNCTION_TRAITS\012"}, {"path":"/opt/intelFPGA_pro/19.4/hls/include/HLS/hls.h", "name":"hls.h", "has_active_debug_locs":false, "absName":"/opt/intelFPGA_pro/19.4/hls/include/HLS/hls.h", "content":"#ifndef __HLS_H__\012#define __HLS_H__\012\012#ifdef __INTELFPGA_COMPILER__\012   // Compiling for FPGA or x86 using FPGA compiler\012#  undef component\012#  define component __attribute__((ihc_component)) __attribute__((noinline))\012#else\012#  ifndef component\012#    define component\012#  endif\012#  ifndef HLS_X86\012#    define HLS_X86\012#  endif\012#endif\012#include <type_traits>\012#include \"HLS/hls_internal.h\"\012#include \"HLS/task.h\"\012#include \"HLS/lsu.h\"\012\012#ifdef _MSC_VER\012#pragma warning(push)\012#pragma warning(disable:4265) // has virtual functions, but destructor is not virtual\012#pragma warning(disable:4505) // unreferenced local function has been removed\012#endif\012\012#ifdef __INTELFPGA_COMPILER__\012// Memory attributes\012#define hls_register                                  __attribute__((__register__))\012#define hls_memory                                    __attribute__((__memory__))\012#define hls_memory_impl(__x)                          __attribute__((__memory__(__x)))\012#define hls_numbanks(__x)                             __attribute__((__numbanks__(__x)))\012#define hls_bankwidth(__x)                            __attribute__((__bankwidth__(__x)))\012#define hls_singlepump                                __attribute__((__singlepump__))\012#define hls_doublepump                                __attribute__((__doublepump__))\012#define hls_numports_readonly_writeonly(__rd, __wr)   __attribute__((__numports_readonly_writeonly__(__rd, __wr)))\012#define hls_bankbits(__x, ...)                        __attribute__((__bank_bits__(__x, ##__VA_ARGS__)))\012#define hls_merge(__x, __y)                           __attribute__((merge(__x, __y)))\012#define hls_init_on_reset                             __attribute__((__static_array_reset__(1)))\012#define hls_init_on_powerup                           __attribute__((__static_array_reset__(0)))\012#define hls_numreadports(__x)                         __attribute__((__numreadports__(__x)))\012#define hls_numwriteports(__x)                        __attribute__((__numwriteports__(__x)))\012#define hls_simple_dual_port_memory                   __attribute__((simple_dual_port))\012#define hls_max_replicates(__x)                       __attribute__((max_replicates(__x)))\012\012// Interface synthesis attributes\012#define hls_avalon_streaming_component         __attribute__((component_interface(\"avalon_streaming\")))\012#define hls_avalon_slave_component             __attribute__((component_interface(\"avalon_mm_slave\"))) __attribute__((stall_free_return))\012#define hls_always_run_component               __attribute__((component_interface(\"always_run\"))) __attribute__((stall_free_return))\012#define hls_conduit_argument                   __attribute__((argument_interface(\"wire\")))\012#define hls_avalon_slave_register_argument     __attribute__((argument_interface(\"avalon_mm_slave\")))\012#define hls_avalon_slave_memory_argument(__x)  __attribute__((local_mem_size(__x))) __attribute__((slave_memory_argument))\012#define hls_stable_argument                    __attribute__((stable_argument))\012#define hls_stall_free_return                  __attribute__((stall_free_return))\012\012// Component attributes\012#define hls_max_concurrency(__x)               __attribute__((max_concurrency(__x)))\012#define hls_scheduler_target_fmax_mhz(__x)     __attribute__((scheduler_target_fmax_mhz(__x)))\012#define hls_component_ii(__x)                  __attribute__((hls_ii(__x)))\012#define hls_disable_component_pipelining       __attribute__((hls_force_loop_pipelining(\"off\")))\012\012// Cluster attributes\012#define hls_use_stall_enable_clusters          __attribute__((stall_enable))\012\012// fpga_reg support\012#define hls_fpga_reg(__x)                      __fpga_reg(__x)\012\012#else\012#define hls_register\012#define hls_memory\012#define hls_numbanks(__x)\012#define hls_bankwidth(__x)\012#define hls_singlepump\012#define hls_doublepump\012#define hls_numports_readonly_writeonly(__rd, __wr)\012#define hls_bankbits(__x, ...)\012#define hls_merge(__x, __y)\012#define hls_init_on_reset\012#define hls_init_on_powerup\012\012#define hls_numreadports(__x)\012#define hls_numwriteports(__x)\012\012#define hls_simple_dual_port_memory\012#define hls_max_replicates(__x)\012\012#define hls_avalon_streaming_component\012#define hls_avalon_slave_component\012#define hls_always_run_component\012#define hls_conduit_argument\012#define hls_avalon_slave_register_argument\012#define hls_avalon_slave_memory_argument(__x)\012#define hls_stable_argument\012#define hls_stall_free_return\012\012#define hls_max_concurrency(__x)\012#define hls_scheduler_target_fmax_mhz(__x)\012#define hls_component_ii(__x)\012#define hls_disable_component_pipelining\012\012#define hls_use_stall_enable_clusters\012\012#define hls_fpga_reg(__x) __x\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Interfaces Declarations\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012\012  ////////////////////////////////\012 /// memory master interface  ///\012////////////////////////////////\012\012  template<int _N> struct dwidth {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 64;\012  };\012\012  template<int _N> struct awidth {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 64;\012  };\012\012  template<int _N> struct latency {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 1;\012  };\012\012  template<int _N> struct readwrite_mode {\012    // Should be enum readwrite_t but we don't know how to make GetValue generic\012    static constexpr enum readwrite_t value = (readwrite_t) _N;\012    static constexpr enum readwrite_t defaultValue = readwrite;\012  };\012\012  template<int _N> struct maxburst {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 1;\012  };\012\012  template<int _N> struct align {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = -1;\012  };\012\012  template<int _N> struct aspace {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 1;\012  };\012\012  template<int _N> struct waitrequest {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = false;\012  };\012\012  template <template <int> class _Type, class _T>\012  struct MatchType : std::is_same<_Type<_T::value>,_T> {};\012\012  template <template <int> class _Type, class ... _T>\012  struct GetValue {\012    // any value is ok here, so '0' is fine for an arbitrary instantiation\012    enum { value = _Type<0>::defaultValue };\012    // only when _T is empty\012  };\012\012  template <template <int> class _Type, class _T1, class ... _T>\012  struct GetValue<_Type, _T1, _T...> {\012    enum { value = std::conditional<MatchType<_Type, _T1>::value, _T1, GetValue<_Type, _T...>>::type::value };\012  };\012\012template <typename _DT, class ... _Params>\012class mm_master final\012#ifdef HLS_X86\012  : public internal::memory_base\012#endif\012{\012public:\012\012#ifdef HLS_X86\012  template <typename _T>\012  explicit mm_master(_T *data, std::size_t size = 0, bool use_socket = false)\012      : internal::memory_base(_aspace, _awidth, _dwidth, _latency,\012                              _readwrite_mode, true, _maxburst, _align,\012                              _waitrequest, data, size, sizeof(_DT),\012                              use_socket) {\012    mSize = size;\012    mUse_socket = use_socket;\012    if (size > 0 && size % sizeof(_DT) != 0) {\012      __ihc_hls_runtime_error_x86(\012          \"The buffer size must be a multiple of the type size\");\012    }\012  }\012#else\012  template<typename _T> explicit mm_master(_T *data, std::size_t size=0, bool use_socket=false);\012#endif\012\012  // The copy constructor and assignment operator are needed in the testbench\012  // but illegal in a component\012  mm_master(const mm_master &other);\012\012  mm_master& operator=(const mm_master& other);\012\012  // Clean up any derrived mm_masters when this object is destroyed.\012  ~mm_master();\012\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the mm_master object and are only\012  // supported in the testbench:\012  //   mm_master()\012  //   getInterfaceAtIndex()\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the base pointer and should only be used\012  // in the component:\012  //   operator[]()\012  //   operator*()\012  //   operator->()\012  //   operator _T()\012  //   operator+()\012  //   operator&()\012  //   operator|()\012  //   operator^()\012  //////////////////////////////////////////////////////////////////////////////\012\012  _DT &operator[](int index);\012  _DT &operator*();\012  _DT *operator->();\012  template<typename _T> operator _T();\012  _DT *operator+(int index);\012  template<typename _T> _DT *operator&(_T value);\012  template<typename _T> _DT *operator|(_T value);\012  template<typename _T> _DT *operator^(_T value);\012  // This function is only supported in the testbench:\012  mm_master<_DT, _Params...>& getInterfaceAtIndex(int index);\012\012#ifdef HLS_X86\012private:\012  std::vector<internal::memory_base* > new_masters;\012#else //Fpga\012\012\012#endif\012private:\012  static constexpr int _dwidth   = GetValue<ihc::dwidth, _Params...>::value;\012  static constexpr int _awidth   = GetValue<ihc::awidth, _Params...>::value;\012  static constexpr int _aspace   = GetValue<ihc::aspace, _Params...>::value;\012  static constexpr int _latency  = GetValue<ihc::latency, _Params...>::value;\012  static constexpr int _maxburst = GetValue<ihc::maxburst, _Params...>::value;\012  static constexpr int _align    = (GetValue<ihc::align, _Params...>::value == -1) ? alignof(_DT) : GetValue<ihc::align, _Params...>::value;\012  static constexpr int _readwrite_mode = GetValue<ihc::readwrite_mode, _Params...>::value;\012  static constexpr bool _waitrequest = GetValue<ihc::waitrequest, _Params...>::value;\012\012  _DT __hls_mm_master_aspace(_aspace) *mPtr;\012  int mSize;\012  bool mUse_socket;\012};\012  /////////////////////////////\012 /// streaming interfaces  ///\012//////////////////////////////\012\012  template<int _N> struct buffer {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 0;\012  };\012\012  template<int _N> struct readyLatency {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 0;\012  };\012\012  template<int _N> struct bitsPerSymbol {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 0;\012  };\012\012  template<int _N> struct usesPackets {\012    static constexpr bool value = _N;\012    static constexpr bool defaultValue = false;\012  };\012\012  template<int _N> struct usesValid {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = true;\012  };\012\012  template<int _N> struct usesReady {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = true;\012  };\012\012  template<int _N> struct usesEmpty {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = false;\012  };\012\012  template<int _N> struct firstSymbolInHighOrderBits {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = false;\012  };\012\012template <typename _T, class ... _Params>\012class stream_in final : public internal::stream<_T, _Params...> {\012public:\012  stream_in();\012  stream_in(const stream_in&) = delete;\012  stream_in(const stream_in&&) = delete;\012  stream_in& operator=(const stream_in&) = delete;\012  stream_in& operator=(const stream_in&&) = delete;\012  _T read(bool wait=false);\012  void write(const _T& arg);\012  _T tryRead(bool &success);\012  bool tryWrite(const _T& arg);\012\012  // for packet based stream\012  _T read(bool& sop, bool& eop, bool wait=false);\012  _T read(bool& sop, bool& eop, int& empty, bool wait=false);\012  void write(const _T& arg, bool sop, bool eop);\012  void write(const _T& arg, bool sop, bool eop, int empty);\012  _T tryRead(bool &success, bool& sop, bool& eop);\012  _T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  bool tryWrite(const _T& arg, bool sop, bool eop);\012  bool tryWrite(const _T& arg, bool sop, bool eop, int empty);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setValidCycles(unsigned average_valid, unsigned valid_delta=0);\012\012 private:\012    static constexpr int _buffer   = GetValue<ihc::buffer, _Params...>::value;\012    static constexpr int _readyLatency   = GetValue<ihc::readyLatency, _Params...>::value;\012    static constexpr int _bitsPerSymbol  = GetValue<ihc::bitsPerSymbol, _Params...>::value;\012    static constexpr bool _firstSymbolInHighOrderBits =  GetValue<ihc::firstSymbolInHighOrderBits, _Params...>::value;\012    static constexpr bool _usesPackets  = GetValue<ihc::usesPackets, _Params...>::value;\012    static constexpr bool _usesEmpty = GetValue<ihc::usesEmpty, _Params...>::value;\012    static constexpr bool _usesValid = GetValue<ihc::usesValid, _Params...>::value;\012    static constexpr bool _usesReady = GetValue<ihc::usesReady, _Params...>::value;\012};\012\012template <typename _T, class ... _Params>\012class stream_out final : public internal::stream<_T, _Params...> {\012\012public:\012  stream_out();\012  stream_out(const stream_out&) = delete;\012  stream_out(const stream_out&&) = delete;\012  stream_out& operator=(const stream_out&) = delete;\012  stream_out& operator=(const stream_out&&) = delete;\012  _T read(bool wait=false);\012  void write(const _T& arg);\012  _T tryRead(bool &success);\012  bool tryWrite(const _T& arg);\012\012  // for packet based stream\012  _T read(bool& sop, bool& eop, bool wait=false);\012  _T read(bool& sop, bool& eop, int& empty, bool wait=false);\012  void write(const _T& arg, bool sop, bool eop);\012  void write(const _T& arg, bool sop, bool eop, int empty);\012  _T tryRead(bool &success, bool& sop, bool& eop);\012  _T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  bool tryWrite(const _T& arg, bool sop, bool eop);\012  bool tryWrite(const _T& arg, bool sop, bool eop, int empty);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setReadyCycles(unsigned average_ready, unsigned ready_delta=0);\012\012 private:\012    static constexpr int _buffer   = GetValue<ihc::buffer, _Params...>::value;\012    static constexpr int _readyLatency   = GetValue<ihc::readyLatency, _Params...>::value;\012    static constexpr int _bitsPerSymbol  = GetValue<ihc::bitsPerSymbol, _Params...>::value;\012    static constexpr bool _firstSymbolInHighOrderBits = GetValue<ihc::firstSymbolInHighOrderBits, _Params...>::value;\012    static constexpr bool _usesPackets  = GetValue<ihc::usesPackets, _Params...>::value;\012    static constexpr bool _usesEmpty = GetValue<ihc::usesEmpty, _Params...>::value;\012    static constexpr bool _usesValid = GetValue<ihc::usesValid, _Params...>::value;\012    static constexpr bool _usesReady = GetValue<ihc::usesReady, _Params...>::value;\012};\012\012\012// Bi-directional inter-task stream\012template<typename _T, class ... _Params>\012class stream final : public internal::stream<_T, _Params...> {\012public:\012  stream();\012  stream(const stream&) = delete;\012  stream(const stream&&) = delete;\012  stream& operator=(const stream&) = delete;\012  stream& operator=(const stream&&) = delete;\012  _T read(bool wait=true);\012  void write(const _T& arg);\012  _T tryRead(bool &success);\012  bool tryWrite(const _T& arg);\012\012  // for packet based stream\012  _T read(bool& sop, bool& eop, bool wait=true);\012  _T read(bool& sop, bool& eop, int& empty, bool wait=true);\012  void write(const _T& arg, bool sop, bool eop);\012  void write(const _T& arg, bool sop, bool eop, int empty);\012  _T tryRead(bool &success, bool& sop, bool& eop);\012  _T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  bool tryWrite(const _T& arg, bool sop, bool eop);\012  bool tryWrite(const _T& arg, bool sop, bool eop, int empty);\012\012private:\012  static constexpr int _buffer   = GetValue<ihc::buffer, _Params...>::value;\012  static constexpr int _readyLatency   = GetValue<ihc::readyLatency, _Params...>::value;\012  static constexpr int _bitsPerSymbol  = GetValue<ihc::bitsPerSymbol, _Params...>::value;\012  static constexpr bool _firstSymbolInHighOrderBits = GetValue<ihc::firstSymbolInHighOrderBits, _Params...>::value;\012  static constexpr bool _usesPackets  = GetValue<ihc::usesPackets, _Params...>::value;\012  static constexpr bool _usesEmpty = GetValue<ihc::usesEmpty, _Params...>::value;\012  static constexpr bool _usesValid = GetValue<ihc::usesValid, _Params...>::value;\012  static constexpr bool _usesReady = GetValue<ihc::usesReady, _Params...>::value;\012  static_assert(_usesValid, \"Bi-directional stream interfaces must use Valid signal\");\012  static_assert(_usesReady, \"Bi-directional stream interfaces must use Ready signal\");\012\012};\012\012}//namespace ihc\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Cosimulation Support API\012////////////////////////////////////////////////////////////////////////////////\012\012#define ihc_hls_enqueue(retptr, func, ...) \\\012  { \\\012    if (__ihc_hls_async_call_capable()){ \\\012      __ihc_enqueue_handle=(retptr); \\\012      (void) (*(func))(__VA_ARGS__); \\\012      __ihc_enqueue_handle=0; \\\012    } else { \\\012      *(retptr) = (*(func))(__VA_ARGS__); \\\012    } \\\012  }\012\012#define ihc_hls_enqueue_noret(func, ...) \\\012  { \\\012  __ihc_enqueue_handle=& __ihc_enqueue_handle; \\\012  (*(func))(__VA_ARGS__); \\\012  __ihc_enqueue_handle=0; \\\012  }\012\012#define ihc_hls_component_run_all(component_address) \\\012  __ihc_hls_component_run_all((void*) (component_address))\012\012#define ihc_hls_set_component_wait_cycle(component_address, num_wait_cycles) \\\012  __ihc_hls_set_component_wait_cycle((void*) (component_address), num_wait_cycles)\012\012// When running a simulation, this function will issue a reset to all components\012// in the testbench\012// Returns: 0 if reset did not occur (ie. if the component target is x86)\012//          1 if reset occured (ie. if the component target is an FPGA)\012extern \"C\" int ihc_hls_sim_reset(void);\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Component Built-Ins\012////////////////////////////////////////////////////////////////////////////////\012\012//Builtin memory fence function call\012#ifdef HLS_X86\012inline void ihc_fence() {}\012\012#else\012extern \"C\" void __acl_mem_fence(unsigned int);\012inline void ihc_fence() {\012  // fence on all types of fences from OpenCL\012  __acl_mem_fence(-1);\012}\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Implementions, no declarations below\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012#ifdef HLS_X86\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012\012  // The copy constructor and assignment operator are needed in the testbench\012  // necessary to ensurebut illegal in a component\012template <typename _DT, class... _Params>\012mm_master<_DT, _Params...>::mm_master(const mm_master &other)\012    : internal::memory_base(_aspace, _awidth, _dwidth, _latency,\012                            static_cast<readwrite_t>(_readwrite_mode), true,\012                            _maxburst, _align, _waitrequest, other.get_base(),\012                            other.get_size(), sizeof(_DT),\012                            other.uses_socket()) {\012  mPtr = other.mPtr;\012  mSize = other.mSize;\012  mUse_socket = other.mUse_socket;\012  mem = other.mem;\012}\012\012template <typename _DT, class ... _Params>\012  mm_master<_DT, _Params...>& mm_master<_DT, _Params...>::operator=(const mm_master& other) {\012    mPtr = other.mPtr;\012    mSize = other.mSize;\012    mUse_socket = other.m_Use_socket;\012    mem = other.mem;\012  }\012\012  // Clean up any derrived mm_masters when this object is destroyed.\012template <typename _DT, class ... _Params>\012  mm_master<_DT, _Params...>::~mm_master() {\012    for(std::vector<internal::memory_base* >::iterator it = new_masters.begin(),\012        ie = new_masters.end(); it != ie; it++) {\012      delete *it;\012    }\012    new_masters.clear();\012  }\012\012template <typename _DT, class ... _Params>\012_DT &mm_master<_DT, _Params... >::operator[](int index) {\012  assert(size==0 || index*data_size<size);\012  return ((_DT*)mem)[index];\012}\012\012template <typename _DT, class ... _Params>\012_DT &mm_master<_DT, _Params...>::operator*() {\012  return ((_DT*)mem)[0];\012}\012\012template <typename _DT, class ... _Params>\012_DT *mm_master<_DT, _Params...>::operator->() {\012  return (_DT*)mem;\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> mm_master<_DT, _Params...>::operator _T() {\012  return (_T)((unsigned long long)mem);\012}\012\012template <typename _DT, class ... _Params>\012_DT *mm_master<_DT, _Params...>::operator+(int index) {\012  assert(size==0 || index*data_size<size);\012  return &((_DT*)mem)[index];\012}\012\012// Bitwise operators\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator&(_T value) {\012  return (_DT*)((unsigned long long)mem & (unsigned long long)value);\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator|(_T value) {\012  return (_DT*)((unsigned long long)mem | (unsigned long long)value);\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator^(_T value) {\012  return (_DT*)((unsigned long long)mem ^ (unsigned long long)value);\012}\012\012// Function for creating new mm_master at an offset\012template <typename _DT, class ... _Params>\012mm_master<_DT, _Params...>& mm_master<_DT,_Params...>::getInterfaceAtIndex(int index) {\012  assert(mSize==0 || index*data_size<mSize);\012  // This new object is cleaned up when this' destructor is called.\012  mm_master<_DT, _Params...> *temp = new mm_master(&(((_DT*)mem)[index]), mSize - index * sizeof(_DT), mUse_socket);\012  new_masters.push_back(temp);\012  return *temp;\012}\012\012  ///////////////////\012 /// stream_in   ///\012///////////////////\012\012template<typename _T, class ... _Params>\012stream_in<_T,_Params...>::stream_in() {}\012\012template<typename _T, class ... _Params>\012  _T stream_in<_T, _Params...>::tryRead(bool &success) {\012  return internal::stream<_T,_Params...>::tryRead(success);\012}\012\012template<typename _T, class ... _Params>\012  _T stream_in<_T,_Params...>::read(bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg) {\012    internal::stream<_T,_Params...>::write(arg);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::read(bool& sop, bool& eop, bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, empty, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop, empty);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    internal::stream<_T,_Params...>::write(arg, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012    internal::stream<_T,_Params...>::write(arg, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<_T,_Params...>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::setValidCycles(unsigned average_valid, unsigned valid_delta) {\012  if (average_valid == 0) {\012    __ihc_hls_runtime_error_x86(\"The valid average in setValidCycles must be at least 1\");\012  }\012  if (valid_delta > average_valid) {\012    __ihc_hls_runtime_error_x86(\"The valid delta in setValidCycles cannot be larger than the average valid value\");\012  }\012  internal::stream<_T,_Params...>::setReadyorValidCycles(average_valid, valid_delta);\012}\012\012  ///////////////////\012 /// stream_out  ///\012///////////////////\012\012template<typename _T, class ... _Params>\012  stream_out<_T,_Params...>::stream_out() {\012}\012\012template<typename _T, class ... _Params>\012  _T stream_out<_T,_Params...>::tryRead(bool &success) {\012  return internal::stream<_T,_Params...>::tryRead(success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg) {\012    internal::stream<_T,_Params...>::write(arg);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool& sop, bool& eop, bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, empty, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    internal::stream<_T,_Params...>::write(arg, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012  internal::stream<_T,_Params...>::write(arg, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop, empty);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<_T,_Params...>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::setReadyCycles(unsigned average_ready, unsigned ready_delta) {\012  if (average_ready == 0) {\012    __ihc_hls_runtime_error_x86(\"The ready average in setReadCycles must be at least 1\");\012  }\012  if (ready_delta > average_ready) {\012    __ihc_hls_runtime_error_x86(\"The ready delta in setReadyCycles cannot be larger than the average ready value\");\012  }\012  internal::stream<_T,_Params...>::setReadyorValidCycles(average_ready, ready_delta);\012}\012\012  ///////////////////\012  ///// stream  /////\012  ///////////////////\012\012template<typename _T, class ... _Params>\012  stream<_T,_Params...>::stream() {\012}\012\012template<typename _T, class ... _Params>\012  _T stream<_T,_Params...>::tryRead(bool &success) {\012  return internal::stream<_T,_Params...>::tryRead(success);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool wait /*=true*/) {\012    _T elem = internal::stream<_T,_Params...>::read(wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg) {\012    internal::stream<_T,_Params...>::write(arg);\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool& sop, bool& eop, bool wait /*=true*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait /*=true*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, empty, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    internal::stream<_T,_Params...>::write(arg, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012  internal::stream<_T,_Params...>::write(arg, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop, empty);\012  }\012  return success;\012}\012\012\012#else //fpga path. Ignore the class just return a consistant pointer/reference\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012template <typename _DT, class ... _Params>\012_DT &mm_master<_DT, _Params...>::operator[](int index) {\012  return *(_DT*)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, index);\012}\012\012template <typename _DT, class ... _Params>\012_DT &mm_master<_DT,_Params...>::operator*(){\012  return *(_DT*)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0);\012}\012\012template <typename _DT, class ... _Params>\012_DT *mm_master<_DT,_Params...>::operator->(){\012  return (_DT*)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0);\012}\012\012template <typename _DT, class ... _Params>\012_DT *mm_master<_DT, _Params...>::operator+(int index) {\012  return (_DT*)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0) + index;\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> mm_master<_DT, _Params...>::operator _T() {\012  return (_T)((unsigned long long)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0));\012}\012\012// Bitwise operators\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator&(_T value) {\012  return (_DT*)(((unsigned long long)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0)) & (unsigned long long)value);\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator|(_T value) {\012  return (_DT*)(((unsigned long long)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0)) | (unsigned long long)value);\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator^(_T value) {\012  return (_DT*)(((unsigned long long)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0)) ^ (unsigned long long)value);\012}\012\012  ///////////////////\012 /// stream_in   ///\012///////////////////\012\012template<typename _T, class ... _Params>\012  _T stream_in<_T, _Params...>::tryRead(bool &success) {\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\");\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &emp, &success);\012}\012template<typename _T, class ... _Params>\012  _T stream_in<_T,_Params...>::read(bool wait) {\012  (void)wait;\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\");\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return  *__builtin_intel_hls_instream_read((_T*)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &emp);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg) {\012 __builtin_intel_hls_instream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, false, false, 0 );\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg) {\012  return  __builtin_intel_hls_instream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer,  _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &emp, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based reads require a stream with the parameterization: usesEmpty<true>\");\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &empty, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::read(bool& sop, bool& eop, bool wait) {\012  (void)wait;\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  int emp = 0;\012  return  *__builtin_intel_hls_instream_read((_T*)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &emp);\012}\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait) {\012  (void) wait;\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based reads require a stream with the parameterization: usesEmpty<true>\");\012  return  *__builtin_intel_hls_instream_read((_T*)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  return  __builtin_intel_hls_instream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid,  sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  return  __builtin_intel_hls_instream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012 __builtin_intel_hls_instream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid,  sop, eop, 0 );\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012 __builtin_intel_hls_instream_write(&arg, (__int64)this,  _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid,  sop, eop, empty );\012}\012\012  ///////////////////\012 /// stream_out  ///\012///////////////////\012\012template<typename _T, class ... _Params>\012  _T stream_out<_T,_Params...>::tryRead(bool &success) {\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_outstream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp, &success);\012}\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool wait) {\012  (void)wait;\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_outstream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp );\012}\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg) {\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\");\012 __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg) {\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\");\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  int emp = 0;\012  return *__builtin_intel_hls_outstream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  return *__builtin_intel_hls_outstream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  &sop, &eop, &empty, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool& sop, bool& eop, bool wait) {\012  (void)wait;\012  int emp;\012  return *__builtin_intel_hls_outstream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait) {\012  (void)wait;\012  return *__builtin_intel_hls_outstream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &empty );\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based writes require a stream with the parameterization: usesEmpty<true>\");\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based writes require a stream with the parameterization: usesEmpty<true>\");\012\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  sop, eop, empty);\012}\012\012  ///////////////////\012  ///// stream  /////\012  ///////////////////\012\012template<typename _T, class ... _Params>\012  _T stream<_T,_Params...>::tryRead(bool &success) {\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp, &success);\012}\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool wait) {\012  (void)wait;\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_instream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp );\012}\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg) {\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\");\012 __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg) {\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\");\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  &sop, &eop, &empty, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool& sop, bool& eop, bool wait) {\012  (void)wait;\012  int emp;\012  return *__builtin_intel_hls_instream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait) {\012  (void)wait;\012  return *__builtin_intel_hls_instream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &empty );\012}\012\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based writes require a stream with the parameterization: usesEmpty<true>\");\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based writes require a stream with the parameterization: usesEmpty<true>\");\012\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  sop, eop, empty);\012}\012\012#endif\012} // namespace ihc\012\012#ifdef _MSC_VER\012#pragma warning(pop)\012#endif\012\012#endif\012"}, {"path":"/opt/intelFPGA_pro/19.4/hls/include/HLS/hls_internal.h", "name":"hls_internal.h", "has_active_debug_locs":false, "absName":"/opt/intelFPGA_pro/19.4/hls/include/HLS/hls_internal.h", "content":"#ifndef __HLS_INTERNAL_H__\012#define __HLS_INTERNAL_H__\012\012#ifdef HLS_X86\012#include <queue>\012#include <string.h> //memcpy\012#include <assert.h>\012#include <stdio.h>\012#include <stdlib.h>\012#include <mutex>\012#include <condition_variable>\012#endif\012\012#ifdef __INTELFPGA_COMPILER__\012#define __hls_mm_master_aspace(__x) __attribute__((address_space(__x + 1024)))\012#else\012#define __hls_mm_master_aspace(__x)\012#endif\012\012#ifdef _MSC_VER\012#pragma warning(push)\012#pragma warning(disable:4265) // has virtual functions, but destructor is not virtual\012#pragma warning(disable:4505) // unreferenced local function has been removed\012#endif\012\012#if defined(_MSC_VER)\012  #define WINDOWSWEAK __declspec(selectany)\012  #define LINUXWEAK\012#else\012  #define WINDOWSWEAK\012  #define LINUXWEAK __attribute__((weak))\012#endif\012\012WINDOWSWEAK void *__ihc_enqueue_handle LINUXWEAK;\012\012extern \"C\" unsigned long long ihc_hls_get_sim_time(void);\012extern \"C\" int __ihc_hls_get_clock_period_ps(void);\012extern \"C\" int __ihc_hls_component_start_sim_task(const char *component_name);\012extern \"C\" int __ihc_hls_component_wait_sim_task(const char *component_name, unsigned int wait_cycles);\012extern \"C\" void __ihc_hls_stream_sink_wait_sim_task(void* obj_ptr);\012extern \"C\" void __ihc_hls_component_run_all(const void* component_address);\012extern \"C\" void __ihc_hls_set_component_wait_cycle(const void * component_address, unsigned int num_wait_cycles);\012\012// Cosim internal support calls\012extern \"C\" int __ihc_hls_async_call_capable(void);\012// Print error message and bail\012extern \"C\" void __ihc_hls_runtime_error(const char *msg);\012\012#ifdef HLS_X86\012inline void __ihc_hls_runtime_error_x86(const char *msg){\012  printf(\"Error: %s\\n\",msg);\012  exit(1);\012}\012#endif\012\012enum readwrite_t {readwrite = 0, readonly = 1, writeonly = 2};\012\012// ignore __fpga_reg in emulation flow\012#ifdef HLS_X86\012  #define __fpga_reg(x) (x)\012#elif defined(__clang__)\012#if __has_builtin(__builtin_fpga_reg)\012  #ifndef __fpga_reg\012    #define __fpga_reg __builtin_fpga_reg\012  #endif\012#endif\012#endif\012\012namespace ihc {\012\012namespace internal {\012\012// Interface parameter base types used to define interfaces\012class param {};\012class notinit:public param {};\012\012class memory_base {\012private:\012#ifdef HLS_X86\012  // Attributes\012  int aspace; \012  int awidth;\012  int dwidth;\012  int latency;\012  readwrite_t readwrite_mode;\012  bool byteenabled;\012  int maxburst;\012  int align;\012  bool waitrequest;\012  size_t sim_base;\012\012protected:\012  // Extra cosim book keeping\012  size_t data_size; //size of the underlying type used by the interface\012  void *mem;\012  size_t size;\012  bool use_socket; // if true, all reads and writes will go through the IPC socket instead of shared memory\012\012  //description of test data buffer accessed through this interface\012  void set_mem(void *x) {mem=x;};\012  void set_size(size_t x) {size=x;};\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  \012#endif\012public:\012#ifdef HLS_X86\012  memory_base() {}\012  memory_base(int aspace, int awidth, int dwidth, int latency,\012              int readwrite_mode, bool byteenabled, int maxburst, int align,\012              bool waitrequest, void *mem, size_t size, size_t data_size,\012              bool use_socket)\012      : aspace(aspace), awidth(awidth), dwidth(dwidth), latency(latency),\012        readwrite_mode(static_cast<readwrite_t>(readwrite_mode)),\012        byteenabled(byteenabled), maxburst(maxburst), align(align),\012        waitrequest(waitrequest), data_size(data_size), mem(mem), size(size),\012        use_socket(use_socket) {}\012  memory_base(int aspace, int awidth, int dwidth, int latency,\012              readwrite_t readwrite_mode, bool byteenabled, int maxburst,\012              int align, bool waitrequest);\012  // set_parameters, set_base, and get_sim_base are defined in the hls_cosim library\012  void set_parameters(int aspace, int awidth, int dwidth, int latency,\012                      readwrite_t readwrite_mode, bool byteenabled,\012                      int maxburst, int align, bool waitrequest);\012  void set_base(void *ptr, size_t datasize, size_t size, bool use_socket);\012  int get_interface_aspace() const {return aspace;}\012  void * get_base() const {return mem;}\012  size_t get_size() const {return size;}\012  int get_awidth() const {return awidth;}\012  int get_dwidth() const {return dwidth;}\012  int get_latency() const {return latency;}\012  readwrite_t get_readwrite_mode() const {return readwrite_mode;}\012  bool get_byteenabled() const {return byteenabled;}\012  int get_maxburst() const {return maxburst;}\012  int get_align() const {return align;}\012  bool get_waitrequest() const {return waitrequest;}\012  \012  size_t get_data_size() const {return data_size;}\012\012  void set_sim_base(size_t addr) {sim_base = addr;}\012  size_t get_sim_base();\012  \012  void set_use_socket(bool socket) {use_socket = socket;}\012  bool uses_socket() const {return use_socket;}\012#endif\012};\012\012#ifdef HLS_X86\012class stream_abstract_base {\012  bool stable; // does the data on this interface change between function calls?\012  bool implicit; // is this interface synchronous with the component's function call interface?\012  bool global; // is this an implicit interface that carries a global variable's address?\012  size_t data_size; //size of the underlying type used by the interface\012protected:\012  unsigned m_average_stall;\012  unsigned m_stall_delta;\012  unsigned m_average_RoV;\012  unsigned m_RoV_delta;\012  unsigned m_remaining_period;\012  unsigned m_period_threshold;\012public:\012stream_abstract_base():stable(false), implicit(false), global(false), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1) { assert(1==0);}\012stream_abstract_base(size_t data_size):stable(false), implicit(false), global(false), data_size(data_size), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1){}\012  bool is_stable() {return stable;}\012  void set_stable() {stable = true;}\012  bool is_implicit() {return implicit;}\012  bool is_global() {return global;}\012  void set_implicit() {implicit = true;}\012  void set_global() {global = true;}\012  size_t get_data_size() {return data_size;}\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  unsigned get_average_stall() {return m_average_stall;}\012  unsigned get_stall_delta() {return m_stall_delta;}\012  unsigned get_average_RoV() {return m_average_RoV;}\012  unsigned get_RoV_delta() {return m_RoV_delta;}\012  virtual bool _internal_cosim_empty() = 0;\012  virtual void read_by_ptr(void *data) = 0;\012  virtual void read_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void read_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) = 0;\012  virtual void write_by_ptr(void *data) = 0;\012  virtual void write_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void write_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) = 0;\012  virtual void front_by_ptr(void *data) = 0;\012  virtual void front_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void front_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) = 0;\012  virtual size_t get_size() = 0;\012};\012#endif\012\012template<typename T, class ... Params>\012class stream \012#ifdef HLS_X86\012  :  public stream_abstract_base \012#endif\012{\012\012#ifdef HLS_X86\012  std::queue<T> q_;\012  std::queue<std::pair<bool,bool> > qp_;\012  std::queue<int> qpe_;\012  std::mutex m_;\012  std::condition_variable cv_;\012#endif\012public:  \012  stream();\012  // do not allow copy and assignment of streams\012  stream(const stream&) = delete;\012  stream& operator=(const stream&) = delete; \012\012  bool _internal_cosim_empty(); \012#ifdef HLS_X86\012  virtual T read(bool wait=false);               \012  virtual void write(const T& arg);      \012  virtual T tryRead(bool &success);   \012  virtual bool tryWrite(const T& arg);       \012\012  // for packet based stream \012  virtual T read(bool& sop, bool& eop, bool wait=false);\012  virtual T read(bool& sop, bool& eop, int& empty, bool wait=false);\012  virtual void write(const T& arg, bool sop, bool eop);\012  virtual void write(const T& arg, bool sop, bool eop, int empty);\012  virtual T tryRead(bool &success, bool& sop, bool& eop);\012  virtual T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  virtual bool tryWrite(const T& arg, bool sop, bool eop);     \012  virtual bool tryWrite(const T& arg, bool sop, bool eop, int empty);     \012  virtual void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  virtual void setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta=0);\012#else\012  T read();               \012  void write(const T& arg);      \012  T tryRead(bool &success); \012  bool tryWrite(const T& arg);       \012\012  // for packet based stream \012  T read(bool& sop, bool& eop);\012  T read(bool& sop, bool& eop, int& empty);\012  void write(const T& arg, bool sop, bool eop);\012  void write(const T& arg, bool sop, bool eop, int empty);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  bool tryWrite(const T& arg, bool sop, bool eop);     \012  bool tryWrite(const T& arg, bool sop, bool eop, int empty);     \012#endif\012   T _internal_cosim_front();\012   T _internal_cosim_front(bool& sop, bool& eop);\012   T _internal_cosim_front(bool& sop, bool& eop, int& empty);\012  \012#ifdef HLS_X86\012  void read_by_ptr(void *data);\012  void read_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  void read_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty);\012  void write_by_ptr(void *data);\012  void write_by_ptr_pkt(void *data, bool* sop, bool*eop);\012  void write_by_ptr_pkt_e(void *data, bool* sop, bool*eop, void* empty);\012  void front_by_ptr(void *data);\012  void front_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  void front_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty);\012  size_t get_size() {return q_.size();}\012\012  // control stall/valid behaviour\012  bool stall();\012  void setStallPeriod();\012  //Middle Square Weyl Sequence RNG\012   unsigned msws();\012#endif\012};\012\012template <typename T, class ... Params>\012  stream<T,Params...>::stream()\012#ifdef HLS_X86\012 :stream_abstract_base(sizeof(T))\012#endif\012{\012}\012\012  ////////////////\012 /// stream   ///\012////////////////\012\012#ifdef HLS_X86\012template<typename T, class ... Params>\012bool stream<T,Params...>::_internal_cosim_empty() {\012  bool empty=q_.empty();  \012  return empty;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::tryRead(bool &success) {\012  std::unique_lock<std::mutex> _{ m_ };\012  success = !_internal_cosim_empty();\012  if (success) {\012    T arg = q_.front();\012    q_.pop();\012 \012    // unused sideband signals\012    qp_.pop();\012    qpe_.pop();\012    return arg;\012  } else {\012    return T();\012  }\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  std::unique_lock<std::mutex> _{ m_ };\012  success = !_internal_cosim_empty();\012  if (success) {\012    T arg = q_.front();\012    q_.pop();\012    std::pair<bool,bool> p = qp_.front();\012    sop = p.first;\012    eop = p.second;\012\012    qp_.pop();\012    qpe_.pop();\012    return arg;\012  } else {\012    return T();\012  }\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  std::unique_lock<std::mutex> _{ m_ };\012  success = !_internal_cosim_empty();\012  if (success) {\012    T arg = q_.front();\012    q_.pop();\012    std::pair<bool,bool> p = qp_.front();\012    empty = qpe_.front();\012    sop = p.first;\012    eop = p.second;\012\012    qp_.pop();\012    qpe_.pop();\012    return arg;\012  } else {\012    return T();\012  }\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::read(bool wait) {\012  std::unique_lock<std::mutex> lock{ m_ };\012  bool empty = _internal_cosim_empty();\012#ifdef HLS_X86\012  // in the case of emulation, we either error out or wait until wait is available\012  if(empty && !wait) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012  // wait until the queue is no longer empty\012  cv_.wait(lock, [this]{return  !this->_internal_cosim_empty();});\012  T arg = q_.front();\012  q_.pop();\012\012  // unused sideband signals\012  qp_.pop();\012  qpe_.pop();\012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::read(bool& sop, bool& eop, bool wait) {\012  T arg;\012\012  std::unique_lock<std::mutex> lock{ m_ };\012  bool empty = _internal_cosim_empty();\012#ifdef HLS_X86\012  // in the case of emulation, we either error out or wait until wait is available\012  if(empty && !wait) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012  // wait until the queue is no longer empty\012  cv_.wait(lock, [this]{return  !this->_internal_cosim_empty();});\012  arg = q_.front();\012  q_.pop();\012  std::pair<bool,bool> p = qp_.front();\012  sop = p.first;\012  eop = p.second;\012\012  qp_.pop();\012  // unused sideband signal\012  qpe_.pop();\012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::read(bool& sop, bool& eop, int& empty, bool wait) {\012  std::unique_lock<std::mutex> lock{ m_ };\012  bool empty_ = _internal_cosim_empty();\012#ifdef HLS_X86\012  // in the case of emulation, we either error out or wait until wait is available\012  if(empty_ && !wait) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012  // wait until the queue is no longer empty\012  cv_.wait(lock, [this]{return  !this->_internal_cosim_empty();});\012  T arg = q_.front();\012  q_.pop();\012\012  std::pair<bool,bool> p = qp_.front();\012  empty = qpe_.front();\012  sop = p.first;\012  eop = p.second;\012\012  qp_.pop();\012  qpe_.pop();\012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::_internal_cosim_front() {\012  T arg;      \012    \012  std::unique_lock<std::mutex> _{ m_ };\012  bool empty = _internal_cosim_empty();\012#ifdef HLS_X86\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012\012  arg = q_.front();\012  \012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::_internal_cosim_front(bool& sop, bool& eop) {\012  T arg;      \012    \012  std::unique_lock<std::mutex> _{ m_ };\012  bool empty = _internal_cosim_empty();\012#ifdef HLS_X86\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012\012  arg = q_.front();\012  std::pair<bool,bool> p = qp_.front();\012\012  sop = p.first;\012  eop = p.second;\012  \012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::_internal_cosim_front(bool& sop, bool& eop, int& empty) {\012  T arg;      \012\012  std::unique_lock<std::mutex> _{ m_ };\012  bool empty_ = _internal_cosim_empty();\012#ifdef HLS_X86\012  if(empty_) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012\012  arg = q_.front();\012  std::pair<bool,bool> p = qp_.front();\012  empty = qpe_.front();\012  sop = p.first;\012  eop = p.second;\012\012  return arg;\012}\012\012template<typename T, class ... Params>\012bool stream<T,Params...>::tryWrite(const T& arg) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg);\012   }\012   return success;\012}\012\012template<typename T, class ... Params>\012bool stream<T,Params...>::tryWrite(const T& arg, bool sop, bool eop) {\012    bool success = true; /* stl::queue has no full */\012    if (success) {\012        write(arg, sop, eop);\012    }\012    return success;\012}\012\012template<typename T, class ... Params>\012bool stream<T,Params...>::tryWrite(const T& arg, bool sop, bool eop, int empty) {\012    bool success = true; /* stl::queue has no full */\012    if (success) {\012        write(arg, sop, eop, empty);\012    }\012    return success;\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write(const T& arg) {\012    {\012        std::unique_lock<std::mutex> _{ m_ };\012        q_.push(arg);\012\012        // sideband signals\012        qp_.push(std::pair<bool,bool>(false,false));\012        qpe_.push(0);\012    }\012    cv_.notify_one();\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write(const T& arg, bool sop, bool eop) {\012    {\012        std::unique_lock<std::mutex> _{ m_ };\012        q_.push(arg);\012\012        // sideband signals\012        qp_.push(std::pair<bool,bool>(sop, eop));\012        qpe_.push(0);\012    }\012    cv_.notify_one();\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write(const T& arg, bool sop, bool eop, int empty) {\012    {\012        std::unique_lock<std::mutex> _{ m_ };\012        q_.push(arg);\012\012        // sideband signals\012        qp_.push(std::pair<bool,bool>(sop, eop));\012        qpe_.push(empty);\012    }\012    cv_.notify_one();\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::read_by_ptr(void *data) {\012    T elem = read();\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::read_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = read(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::read_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) {\012    int temp_empty;\012    T elem = read(*sop, *eop, temp_empty);\012    memcpy(data, &elem, sizeof(T));\012    memcpy(empty, &temp_empty, sizeof(int));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::front_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) {\012    int temp_empty;\012    T elem = _internal_cosim_front(*sop, *eop, temp_empty);\012    memcpy(data, &elem, sizeof(T));\012    memcpy(empty, &temp_empty, sizeof(int));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::front_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = _internal_cosim_front(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));    \012}\012\012\012template<typename T, class ... Params>\012void stream<T,Params...>::front_by_ptr(void *data) {\012    T elem = _internal_cosim_front();\012    memcpy(data, &elem, sizeof(T));    \012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem, *sop, *eop);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) {\012    T elem;\012    int temp_empty;\012    memcpy(&elem, data, sizeof(T));\012    memcpy(&temp_empty, empty, sizeof(int));\012    write(elem, *sop, *eop, temp_empty);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write_by_ptr(void *data) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::setStallPeriod() {\012    if (m_stall_delta == 0) {\012        m_remaining_period = m_average_stall;\012    } else {\012        m_remaining_period = (m_average_stall - m_stall_delta) + msws()%(m_stall_delta*2+1);\012    }\012    if (m_RoV_delta == 0) {\012        m_period_threshold = m_average_RoV;\012    } else {\012        m_period_threshold = (m_average_RoV - m_RoV_delta) + msws()%(m_RoV_delta*2+1);\012    }\012    m_remaining_period +=  m_period_threshold;\012}\012\012template<typename T, class ... Params>\012  void stream<T, Params...>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012    m_average_stall = average_stall;\012    m_stall_delta = stall_delta;\012    setStallPeriod();\012}\012\012template<typename T, class ... Params>\012  void stream<T, Params...>::setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta) {\012    m_average_RoV = average_RoV;\012    m_RoV_delta = RoV_delta;\012    setStallPeriod();\012}\012\012template<typename T, class ... Params>\012bool stream<T, Params...>::stall() {\012  if (m_remaining_period == 0) {\012    setStallPeriod();\012  }\012  m_remaining_period--;\012  if (m_remaining_period < m_period_threshold) { \012    return false;\012  } else {\012    return true;\012  }\012}\012\012template<typename T, class ... Params>\012unsigned stream<T, Params...>::msws() {\012  static unsigned long long x = 0, w = 0;\012  const unsigned long long s = 0xb5ad4eceda1ce2a9ULL;\012  \012  x *= x; \012  x += (w += s); \012  return (unsigned) (x = (x>>32) | (x<<32));\012}\012\012#endif\012} //namespace internal\012} //namespace ihc\012\012#ifdef _MSC_VER\012#pragma warning(pop)\012#endif\012\012#endif\012\012"}, {"path":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/img_filter_base_intel.h", "name":"img_filter_base_intel.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/img_filter_base_intel.h", "content":"#ifndef SRC_IMG_FILTER_BASE_INTEL_H_\012#define SRC_IMG_FILTER_BASE_INTEL_H_\012#include \"img_filter_core.h\"\012#include \"link_OpenCLIntel.h\"\012#include \"HLS/task.h\" //system of task\012\012//Intel wrapper to call the function as a task, Intel require: The streammings only can pass to a funtion through argument template\012//are an invalid implementation\012template <typename SrcType, typename DstType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0,int stream_type1, int stream_type2,typename vx_type0, typename vx_type1, typename vx_type2, vx_type0 &input0, vx_type1 &output1, vx_type2 &output2>\012void ImgSobelIntel(){\012	HwSobel<SrcType, DstType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0,stream_type1, stream_type2>(input0, output1, output2);\012}\012//ToDo: All the funtion under the same struct to build a vx_node, wth image parameters as commom\012template <typename SrcType, typename DstType, vx_uint8 VEC_NUM, \012			vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, \012			typename vx_type0, typename vx_type1, typename vx_type2, \012			vx_type0 &input0, vx_type1 &output1, vx_type2 &output2, \012			int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012struct ImgSobel{\012     ImgSobel(){\012#ifdef Xilinx\012     ImgSobel<SrcType, DstType, VEC_NUM, COLS_FHD, ROWS_FHD, FILTER_SIZE, BORDER_TYPE>(input0, output1, output2);\012#elif Intel\012     ihc::launch((ImgSobelIntel<SrcType, DstType,VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE,stream_type0,stream_type1,stream_type2,decltype(input0),decltype(output1),decltype(output2),input0,output1,output2>));\012#endif\012	 }\012     void vxReleaseNode(){\012#ifdef Xilinx\012#elif Intel\012     ihc::collect((ImgSobelIntel<SrcType, DstType,VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE,stream_type0,stream_type1,stream_type2,decltype(input0),decltype(output1),decltype(output2),input0,output1,output2>));\012#endif\012	 }\012};\012/** @brief  Computes a Box filter over a window of the input image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param SEPARABLE   Is true, if separable filter should be used\012@param stream_type0 type of streamming for of Input for intel FPGAs\012@param stream_type1 type of streamming for of Output for intel FPGAs\012@param input       Input image\012@param output      Output image\012*/\012template <typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, bool SEPARABLE, int stream_type0, int stream_type1, typename vx_type0, typename vx_type1, vx_type0 &input0, vx_type1 &output1>\012void ImgBoxIntel(){\012	HwBox<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, SEPARABLE, stream_type0, stream_type1>(input0, output1);\012}\012\012template <typename SrcType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, bool SEPARABLE, typename vx_type0, typename vx_type1, vx_type0 &input0, vx_type1 &output1, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e>\012struct ImgBox{\012     ImgBox(){\012#ifdef Xilinx\012     ImgBox<SrcType, VEC_NUM, COLS_FHD, ROWS_FHD, FILTER_SIZE, BORDER_TYPE, SEPARABLE_FILTER>(input0, output1);\012#elif Intel\012     ihc::launch((ImgBoxIntel<SrcType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, SEPARABLE_FILTER, stream_type0, stream_type1,decltype(input0),decltype(output1),input0,output1>));\012#endif\012	 }\012     void vxReleaseNode(){\012#ifdef Xilinx\012#elif Intel\012     ihc::collect((ImgBoxIntel<SrcType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, SEPARABLE_FILTER,stream_type0, stream_type1,decltype(input0),decltype(output1),input0,output1>));\012#endif\012	 }\012};\012\012/** @brief  Convolves the input with the client supplied convolution matrix. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned, signed)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param stream_type0 type of streamming for of Input for intel FPGAs\012@param stream_type1 type of streamming for of Output for intel FPGAs\012@param input       Input image\012@param output      Output image\012@param conv        The custom convolution kernel\012*/\012template <typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0, typename vx_type0, typename vx_type1, vx_type0 &input0, vx_type1 &output1>\012void ImgConvolveIntel(const vx_uint8 convolve_kernel[3][3]) {\012	HwConvolve<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input0, output1, convolve_kernel);\012}\012\012template <typename SrcType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, typename vx_type0, typename vx_type1, vx_type0 &input0, vx_type1 &output1, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e>\012struct ImgConvolve{\012     ImgConvolve(){\012			 // Convolution kernel for the HwConvolve filter\012			 // example of convolutional kernel\012			  const vx_uint8 convolve_kernel[3][3] = {\012			  	{ 191, 185, 157 },\012			  	{ 237, 171, 245 },\012			  	{ 219, 235, 173 }	};\012\012#ifdef Xilinx\012     ImgConvolve<SrcType, VEC_NUM, COLS_FHD, ROWS_FHD, FILTER_SIZE, BORDER_TYPE>(input0, output1, convolve_kernel);\012#elif Intel\012     ihc::launch((ImgConvolveIntel<SrcType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1, decltype(input0), decltype(output1), input0, output1>),convolve_kernel);\012#endif\012	 }\012     void vxReleaseNode(){\012#ifdef Xilinx\012#elif Intel\012     ihc::collect((ImgConvolveIntel<SrcType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1, decltype(input0), decltype(output1), input0, output1>));\012#endif\012	 }\012};\012\012/** @brief  Implements Dilation, which grows the white space in a Boolean image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param stream_type0 type of streamming for of Input for intel FPGAs\012@param stream_type1 type of streamming for of Output for intel FPGAs\012@param input       Input image\012@param output      Output image\012*/\012template <typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0, int stream_type1, typename vx_type0, vx_type0 &input0, vx_type0 &output1>\012void ImgDilateIntel() {\012	HwDilate<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1>(input0, output1);\012}\012template <typename SrcType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, typename vx_type0, typename vx_type1, vx_type0 &input0, vx_type1 &output1, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e>\012struct ImgDilate{\012     ImgDilate(){\012#ifdef Xilinx\012     ImgDilate<SrcType, VEC_NUM, COLS_FHD, ROWS_FHD, FILTER_SIZE, BORDER_TYPE>(input0, output1);\012#elif Intel\012     ihc::launch((ImgDilateIntel<SrcType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1, decltype(input0), decltype(output1), input0, output1>));\012#endif\012	 }\012     void vxReleaseNode(){\012#ifdef Xilinx\012#elif Intel\012     ihc::collect((ImgDilateIntel<SrcType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1, decltype(input0), decltype(output1), input0, output1>));\012#endif\012	 }\012};\012\012/** @brief  Implements Erosion, which shrinks the white space in a Boolean image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param stream_type0 type of streamming for of Input for intel FPGAs\012@param stream_type1 type of streamming for of Output for intel FPGAs\012@param input       Input image\012@param output      Output image\012*/\012template <typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0, typename vx_type0, vx_type0 &input0, vx_type0 &output1>\012void ImgErodeIntel() {\012	HwErode<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input0, output1);\012}\012template <typename SrcType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, typename vx_type0, typename vx_type1, vx_type0 &input0, vx_type1 &output1, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e>\012struct ImgErode{\012     ImgErode(){\012#ifdef Xilinx\012     ImgErode<SrcType, VEC_NUM, COLS_FHD, ROWS_FHD, FILTER_SIZE, BORDER_TYPE>(input0, output1);\012#elif Intel\012     ihc::launch((ImgErodeIntel<SrcType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1, decltype(input0), decltype(output1), input0, output1>));\012#endif\012	 }\012     void vxReleaseNode(){\012#ifdef Xilinx\012#elif Intel\012     ihc::collect((ImgErodeIntel<SrcType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1, decltype(input0), decltype(output1), input0, output1>));\012#endif\012	 }\012};\012\012/** @brief  Computes a Gaussian filter over a window of the input image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param SEPARABLE   Is true, if separable filter should be used\012@param stream_type0 type of streamming for of Input for intel FPGAs\012@param stream_type1 type of streamming for of Output for intel FPGAs\012@param input       Input image\012@param output      Output image\012*/\012template <typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, vx_bool SEPARABLE, int stream_type0, int stream_type1, typename vx_type0, typename vx_type1, vx_type0 &input0, vx_type1 &output1>\012void ImgGaussianIntel(){\012	HwGaussian<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, SEPARABLE, stream_type0, stream_type1>(input0, output1);\012}\012template <typename SrcType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, vx_bool SEPARABLE, typename vx_type0, typename vx_type1, vx_type0 &input0, vx_type1 &output1, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e>\012struct ImgGaussian{\012     ImgGaussian(){\012#ifdef Xilinx\012     ImgGaussian<SrcType, VEC_NUM, COLS_FHD, ROWS_FHD, FILTER_SIZE, BORDER_TYPE, SEPARABLE_FILTER>(input0, output1);\012#elif Intel\012     ihc::launch((ImgGaussianIntel<SrcType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, SEPARABLE_FILTER, stream_type0, stream_type1,decltype(input0),decltype(output1),input0,output1>));\012#endif\012	 }\012     void vxReleaseNode(){\012#ifdef Xilinx\012#elif Intel\012     ihc::collect((ImgGaussianIntel<SrcType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, SEPARABLE_FILTER,stream_type0, stream_type1,decltype(input0),decltype(output1),input0,output1>));\012#endif\012	 }\012};\012\012/** @brief  Computes a median pixel value over a window of the input image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param stream_type0 type of streamming for of Input for intel FPGAs\012@param stream_type1 type of streamming for of Output for intel FPGAs\012@param input       Input image\012@param output      Output image\012*/\012template <typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0, typename vx_type0, vx_type0 &input0, vx_type0 &output1>\012void ImgMedianIntel(){\012	HwMedian<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input0,output1);\012}\012template <typename SrcType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, typename vx_type0, typename vx_type1, vx_type0 &input0, vx_type1 &output1, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e>\012struct ImgMedian{\012     ImgMedian(){\012#ifdef Xilinx\012     ImgMedian<SrcType, VEC_NUM, COLS_FHD, ROWS_FHD, FILTER_SIZE, BORDER_TYPE>(input0, output1);\012#elif Intel\012     ihc::launch((ImgMedianIntel<SrcType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1,decltype(input0),decltype(output1),input0,output1>));\012#endif\012	 }\012     void vxReleaseNode(){\012#ifdef Xilinx\012#elif Intel\012     ihc::collect((ImgMedianIntel<SrcType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1,decltype(input0),decltype(output1),input0,output1>));\012#endif\012	 }\012};\012\012/** @brief  Implements the Scharr Image Filter Kernel. The output images dimensions should be the same as the dimensions of the input image.\012@param SrcType     Data type of the input image (unsigned)(8-bit, 16-bit, 32-bit)\012@param DstType     Data type of the output image (signed)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param stream_type0 type of streamming for of Input for intel FPGAs\012@param stream_type1 type of streamming for of Output1 for intel FPGAs\012@param stream_type2 type of streamming for of Output2 for intel FPGAs\012@param input       The input image\012@param output1     The output image (x derivative)\012@param output2     The output image (y derivative)\012*/\012template <typename SrcType, typename DstType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_border_e BORDER_TYPE, int stream_type0,int stream_type1, typename vx_type0, typename vx_type1, vx_type0 &input0, vx_type1 &output1, vx_type1 &output2>\012void ImgScharr3x3Intel(){\012	HwScharr3x3<SrcType, DstType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, BORDER_TYPE>(input0, output1, output2);\012}\012template <typename SrcType, typename DstType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, typename vx_type0, typename vx_type1, typename vx_type2, vx_type0 &input0, vx_type1 &output1, vx_type2 &output2, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012struct ImgScharr3x3{\012     ImgScharr3x3(){\012#ifdef Xilinx\012     ImgScharr3x3<SrcType, DstType, VEC_NUM, COLS_FHD, ROWS_FHD, BORDER_TYPE>(input0, output1, output2);\012#elif Intel\012     ihc::launch((ImgScharr3x3Intel<SrcType, DstType,VEC_NUM, WIDTH, HEIGHT, BORDER_TYPE,stream_type0,stream_type1,stream_type2,decltype(input0),decltype(output1),decltype(output2),input0,output1,output2>));\012#endif\012	 }\012     void vxReleaseNode(){\012#ifdef Xilinx\012#elif Intel\012     ihc::collect((ImgScharr3x3Intel<SrcType, DstType,VEC_NUM, WIDTH, HEIGHT, BORDER_TYPE,stream_type0,stream_type1,stream_type2,decltype(input0),decltype(output1),decltype(output2),input0,output1,output2>));\012#endif\012	 }\012};\012\012\012/** @brief  Computes a Non-Max suppression over a 3x3 window of the input image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param stream_type0 type of streamming for of Input for intel FPGAs\012@param stream_type1 type of streamming for of Output for intel FPGAs\012@param input       Input image\012@param output      Output image\012*/\012template <typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0, int stream_type1, typename vx_type0, typename vx_type1, vx_type0 &input0, vx_type1 &output1>\012void ImgNonMaximaSuppressionIntel(){\012 	HwNonMaximaSuppression<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, vx_type0, vx_type1>(input0, output1);\012}\012\012template <typename SrcType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, typename vx_type0, typename vx_type1, vx_type0 &input0, vx_type1 &output1, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e>\012struct ImgNonMaximaSuppression{\012     ImgNonMaximaSuppression(){\012#ifdef Xilinx\012     ImgNonMaximaSuppression<SrcType, VEC_NUM, COLS_FHD, ROWS_FHD, FILTER_SIZE, BORDER_TYPE>(input0, output1);\012#elif Intel\012     ihc::launch((ImgNonMaximaSuppressionIntel<SrcType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1,decltype(input0),decltype(output1),input0, output1>));\012#endif\012	 }\012     void vxReleaseNode(){\012#ifdef Xilinx\012#elif Intel\012     ihc::collect((ImgNonMaximaSuppressionIntel<SrcType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1,decltype(input0),decltype(output1),input0,output1>));\012#endif\012	 }\012};\012\012\012/** @brief  Computes a Non-Max suppression over a 3x3 window for canny with\012 * phhse \012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param stream_type0 type of streamming for of Input for intel FPGAs\012@param phase        type of streamming for phase data \012@param stream_type1 type of streamming for of Output for intel FPGAs\012@param input       Input image\012@param output      Output image\012*/\012template <typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0, int stream_type1, typename vx_type0, typename vx_type1, vx_type0 &input0, vx_type0 &input1, vx_type1 &output1>\012void ImgNonMaximaSuppressionPhaseIntel(){\012 	HwNonMaximaSuppressionPhase4<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, vx_type0, vx_type1>(input0, input1, output1);\012}\012\012template <typename SrcType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, typename vx_type0, typename vx_type1, vx_type0 &input0, vx_type0 &input1, vx_type1 &output1, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e>\012struct ImgNonMaximaSuppressionPhase{\012     ImgNonMaximaSuppressionPhase(){\012#ifdef Xilinx\012     ImgNonMaximaSuppressionPhase<SrcType, VEC_NUM, COLS_FHD, ROWS_FHD, FILTER_SIZE, BORDER_TYPE>(input0, output1);\012#elif Intel\012     ihc::launch((ImgNonMaximaSuppressionPhaseIntel<SrcType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1,decltype(input0),decltype(output1),input0, input1,output1>));\012#endif\012	 }\012     void vxReleaseNode(){\012#ifdef Xilinx\012#elif Intel\012     ihc::collect((ImgNonMaximaSuppressionPhaseIntel<SrcType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1,decltype(input0),decltype(output1),input0,input1,output1>));\012#endif\012	 }\012};\012\012\012\012/** @brief  Computes a Census Transform  over a 3x3 window of the input image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param stream_type0 type of streamming for of Input for intel FPGAs\012@param stream_type1 type of streamming for of Output for intel FPGAs\012@param input       Input image\012@param output      Output image\012*/\012template <typename InType, typename OutType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0, int stream_type1, typename vx_type0, typename vx_type1, vx_type0 &input0, vx_type1 &output1>\012void ImgCensusIntel(){\012 	HwCensusTransform<InType,OutType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, vx_type0, vx_type1>(input0, output1);\012}\012\012template <typename SrcType,typename DstType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, typename vx_type0, typename vx_type1, vx_type0 &input0, vx_type1 &output1, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e>\012struct ImgCensus{\012     ImgCensus(){\012#ifdef Xilinx\012     ImgCensus<SrcType, DstType,VEC_NUM, COLS_FHD, ROWS_FHD, FILTER_SIZE, BORDER_TYPE>(input0, output1);\012#elif Intel\012     ihc::launch((ImgCensusIntel<SrcType, DstType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1,decltype(input0),decltype(output1),input0, output1>));\012#endif\012	 }\012     void vxReleaseNode(){\012#ifdef Xilinx\012#elif Intel\012     ihc::collect((ImgCensusIntel<SrcType, DstType, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1,decltype(input0),decltype(output1),input0,output1>));\012#endif\012	 }\012};\012\012#endif /* SRC_IMG_FILTER_BASE_H_ */\012"}, {"path":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/img_filter_core.h", "name":"img_filter_core.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/img_filter_core.h", "content":"/**\012* Licence: GNU GPLv3 \\n\012* You may copy, distribute and modify the software as long as you track\012* changes/dates in source files. Any modifications to or software\012* including (via compiler) GPL-licensed code must also be made available\012* under the GPL along with build & install instructions.\012*\012* @file    img_filter_core.h\012* @author  Lester Kalms <lester.kalms@tu-dresden.de>\012* @version 1.3\012* @brief Description:\\n\012*  These are the core functions used for the hardware accelerated image processing functions (Do not call functions from here)\012*/\012\012#ifndef SRC_IMG_FILTER_CORE_H_\012#define SRC_IMG_FILTER_CORE_H_\012#include \"HLS/hls.h\"\012#include \"vx_fpga.h\"\012#include \"img_helper.h\"\012\012\012using namespace std;\012\012/*********************************************************************************************************************/\012/* Linebuffer Functions */\012/*********************************************************************************************************************/\012\012/** @brief Reads data from line buffers\012@param VecType     1 vector is 1 linebuffer element\012@param KERN_SIZE   The size of the filter kernel\012@param VEC_COLS    The amount of columns in the vectorized image\012@param input       New image data to be stored into the linebuffer\012@param linebuffer  Linebuffers to store (KERN_SIZE-1) image rows\012@param output      Data at x coordinates in the linebuffers\012@param x           The x coordinate in the vectorized image\012*/\012template <typename InType, typename BufferType, const vx_uint16 BUFFER_NUM, const vx_uint8 VEC_NUM, const vx_uint16 KERN_SIZE, const vx_uint16 VEC_COLS>\012void ReadFromLineBuffer(InType input[VEC_NUM], BufferType linebuffer[BUFFER_NUM][VEC_COLS], InType output[KERN_SIZE][VEC_NUM], const vx_uint16 x) {\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012\012	// For data type conversion to decrease BRAM usage: FACTOR*BUFFER_NUM = (KERN_SIZE-1)*VEC_NUM\012	const vx_uint16 FACTOR = sizeof(BufferType) / sizeof(InType);\012\012	// Buffer for data type conversion\012#ifdef Xilinx\012	BufferType buffer1[BUFFER_NUM];\012        #pragma HLS array_partition variable=buffer1 complete dim=0\012#elif Intel\012	BufferType buffer1[BUFFER_NUM] hls_register;\012#endif\012\012#ifdef Xilinx\012	InType buffer2[BUFFER_NUM*FACTOR];\012	#pragma HLS array_partition variable=buffer2 complete dim=0\012#elif Intel\012	InType buffer2[BUFFER_NUM*FACTOR] hls_register;\012#endif\012\012\012	// Check linebuffer border\012	if (x < VEC_COLS)\012       {\012		// Read data from linebuffer\012UNROLL_INTEL()\012		for (vx_uint16 i = 0; i < BUFFER_NUM; i++) {\012UNROLL_XILINX()\012			buffer1[i] = linebuffer[i][x];\012		}\012\012		// Unpack data\012UNROLL_INTEL()\012		for (vx_uint16 i = 0; i < BUFFER_NUM; i++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012			for (vx_uint16 j = 0; j < FACTOR; j++) {\012UNROLL_XILINX()\012				vx_uint16 shift = j * static_cast<vx_uint16>(sizeof(InType)) * static_cast<vx_uint16>(8);\012				buffer2[i*FACTOR + j] = static_cast<InType>(buffer1[i] >> shift);\012			}\012		}\012\012		// Pack data for output\012#ifdef Intel\012	#pragma loop_coalesce\012#endif\012UNROLL_INTEL()\012		for (vx_uint16 i = 0; i < KERN_SIZE-1; i++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012			for (vx_uint16 j = 0; j < VEC_NUM; j++) {\012UNROLL_XILINX()\012				output[i][j] = buffer2[i*VEC_NUM + j];\012			}\012		}\012		UNROLL_INTEL()\012		for (vx_uint16 j = 0; j < VEC_NUM; j++) {\012		UNROLL_XILINX()\012			output[KERN_SIZE - 1][j] = input[j];\012		}\012	}//end if VEC_COLS\012}\012\012/** @brief Writes data to line buffers\012@param VecType     1 vector is 1 linebuffer element\012@param KERN_SIZE   The size of the filter kernel\012@param VEC_COLS    The amount of columns in the vectorized image\012@param input       Stores data at the x coordinates of the linebuffers\012@param linebuffer  Linebuffers to store (KERN_SIZE-1) image rows\012@param x           The x coordinate in the vectorized image\012*/\012template <typename InType, typename BufferType, const vx_uint16 BUFFER_NUM, const vx_uint8 VEC_NUM, const vx_uint16 KERN_SIZE, const vx_uint16 VEC_COLS>\012void WriteToLineBuffer(InType input[KERN_SIZE][VEC_NUM], BufferType linebuffer[BUFFER_NUM][VEC_COLS], const vx_uint16 x) {\012\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	// For data type conversion to decrease BRAM usage: FACTOR*BUFFER_NUM = (KERN_SIZE-1)*VEC_NUM\012	const vx_uint16 FACTOR = sizeof(BufferType) / sizeof(InType);\012\012	// Buffer for data type conversion\012#ifdef Xilinx\012	InType buffer1[(KERN_SIZE - 1)*VEC_NUM];\012	#pragma HLS array_partition variable=buffer1 complete dim=0\012#elif Intel\012        InType buffer1[(KERN_SIZE - 1)*VEC_NUM] hls_register;\012#endif\012\012#ifdef Xilinx\012	BufferType buffer2[BUFFER_NUM];\012	#pragma HLS array_partition variable=buffer2 complete dim=0\012#elif Intel\012	BufferType buffer2[BUFFER_NUM] hls_register;\012#endif\012	// Check linebuffer border\012	if (x < VEC_COLS) {\012\012		// Unpack data from input\012\012UNROLL_INTEL()\012		for (vx_uint16 i = 0; i < KERN_SIZE - 1; i++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012			for (vx_uint16 j = 0; j < VEC_NUM; j++) {\012UNROLL_XILINX()\012				buffer1[i*VEC_NUM + j] = input[i + 1][j];\012			}\012		}\012\012		// Pack data for linebuffer\012UNROLL_INTEL()\012		for (vx_uint16 i = 0; i < BUFFER_NUM; i++) {\012UNROLL_XILINX()\012			BufferType data = 0;\012UNROLL_INTEL()\012			for (vx_uint16 j = 0; j < FACTOR; j++) {\012UNROLL_XILINX()\012				vx_uint16 shift = j * static_cast<vx_uint16>(sizeof(InType)) * static_cast<vx_uint16>(8);\012				data |= (static_cast<BufferType>(buffer1[i*FACTOR + j])) << shift;\012			}\012			buffer2[i] = data;\012		}\012\012		// Write to linebuffer\012UNROLL_INTEL()\012		for (vx_uint16 i = 0; i < BUFFER_NUM; i++) {\012UNROLL_XILINX()\012			linebuffer[i][x] = buffer2[i];\012		}\012	}\012}\012\012/*********************************************************************************************************************/\012/* Sliding Window Functions for Different Border Types */\012/*********************************************************************************************************************/\012\012/** @brief Replicates the y borders if needed for the sliding window\012@param VecType     1 vector is 1 linebuffer element\012@param IMG_ROWS    Amount of rows in the image\012@param KERN_RAD    Radius of the filter kernel\012@param KERN_SIZE   Total amount of rows in the sliding window\012@param input       Output of the linebuffers\012@param output      Input with replicated borders if needed\012@param y           y coordinate of the image\012*/\012template <typename InType, const vx_uint8 VEC_NUM, const vx_uint32 IMG_ROWS, const vx_uint16 KERN_RAD, const vx_uint16 KERN_SIZE>\012void SlidingWindowReplicatedY(const InType input[KERN_SIZE][VEC_NUM], InType output[KERN_SIZE][VEC_NUM], const vx_uint16 y) {\012\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	// Get upper pixels and check y border\012	if (KERN_RAD > 0) {\012UNROLL_INTEL()\012		for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012UNROLL_XILINX()\012			output[KERN_RAD - 1][v] = (y > KERN_RAD) ? (input[KERN_RAD - 1][v]) : (input[KERN_RAD][v]);\012		}\012		//output[KERN_RAD - 1] = (y > KERN_RAD) ? (input[KERN_RAD - 1]) : (input[KERN_RAD]);\012UNROLL_INTEL()\012		for (vx_int32 i = KERN_RAD - 2; i >= 0; i--) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012			for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012UNROLL_XILINX()\012				output[i][v] = (y > static_cast<vx_uint16>(KERN_SIZE - 2 - i)) ? (input[i][v]) : (output[i + 1][v]);\012			}\012		}\012	}\012\012	// Pass through observed pixel in the image\012UNROLL_INTEL()\012	for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012UNROLL_XILINX()\012		output[KERN_RAD][v] = input[KERN_RAD][v];\012	}\012\012	// Get lower pixels and check y border\012	if (KERN_RAD > 0) {\012UNROLL_INTEL()\012		for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012UNROLL_XILINX()\012			output[KERN_RAD + 1][v] = (y < IMG_ROWS + KERN_RAD - 1) ? (input[KERN_RAD + 1][v]) : (input[KERN_RAD][v]);\012		}\012UNROLL_INTEL()\012		for (vx_uint16 i = KERN_RAD + 2; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012			for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012UNROLL_XILINX()\012				output[i][v] = (y < static_cast<vx_uint16>(IMG_ROWS + KERN_SIZE - 1 - i)) ? (input[i][v]) : (output[i - 1][v]);\012			}\012		}\012	}\012}\012\012/** @brief Moves sliding window and a replicated border in x direction\012@param ScalarType  The data type of the image elements\012@param KERN_SIZE   Total amount of rows in the sliding window\012@param VEC_COLS    The amount of columns in the vectorized image\012@param VEC_SIZE    The number of elements in a vector\012@param WIN_BORD_A  Internal vertical border for the sliding window\012@param WIN_BORD_B  Internal vertical border for the sliding window\012@param WIN_COLS    The number of columns in a row\012@param input       An array of input data for each row\012@param window      The sliding window\012@param x           x coordinate of the vectorized image\012*/\012template <typename ScalarType, const vx_uint16 KERN_SIZE, const vx_uint16 VEC_COLS, const vx_uint16 VEC_SIZE, const vx_uint16 WIN_BORD_A, const vx_uint16 WIN_BORD_B, const vx_uint16 WIN_COLS>\012void SlidingWindowReplicatedX(ScalarType input[KERN_SIZE][VEC_SIZE], ScalarType window[KERN_SIZE][WIN_COLS], const vx_uint16 x) {\012\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	// Move sliding window and check x border\012UNROLL_INTEL()\012	for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012\012		// Move sliding window\012UNROLL_INTEL()\012		for (vx_uint16 j = 0; j < WIN_BORD_A; j++) {\012UNROLL_XILINX()\012			window[i][j] = window[i][j + VEC_SIZE];\012		}\012\012		// Move pixel in sliding window and get/check left x border\012UNROLL_INTEL()\012		for (vx_uint16 j = WIN_BORD_A; j < WIN_BORD_B; j++) {\012UNROLL_XILINX()\012			if (x == 0)\012				window[i][j] = input[i][0];\012			else\012				window[i][j] = window[i][j + VEC_SIZE];\012		}\012\012		// Get new pixel array and check right x border\012UNROLL_INTEL()\012		for (vx_uint16 j = WIN_BORD_B; j < WIN_COLS; j++) {\012UNROLL_XILINX()\012			if (x >= VEC_COLS) {\012				window[i][j] = window[i][WIN_BORD_B-1];\012			} else {\012				window[i][j] = input[i][j - WIN_BORD_B];\012			}\012		}\012	}\012}\012\012/** @brief Sets a constant border of 0 for the sliding window\012@param VecType     1 vector is 1 linebuffer element\012@param IMG_ROWS    Amount of rows in the image\012@param KERN_RAD    Radius of the filter kernel\012@param KERN_SIZE   Total amount of rows in the sliding window\012@param input       Output of the linebuffers\012@param output      Input with replicated borders if needed\012@param y           y coordinate of the image\012*/\012template <typename InType, const vx_uint8 VEC_NUM, const vx_uint32 IMG_ROWS, const vx_uint16 KERN_RAD, const vx_uint16 KERN_SIZE>\012void SlidingWindowConstantY(const InType input[KERN_SIZE][VEC_NUM], InType output[KERN_SIZE][VEC_NUM], const vx_uint16 y) {\012\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	// Get upper pixels and check y border\012UNROLL_INTEL()\012	for (vx_uint16 i = 0; i < KERN_RAD; i++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012UNROLL_XILINX()\012			output[i][v] = (y > KERN_SIZE - 2 - i) ? (input[i][v]) : (0);\012		}\012	}\012\012	// Pass through observed pixel in the image\012UNROLL_INTEL()\012	for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012UNROLL_XILINX()\012		output[KERN_RAD][v] = input[KERN_RAD][v];\012	}\012\012	// Get lower pixels and check y border\012UNROLL_INTEL()\012	for (vx_uint16 i = KERN_RAD + 1; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012UNROLL_XILINX()\012			output[i][v] = (y < IMG_ROWS + KERN_SIZE - 1 - i) ? (input[i][v]) : (0);\012		}\012	}\012}\012\012/** @brief Moves sliding window and a constant border in x direction\012@param ScalarType  The data type of the image elements\012@param KERN_SIZE   Total amount of rows in the sliding window\012@param VEC_COLS    The amount of columns in the vectorized image\012@param VEC_SIZE    The number of elements in a vector\012@param WIN_BORD_A  Internal vertical border for the sliding window\012@param WIN_BORD_B  Internal vertical border for the sliding window\012@param WIN_COLS    The number of columns in a row\012@param input       An array of input data for each row\012@param window      The sliding window\012@param x           x coordinate of the vectorized image\012*/\012template <typename ScalarType, const vx_uint16 KERN_SIZE, const vx_uint16 VEC_COLS, const vx_uint16 VEC_SIZE, const vx_uint16 WIN_BORD_A, const vx_uint16 WIN_BORD_B, const vx_uint16 WIN_COLS>\012void SlidingWindowConstantX(ScalarType input[KERN_SIZE][VEC_SIZE], ScalarType window[KERN_SIZE][WIN_COLS], const vx_uint16 x) {\012\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012UNROLL_INTEL()\012	for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012\012		// Move sliding window\012UNROLL_INTEL()\012		for (vx_uint16 j = 0; j < WIN_BORD_A; j++) {\012UNROLL_XILINX()\012			window[i][j] = window[i][j + VEC_SIZE];\012		}\012\012		// Move pixel in sliding window and get/check left x border\012UNROLL_INTEL()\012		for (vx_uint16 j = WIN_BORD_A; j < WIN_BORD_B; j++) {\012UNROLL_XILINX()\012			if (x == 0)\012				window[i][j] = 0;\012			else\012				window[i][j] = window[i][j + VEC_SIZE];\012		}\012\012		// Get new pixel vector and check right x border\012UNROLL_INTEL()\012		for (vx_uint16 j = WIN_BORD_B; j < WIN_COLS; j++) {\012UNROLL_XILINX()\012			if (x >= VEC_COLS)\012				window[i][j] = 0;\012			else\012				window[i][j] = input[i][j - WIN_BORD_B];\012		}\012	}\012}\012\012/** @brief Moves sliding window without considering borders\012@param ScalarType  The data type of the image elements\012@param KERN_SIZE   Total amount of rows in the sliding window\012@param VEC_SIZE    The number of elements in a vector\012@param WIN_BORD_B  Internal vertical border for the sliding window\012@param WIN_COLS    The number of columns in a row\012@param input       An array of input data for each row\012@param window      The sliding window\012*/\012template <typename ScalarType, const vx_uint16 KERN_SIZE, const vx_uint16 VEC_SIZE, const vx_uint16 WIN_BORD_B, const vx_uint16 WIN_COLS>\012void SlidingWindowUnchanged(const ScalarType input[KERN_SIZE][VEC_SIZE], ScalarType window[KERN_SIZE][WIN_COLS]) {\012\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012\012UNROLL_INTEL()\012	for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012\012		// Move sliding window\012UNROLL_INTEL()\012		for (vx_uint16 j = 0; j < WIN_BORD_B; j++) {\012UNROLL_XILINX()\012			window[i][j] = window[i][j + VEC_SIZE];\012		}\012\012		// Get new pixel vector\012UNROLL_INTEL()\012		for (vx_uint16 j = WIN_BORD_B; j < WIN_COLS; j++) {\012UNROLL_XILINX()\012			window[i][j] = input[i][j - WIN_BORD_B];\012		}\012	}\012}\012\012/*********************************************************************************************************************/\012/* Main sliding Window Functions */\012/*********************************************************************************************************************/\012\012/** @brief Sliding window horizontal main function / considers different border types\012@param VecType     1 vector is processed in each clock cycle\012@param ScalarType  1 vector contains N scalar elements\012@param KERN_RAD    Radius of the filter kernel\012@param VEC_COLS    The amount of columns in the vectorized image\012@param VEC_SIZE    The number of elements in a vector\012@param WIN_COLS    The number of columns in a row\012@param BORDER_TYPE The border type that is considered in the sliding window\012@param input       The input buffer\012@param window      The output sliding window\012@param x           The x current coordinate\012*/\012template <typename ScalarType, const vx_uint16 KERN_RAD, const vx_uint16 VEC_COLS, const vx_uint16 VEC_SIZE, const vx_uint16 WIN_COLS, const vx_border_e BORDER_TYPE>\012void SlidingWindowHorizontal(const ScalarType input[VEC_SIZE], ScalarType window[1][WIN_COLS], const vx_uint16 x) {\012\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	// Constants\012	const vx_uint16 WIN_BORD_A = WIN_COLS - VEC_SIZE - KERN_RAD;\012	const vx_uint16 WIN_BORD_B = WIN_COLS - VEC_SIZE;\012\012	// Input data rows in scalar representation (after considering y border)\012	#ifdef Xilinx\012	ScalarType input_vector[1][VEC_SIZE];\012	#pragma HLS array_partition variable=input_vector complete  dim=0\012        #elif Intel\012	ScalarType input_vector[1][VEC_SIZE]hls_register;\012	#endif\012\012UNROLL_INTEL()\012	for (vx_uint16 i = 0; i < VEC_SIZE; i++) {\012UNROLL_XILINX()\012		input_vector[0][i] = input[i];\012	}\012\012	// REPLICATED: replicates the border values when exceeding borders\012	if (BORDER_TYPE == VX_BORDER_REPLICATE) {\012\012		// Sets sliding window and replicated x borders\012		SlidingWindowReplicatedX<ScalarType, 1, VEC_COLS, VEC_SIZE, WIN_BORD_A, WIN_BORD_B, WIN_COLS>(input_vector, window, x);\012\012	// CONSTANT: creates a constant border of zeros around the image\012	} else if (BORDER_TYPE == VX_BORDER_CONSTANT) {\012\012		// Sets sliding window and constant x borders\012		SlidingWindowConstantX<ScalarType, 1, VEC_COLS, VEC_SIZE, WIN_BORD_A, WIN_BORD_B, WIN_COLS>(input_vector, window, x);\012\012	// UNCHANGED: filters exceeding the borders are invalid\012	} else if (BORDER_TYPE == VX_BORDER_UNDEFINED) {\012\012		// Sets sliding window and does not create borders\012		SlidingWindowUnchanged<ScalarType, 1, VEC_SIZE, WIN_BORD_B, WIN_COLS>(input_vector, window);\012	}\012}\012\012/** @brief Sliding window main function / considers different border types\012@param VecType     1 vector is processed in each clock cycle\012@param ScalarType  1 vector contains N scalar elements\012@param IMG_ROWS    Amount of rows in the image\012@param KERN_RAD    Radius of the filter kernel\012@param VEC_SIZE    The number of elements in a vector\012@param KERN_SIZE   Total amount of rows in the sliding window\012@param BORDER_TYPE The border type that is considered in the sliding window\012@param input       The input buffer\012@param window      The output sliding window\012@param y           The y current coordinate\012*/\012template <typename ScalarType, const vx_uint32 IMG_ROWS, const vx_uint16 KERN_RAD, const vx_uint16 VEC_SIZE, const vx_uint16 KERN_SIZE, const vx_border_e BORDER_TYPE>\012void SlidingWindowVertical(const ScalarType input[KERN_SIZE][VEC_SIZE], ScalarType window[KERN_SIZE][VEC_SIZE], const vx_uint16 y) {\012\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	// Input data rows in vector representation (after considering y border)\012#ifdef Xilinx\012	ScalarType buffer_vector[KERN_SIZE][VEC_SIZE];\012	#pragma HLS array_partition variable=buffer_vector complete dim=0\012#elif Intel\012	ScalarType buffer_vector[KERN_SIZE][VEC_SIZE] hls_register;\012#endif\012	// REPLICATED: replicates the border values when exceeding borders\012	if (BORDER_TYPE == VX_BORDER_REPLICATE) {\012\012		// Replicated y borders\012		SlidingWindowReplicatedY<ScalarType, VEC_SIZE, IMG_ROWS, KERN_RAD, KERN_SIZE>(input, buffer_vector, y);\012\012	// CONSTANT: creates a constant border of zeros around the image\012	} else if (BORDER_TYPE == VX_BORDER_CONSTANT) {\012\012		// Constant y borders\012		SlidingWindowConstantY<ScalarType, VEC_SIZE, IMG_ROWS, KERN_RAD, KERN_SIZE>(input, buffer_vector, y);\012	}\012\012	// Convert from vector to scalar type\012UNROLL_INTEL()\012	for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint16 j = 0; j < VEC_SIZE; j++) {\012UNROLL_XILINX()\012			if(BORDER_TYPE == VX_BORDER_REPLICATE || BORDER_TYPE == VX_BORDER_CONSTANT)\012				window[i][j] = buffer_vector[i][j];\012			else if(BORDER_TYPE == VX_BORDER_UNDEFINED)\012				window[i][j] = input[i][j];\012		}\012	}\012}\012\012/** @brief Sliding window main function / considers different border types\012@param VecType     1 vector is processed in each clock cycle\012@param ScalarType  1 vector contains N scalar elements\012@param IMG_ROWS    Amount of rows in the image\012@param KERN_RAD    Radius of the filter kernel\012@param VEC_COLS    The amount of columns in the vectorized image\012@param VEC_SIZE    The number of elements in a vector\012@param WIN_COLS    The number of columns in a row\012@param KERN_SIZE   Total amount of rows in the sliding window\012@param BORDER_TYPE The border type that is considered in the sliding window\012@param input       The input buffer\012@param window      The output sliding window\012@param x           The x current coordinate\012@param y           The y current coordinate\012*/\012template <typename InType, const vx_uint8 VEC_NUM, const vx_uint32 IMG_ROWS, const vx_uint16 KERN_RAD, const vx_uint16 VEC_COLS, const vx_uint16 WIN_COLS, const vx_uint16 KERN_SIZE, const vx_border_e BORDER_TYPE>\012void SlidingWindow(const InType input[KERN_SIZE][VEC_NUM], InType window[KERN_SIZE][WIN_COLS], const vx_uint16 x, const vx_uint16 y) {\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Constants\012	const vx_uint16 WIN_BORD_A = WIN_COLS - VEC_NUM - KERN_RAD;\012	const vx_uint16 WIN_BORD_B = WIN_COLS - VEC_NUM;\012\012	// Input data rows in vector representation (after considering y border)\012	#ifdef Xilinx\012	InType buffer_vector[KERN_SIZE][VEC_NUM];\012	#pragma HLS array_partition variable=buffer_vector complete dim=0\012	#elif Intel\012	InType buffer_vector[KERN_SIZE][VEC_NUM] hls_register;\012	#endif\012\012\012	// REPLICATED: replicates the border values when exceeding borders\012	if (BORDER_TYPE == VX_BORDER_REPLICATE) {\012\012		// Replicated y borders\012		SlidingWindowReplicatedY<InType, VEC_NUM, IMG_ROWS, KERN_RAD, KERN_SIZE>(input, buffer_vector, y);\012\012		// Sets sliding window and replicated x borders\012		SlidingWindowReplicatedX<InType, KERN_SIZE, VEC_COLS, VEC_NUM, WIN_BORD_A, WIN_BORD_B, WIN_COLS>(buffer_vector, window, x);\012\012	// CONSTANT: creates a constant border of zeros around the image\012	} else if (BORDER_TYPE == VX_BORDER_CONSTANT) {\012\012		// Constant y borders\012		SlidingWindowConstantY<InType, VEC_NUM, IMG_ROWS, KERN_RAD, KERN_SIZE>(input, buffer_vector, y);\012\012		// Sets sliding window and constant x borders\012		SlidingWindowConstantX<InType, KERN_SIZE, VEC_COLS, VEC_NUM, WIN_BORD_A, WIN_BORD_B, WIN_COLS>(buffer_vector, window, x);\012\012	// UNCHANGED: filters exceeding the borders are invalid\012	} else if (BORDER_TYPE == VX_BORDER_UNDEFINED) {\012\012		// Sets sliding window and does not create borders\012		SlidingWindowUnchanged<InType, KERN_SIZE, VEC_NUM, WIN_BORD_B, WIN_COLS>(input, window);\012	}\012}\012\012/*********************************************************************************************************************/\012/* Filter Sub-Functions */\012/*********************************************************************************************************************/\012\012/** @brief Compares and swaps 2 elements\012@param InType  Data type of the image pixels\012@param A       1. element to be compared\012@param B       2. element to be compared\012@param H       smaller element\012@param L       bigger element\012*/\012template <typename InType>\012void CompareAndSwap(InType A, InType B, InType &L, InType &H) {\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Compare and Swap\012	if (A > B) {\012		L = B;\012		H = A;\012	} else {\012		L = A;\012		H = B;\012	}\012}\012\012/*********************************************************************************************************************/\012/* Filter Functions */\012/*********************************************************************************************************************/\012\012/** @brief Computes a 1d box filter\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KERN_SIZE     The size of the kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the box filter\012*/\012template <typename ScalarType, const vx_uint16 KERN_SIZE>\012ScalarType ComputeBox1d(ScalarType window[KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Variable\012	vx_uint64 result = 0;\012\012	// Sum all input data\012UNROLL_INTEL()\012	for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012		result += static_cast<vx_uint64>(window[i]);\012	}\012\012	// Normalize\012	const vx_uint64 rounding = static_cast<vx_uint64>(1) << (kernel_shift - 1);\012	const vx_uint64 norm = (result * kernel_mult + rounding) >> kernel_shift;\012\012	// Return result\012	return static_cast<ScalarType>(norm);\012}\012\012/** @brief Computes a 2d box filter\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KERN_SIZE     The size of the kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the box filter\012*/\012template <typename InType, typename OutType, const vx_uint16 KERN_SIZE>\012OutType ComputeBox2d(InType window[KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Variable\012	vx_uint64 result = 0;\012\012	// Sum all input data\012UNROLL_INTEL()\012	for (vx_uint16 y = 0; y < KERN_SIZE; y++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint16 x = 0; x < KERN_SIZE; x++) {\012UNROLL_XILINX()\012			result += static_cast<vx_uint64>(window[y][x]);\012		}\012	}\012\012	// Normalize\012	const vx_uint64 rounding = static_cast<vx_uint64>(1) << (kernel_shift - 1);\012	const vx_uint64 norm = (result * kernel_mult + rounding) >> kernel_shift;\012\012	// Return result\012	return static_cast<OutType>(norm);\012}\012\012/** @brief Computes a 2d convolution filter\012@param InType        The input scalar data type\012@param CompType      Data type for internal computation (uint64 or int64)\012@param OutType       The output scalar data type\012@param KernType      The kernel scalar data type\012@param KERN_SIZE     The size of the kernel\012@param inKernel      The costum kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the convolution filter\012*/\012template <typename InType, typename CompType, typename OutType, typename KernType, const vx_uint16 KERN_SIZE>\012OutType ComputeConvolve2d(KernType kernel[KERN_SIZE][KERN_SIZE], InType window[KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Variables\012	CompType result = 0;\012\012	// Compute the costum filter\012UNROLL_INTEL()\012	for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint16 j = 0; j < KERN_SIZE; j++) {\012UNROLL_XILINX()\012			CompType kernelData = static_cast<CompType>(kernel[i][j]);\012			CompType windowData = static_cast<CompType>(window[i][j]);\012			result += (kernelData * windowData);\012		}\012	}\012\012	// Normalize\012	const vx_uint64 rounding = static_cast<vx_uint64>(1) << (kernel_shift - 1);\012	const vx_uint64 norm = (result * kernel_mult + rounding) >> kernel_shift;\012\012	// Return result\012	return static_cast<OutType>(norm);\012}\012\012/** @brief Computes a 1d dilate filter\012@param ScalarType    The Scalar Data type\012@param KERN_SIZE     The size of the kernel\012@param window        The sliding window of this scalar computation\012@return              The result of the dilate filter\012*/\012template <typename ScalarType, const vx_uint16 KERN_SIZE>\012ScalarType ComputeDilate1d(ScalarType window[KERN_SIZE]) {\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Compute dilate\012	ScalarType result = window[0];\012UNROLL_INTEL()\012	for (vx_uint16 i = 1; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012		result = max(result, window[i]);\012	}\012\012	// Return result\012	return result;\012}\012\012/** @brief Computes a 1d erode filter\012@param ScalarType    The Scalar Data type\012@param KERN_SIZE     The size of the kernel\012@param window        The sliding window of this scalar computation\012@return              The result of the erode filter\012*/\012template <typename ScalarType, const vx_uint16 KERN_SIZE>\012ScalarType ComputeErode1d(ScalarType window[KERN_SIZE]) {\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Compute erode\012	ScalarType result = window[0];\012UNROLL_INTEL()\012	for (vx_uint16 i = 1; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012		result = min(result, window[i]);\012	}\012\012	// Return result\012	return result;\012}\012\012/** @brief Computes a gaussian 1d filter (optimized to the kernel symmetry)\012@param ScalarType    The input/output data type\012@param KernType      The kernel scalar data type\012@param KERN_SIZE     The size of the kernel\012@param kernel        The gaussian kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the gaussian convolution\012*/\012template <typename ScalarType, typename KernelType, const vx_uint16 KERN_SIZE>\012ScalarType ComputeGaussian1d(KernelType kernel[KERN_SIZE], ScalarType window[KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Constants\012	const vx_uint16 KERN_RAD = KERN_SIZE >> 1;\012\012	// Get middle pixel result\012	vx_uint64 result = static_cast<vx_uint64>(kernel[KERN_RAD]) * static_cast<vx_uint64>(window[KERN_RAD]);\012\012	// Add all other pixel to result\012UNROLL_INTEL()\012	for (vx_uint16 i = 0; i < KERN_RAD; i++) {\012UNROLL_XILINX()\012		vx_uint64 A = static_cast<vx_uint64>(kernel[i]);\012		vx_uint64 B0 = static_cast<vx_uint64>(window[i]);\012		vx_uint64 B1 = static_cast<vx_uint64>(window[KERN_SIZE - i - 1]);\012		result += A * (B0 + B1);\012	}\012\012	// Normalize\012	const vx_uint64 rounding = static_cast<vx_uint64>(1) << (kernel_shift - 1);\012	const vx_uint64 norm = (result * kernel_mult + rounding) >> kernel_shift;\012\012	// Return result\012	return static_cast<ScalarType>(norm);\012}\012\012/** @brief Computes a gaussian 2d filter (optimized to the kernel symmetry)\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KernType      The kernel scalar data type\012@param KERN_SIZE     The size of the kernel\012@param kernel        The gaussian kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the gaussian convolution\012*/\012template <typename InType, typename OutType, typename KernType, const vx_uint16 KERN_SIZE>\012OutType ComputeGaussian2d(KernType kernel[KERN_SIZE][KERN_SIZE], InType window[KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012\012	// Constants\012	const vx_uint16 KERN_RAD = KERN_SIZE / 2;\012	const vx_uint16 KERN_RNG = KERN_SIZE - 1;\012\012	// Store result of the gaussian filter (scalar)\012	vx_uint64 result = 0;\012\012	// if: (y == KERN_RAD) && (x == KERN_RAD)\012	{\012		vx_uint64 sum = static_cast<vx_uint64>(window[KERN_RAD][KERN_RAD]);\012		result = (static_cast<vx_uint64>(kernel[KERN_RAD][KERN_RAD]) * sum);\012	}\012\012	// if: (y == KERN_RAD) && (x < KERN_RAD)\012UNROLL_INTEL()\012	for (vx_uint16 x = 0; x < KERN_RAD; x++) {\012UNROLL_XILINX()\012		const vx_uint16 RADIUS = KERN_RAD - x;\012		vx_uint64 sum = 0;\012		sum += static_cast<vx_uint64>(window[KERN_RAD][x]);\012		sum += static_cast<vx_uint64>(window[KERN_RAD][KERN_RNG - x]);\012		sum += static_cast<vx_uint64>(window[KERN_RAD + RADIUS][x + RADIUS]);\012		sum += static_cast<vx_uint64>(window[KERN_RAD - RADIUS][x + RADIUS]);\012		result += (static_cast<vx_uint64>(kernel[KERN_RAD][x]) * sum);\012	}\012\012	// if: (y == x) && (x < KERN_RAD)\012UNROLL_INTEL()\012	for (vx_uint16 y = 0; y < KERN_RAD; y++) {\012UNROLL_XILINX()\012		vx_uint64 sum = 0;\012		sum += static_cast<vx_uint64>(window[y][y]);\012		sum += static_cast<vx_uint64>(window[y][KERN_RNG - y]);\012		sum += static_cast<vx_uint64>(window[KERN_RNG - y][y]);\012		sum += static_cast<vx_uint64>(window[KERN_RNG - y][KERN_RNG - y]);\012		result += (static_cast<vx_uint64>(kernel[y][y]) * sum);\012	}\012\012	// if: (y > 0) && (y < KERN_RAD) && (y > x)\012UNROLL_INTEL()\012	for (vx_uint16 x = 0; x <= KERN_RAD; x++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint16 y = x + 1; y < KERN_RAD; y++) {\012UNROLL_XILINX()\012			vx_int64 sum = 0;\012			sum += static_cast<vx_uint64>(window[y][x]);\012			sum += static_cast<vx_uint64>(window[x][y]);\012			sum += static_cast<vx_uint64>(window[KERN_RNG - y][x]);\012			sum += static_cast<vx_uint64>(window[x][KERN_RNG - y]);\012			sum += static_cast<vx_uint64>(window[KERN_RNG - x][y]);\012			sum += static_cast<vx_uint64>(window[y][KERN_RNG - x]);\012			sum += static_cast<vx_uint64>(window[KERN_RNG - x][KERN_RNG - y]);\012			sum += static_cast<vx_uint64>(window[KERN_RNG - y][KERN_RNG - x]);\012			result += (static_cast<vx_uint64>(kernel[y][x]) * sum);\012		}\012	}\012\012	// Normalize\012	const vx_uint64 rounding = static_cast<vx_uint64>(1) << (kernel_shift - 1);\012	const vx_uint64 norm = (result * kernel_mult + rounding) >> kernel_shift;\012\012	// Return result\012	return static_cast<OutType>(norm);\012}\012\012/** @brief Computes a median filter\012@details Algorithm taken from the the following paper:\012A fault-tolerant implementation of the median filter\012from L. A. Aranda and P. Reviriego and J. A. Maestro\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KERN_SIZE     The size of the kernel\012@param window        The sliding window of this scalar computation\012@return              The result of the median filter\012*/\012template <typename InType, typename OutType, const vx_uint16 KERN_SIZE>\012OutType ComputeMedian3x3(InType window[KERN_SIZE][KERN_SIZE]) {\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Variables\012	InType B0, B1, B3, B4, B6, B7;\012	InType C1, C2, C4, C5, C7, C8;\012	InType D0, D1, D3, D4, D6, D7;\012	InType E0, E1, E3, E4, E7, E8;\012	InType F1, F2, F4, F5, F6, F7;\012	InType G3, G4, H3, H4, I4, I5, J3, J4;\012\012	// Input pixel\012	InType A0 = window[0][0], A1 = window[0][1], A2 = window[0][2];\012	InType A3 = window[1][0], A4 = window[1][1], A5 = window[1][2];\012	InType A6 = window[2][0], A7 = window[2][1], A8 = window[2][2];\012\012	// Get median with 19 compare and swap units\012	CompareAndSwap(A0, A1, B0, B1);\012	CompareAndSwap(A3, A4, B3, B4);\012	CompareAndSwap(A6, A7, B6, B7);\012	CompareAndSwap(B1, A2, C1, C2);\012	CompareAndSwap(B4, A5, C4, C5);\012	CompareAndSwap(B7, A8, C7, C8);\012	CompareAndSwap(B0, C1, D0, D1);\012	CompareAndSwap(B3, C4, D3, D4);\012	CompareAndSwap(B6, C7, D6, D7);\012	CompareAndSwap(D0, D3, E0, E1);\012	CompareAndSwap(D1, D4, E3, E4);\012	CompareAndSwap(C5, C8, E7, E8);\012	CompareAndSwap(E1, D6, F1, F2);\012	CompareAndSwap(E4, D7, F4, F5);\012	CompareAndSwap(C2, E7, F6, F7);\012	CompareAndSwap(E3, F4, G3, G4);\012	CompareAndSwap(F2, G4, H3, H4);\012	CompareAndSwap(H4, F6, I4, I5);\012	CompareAndSwap(H3, I4, J3, J4);\012\012	// Take median value\012	return static_cast<OutType>(J4);\012}\012\012/** @brief Computes a median filter\012@details Algorithm taken from the the following book:\012Knuth in The Art of Computer Programming, vol 3 (algorithm 5.2.2M)\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KERN_SIZE     The size of the kernel\012@param window        The sliding window of this scalar computation\012@return              The result of the median filter\012*/\012template <typename InType, typename OutType, const vx_uint16 KERN_SIZE>\012OutType ComputeMedian(InType window[KERN_SIZE][KERN_SIZE]) {\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Constants and variables\012	const vx_uint16 BUFFER_SIZE = KERN_SIZE * KERN_SIZE;\012	const vx_uint16 BUFFER_RAD = BUFFER_SIZE >> 1;\012	vx_uint16 START = 1;\012	vx_uint16 row_ptr = 0;\012	vx_uint16 SCALE = BUFFER_SIZE - 1;\012	vx_uint16 MSB = 0;\012\012	// Register stages for pipelining of the sorting\012	#ifdef Xilinx\012	InType buffer[BUFFER_SIZE + 1][BUFFER_SIZE];\012	#pragma HLS array_partition variable=buffer complete dim=0\012	#elif Intel\012	InType buffer[BUFFER_SIZE + 1][BUFFER_SIZE] hls_register;\012	#endif\012\012	// Pre-computation\012UNROLL_INTEL()\012	for (vx_uint16 i = 0; i < sizeof(vx_uint16) * 8; i++) {\012UNROLL_XILINX()\012		if ((SCALE & static_cast<vx_uint16>(1 << i)) != 0)\012			MSB = i;\012	}\012UNROLL_INTEL()\012	for (vx_uint16 i = 0; i < MSB; i++) {\012UNROLL_XILINX()\012		START *= 2;\012	}\012\012	// 2d to 1d input window conversion\012UNROLL_INTEL()\012	for (vx_uint16 i = 0, ptr = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint16 j = 0; j < KERN_SIZE; j++) {\012UNROLL_XILINX()\012			buffer[0][ptr] = window[i][j];\012			ptr++;\012		}\012	}\012\012	// Sort array using odd-even mergesort\012UNROLL_INTEL()\012	for (vx_uint16 p = START; p > 0; p >>= 1) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint16 q = START, r = 0, d = p; d > 0; d = q - p, q >>= 1, r = p) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012			for (vx_uint16 i = 0; i < BUFFER_SIZE; i++) {\012UNROLL_XILINX()\012				buffer[row_ptr + 1][i] = buffer[row_ptr][i];\012			}\012UNROLL_INTEL()\012			for (vx_uint16 i = 0; i < BUFFER_SIZE - d; i++) {\012UNROLL_XILINX()\012				if ((i & p) == r)\012					CompareAndSwap<InType>(buffer[row_ptr][i], buffer[row_ptr][i + d], buffer[row_ptr + 1][i], buffer[row_ptr + 1][i + d]);\012			}\012			row_ptr++;\012		}\012	}\012\012	// Take median value\012	return static_cast<OutType>(buffer[row_ptr][BUFFER_RAD]);\012}\012\012/** @brief Computes the x derivative (optimized for kernel symmetry)\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KernType      The kernel scalar data type\012@param KERN_SIZE     The size of the kernel\012@param kernel        The sobel/scharr kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the x derivative computation\012*/\012template <typename InType, typename OutType, typename KernType, const vx_uint16 KERN_SIZE>\012OutType ComputeDerivativeX(KernType kernel[KERN_SIZE][KERN_SIZE], InType window[KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Constants\012	const vx_uint16 KERN_RAD = KERN_SIZE >> 1;\012	const vx_uint16 KERN_RANGE = KERN_SIZE - 1;\012\012	// Compute the filter result\012	vx_int64 result = 0;\012\012UNROLL_INTEL()\012	for (vx_uint16 y = 0; y < KERN_RAD + 1; y++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint16 x = 0; x < KERN_RAD; x++) {\012UNROLL_XILINX()\012\012			// Constants\012			const vx_uint16 yn = y + KERN_RANGE - y * 2;\012			const vx_uint16 xn = x + KERN_RANGE - x * 2;\012\012			// Compute mul\012			vx_int64 mul = abs(static_cast<vx_int64>(kernel[y][x]));\012\012			// compute sum\012			vx_int64 sum;\012			if (y < KERN_RAD) {\012				sum = static_cast<vx_int64>(window[y][xn]) +\012					static_cast<vx_int64>(window[yn][xn]) -\012					static_cast<vx_int64>(window[y][x]) -\012					static_cast<vx_int64>(window[yn][x]);\012			} else {\012				sum = static_cast<vx_int64>(window[y][xn]) -\012					static_cast<vx_int64>(window[y][x]);\012			}\012\012			// Add to result\012			result += sum*mul;\012		}\012	}\012\012	// Normalize\012	const vx_uint64 rounding = static_cast<vx_uint64>(1) << (kernel_shift - 1);\012	const vx_uint64 norm = (result * kernel_mult + rounding) >> kernel_shift;\012\012	// Return result\012	return static_cast<OutType>(norm);\012}\012\012/** @brief Computes the y derivative (optimized for kernel symmetry)\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KernType      The kernel scalar data type\012@param KERN_SIZE     The size of the kernel\012@param kernel        The sobel/scharr kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the y derivative computation\012*/\012template <typename InType, typename OutType, typename KernType, const vx_uint16 KERN_SIZE>\012OutType ComputeDerivativeY(KernType kernel[KERN_SIZE][KERN_SIZE], InType window[KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Constants\012	const vx_uint16 KERN_RAD = KERN_SIZE >> 1;\012	const vx_uint16 KERN_RANGE = KERN_SIZE - 1;\012\012	// Compute the filter result\012	vx_int64 result = 0;\012\012UNROLL_INTEL()\012	for (vx_uint16 x = 0; x < KERN_RAD + 1; x++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint16 y = 0; y < KERN_RAD; y++) {\012UNROLL_XILINX()\012			// Constants\012			const vx_uint16 yn = y + KERN_RANGE - y * 2;\012			const vx_uint16 xn = x + KERN_RANGE - x * 2;\012\012			// Compute mul\012			vx_int64 mul = abs(static_cast<vx_int64>(kernel[y][x]));\012\012			// compute sum\012			vx_int64 sum;\012			if (x < KERN_RAD) {\012				sum = static_cast<vx_int64>(window[yn][x]) +\012					static_cast<vx_int64>(window[yn][xn]) -\012					static_cast<vx_int64>(window[y][x]) -\012					static_cast<vx_int64>(window[y][xn]);\012			} else {\012				sum = static_cast<vx_int64>(window[yn][x]) -\012					static_cast<vx_int64>(window[y][x]);\012			}\012\012			// Add to result\012			result += sum*mul;\012		}\012	}\012\012	// Normalize\012	const vx_uint64 rounding = static_cast<vx_uint64>(1) << (kernel_shift - 1);\012	const vx_uint64 norm = (result * kernel_mult + rounding) >> kernel_shift;\012\012	// Return result\012	return static_cast<OutType>(norm);\012}\012\012/*********************************************************************************************************************/\012/* Filter Main Function */\012/*********************************************************************************************************************/\012\012/** @brief Selects and computes a 1d horizontal filter\012@param ScalarType   Data type of the input/output image\012@param KernelType   Data type of the kernel\012@param KERN_SIZE    Filter kernel size\012@param WIN_COLS     Columns of the sliding window\012@param VEC_NUM      Vector size\012@param window       The sliding window\012@param kernel       The convolution kernels\012@param kernel_mult  Resulting pixels are 1. multiplied by this amount\012@param kernel_shift Resulting pixels are 2. shifted to the right by this amount\012@param kernel_type  The type of convolution\012@param output       The results (vector) (per clock cycle)\012*/\012template <typename ScalarType, typename KernelType, vx_uint16 KERN_SIZE, vx_uint16 WIN_COLS, vx_uint16 VEC_NUM>\012void ComputeFilterHorizontal(ScalarType window[WIN_COLS], KernelType kernel[KERN_SIZE],\012	const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type, ScalarType output[VEC_NUM]) {\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012\012UNROLL_INTEL()\012	for (vx_uint16 vecId = 0; vecId < VEC_NUM; vecId++) {\012UNROLL_XILINX()\012\012		// Window for single vector element\012		#ifdef Xilinx\012		ScalarType kernel_window[KERN_SIZE];\012		#pragma HLS array_partition variable=kernel_window complete dim=0\012		#elif Intel\012		ScalarType kernel_window[KERN_SIZE] hls_register;\012		#endif\012\012		// Get window for single vector element\012UNROLL_INTEL()\012		for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012			kernel_window[i] = window[i + vecId];\012		}\012\012		// Compute filter for single vector element\012		ScalarType result = 0;\012		switch (kernel_type) {\012		case HIFLIPVX::GAUSSIAN_FILTER:\012			result = ComputeGaussian1d<ScalarType, KernelType, KERN_SIZE>(kernel, kernel_window, kernel_mult, kernel_shift);\012			break;\012		case HIFLIPVX::BOX_FILTER:\012			result = ComputeBox1d<ScalarType, KERN_SIZE>(kernel_window, kernel_mult, kernel_shift);\012			break;\012		case HIFLIPVX::ERODE_IMAGE:\012			result = ComputeErode1d<ScalarType, KERN_SIZE>(kernel_window);\012			break;\012		case HIFLIPVX::DILATE_IMAGE:\012			result = ComputeDilate1d<ScalarType, KERN_SIZE>(kernel_window);\012			break;\012		default:\012			break;\012		}\012		output[vecId] = result;\012	}\012}\012\012/** @brief Selects and computes a 1d vertical filter\012@param ScalarType   Data type of the input/output image\012@param KernelType   Data type of the kernel\012@param KERN_SIZE    Filter kernel size\012@param VEC_NUM      Vector size\012@param window       The sliding window\012@param kernel       The convolution kernels\012@param kernel_mult  Resulting pixels are 1. multiplied by this amount\012@param kernel_shift Resulting pixels are 2. shifted to the right by this amount\012@param kernel_type  The type of convolution\012@param output       The results (vector) (per clock cycle)\012*/\012template <typename ScalarType, typename KernelType, vx_uint16 KERN_SIZE, vx_uint16 VEC_NUM>\012void ComputeFilterVertical(ScalarType window[KERN_SIZE][VEC_NUM], KernelType kernel[KERN_SIZE],\012	const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type, vx_image<ScalarType, VEC_NUM> &output) {\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Output array of the different filter (scalar)\012	vx_image<ScalarType, VEC_NUM> output_array;\012\012UNROLL_INTEL()\012	for (vx_uint16 vecId = 0; vecId < VEC_NUM; vecId++) {\012UNROLL_XILINX()\012\012		// Window for single vector element\012		#ifdef Xilinx\012		ScalarType kernel_window[KERN_SIZE];\012		#pragma HLS array_partition variable=kernel_window complete dim=0\012		#elif Intel\012		ScalarType kernel_window[KERN_SIZE] hls_register;\012		#endif\012\012		// Get window for single vector element\012UNROLL_INTEL()\012		for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012			kernel_window[i] = window[i][vecId];\012		}\012\012		// Compute filter for single vector element\012		ScalarType result = 0;\012		switch (kernel_type) {\012		case HIFLIPVX::GAUSSIAN_FILTER:\012			result = ComputeGaussian1d<ScalarType, KernelType, KERN_SIZE>(kernel, kernel_window, kernel_mult, kernel_shift);\012			break;\012		case HIFLIPVX::BOX_FILTER:\012			result = ComputeBox1d<ScalarType, KERN_SIZE>(kernel_window, kernel_mult, kernel_shift);\012			break;\012		case HIFLIPVX::ERODE_IMAGE:\012			result = ComputeErode1d<ScalarType, KERN_SIZE>(kernel_window);\012			break;\012		case HIFLIPVX::DILATE_IMAGE:\012			result = ComputeDilate1d<ScalarType, KERN_SIZE>(kernel_window);\012			break;\012		default:\012			break;\012		}\012		output_array.pixel[vecId] = result;\012	}\012\012	output = output_array;\012}\012\012\012/** @brief Computes a Non-Max suppression 3x3  filter\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KERN_SIZE     The size of the kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the box filter\012*/\012template <typename InType, typename OutType, const vx_uint16 KERN_SIZE>\012OutType ComputeNonMaxSuppression(InType window[KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Input pixel\012	InType A0 = window[0][0], A1 = window[0][1], A2 = window[0][2];\012	InType A3 = window[1][0], A4 = window[1][1], A5 = window[1][2];\012	InType A6 = window[2][0], A7 = window[2][1], A8 = window[2][2];\012\012       	bool O0=0;\012\012	if (A4 < A0) //p(x,y)>=p(x-1,y1)\012		O0 = 1; //suppress\012	if (A4 < A1)\012		O0 = 1; //suppress\012	if (A4 < A2)\012		O0 = 1; //suppress\012	if (A4 < A3)\012		O0 = 1; //suppress\012	if (A4 < A5)\012		O0 = 1; //suppress\012	if (A4 < A6)\012		O0 = 1; //suppress\012	if (A4 < A7)\012		O0 = 1; //suppress\012	if (A4 < A8)\012		O0 = 1; //suppress\012\012	if (O0) A4=0;	\012	/*Threashold.*/\012    if (A4>8) A4=127;\012	else A4=0;\012	return static_cast<OutType>(A4);\012}\012\012\012/** @brief Computes a Non-Max suppression 3x3  filter with pahse data\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KERN_SIZE     The size of the kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the box filter\012*/\012template <typename InType, typename OutType, const vx_uint16 KERN_SIZE>\012OutType ComputeNonMaxSuppressionPhase(InType window[KERN_SIZE][KERN_SIZE], \012		InType phase, const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Input pixel\012	InType A0 = window[0][0], A1 = window[0][1], A2 = window[0][2];\012	InType A3 = window[1][0], A4 = window[1][1], A5 = window[1][2];\012	InType A6 = window[2][0], A7 = window[2][1], A8 = window[2][2];\012\012       	bool O0=0;\012    //Negative diagnoal\012    if ( phase == 3 ){\012		if (A4 < A0) //p(x,y)>=p(x-1,y1)\012			O0 = 1; //suppress\012		if (A4 < A8)\012			O0 = 1; //suppress\012	}\012	//Horizontal\012    if ( phase == 1 ){\012		if (A4 < A3)\012			O0 = 1; //suppress\012		if (A4 < A5)\012			O0 = 1; //suppress\012	}\012	//Vertical\012    if ( phase == 0 ){\012		if (A4 < A7)\012			O0 = 1; //suppress\012		if (A4 < A1)\012			O0 = 1; //suppress\012	}\012	//Positive Diagonal\012    if ( phase == 2 ){\012		if (A4 < A2)\012			O0 = 1; //suppress\012		if (A4 < A6)\012			O0 = 1; //suppress\012	}\012\012	if (O0) A4=0;	\012	/*Threashold.*/\012    if (A4>8) A4=127;\012	else A4=0;\012	return static_cast<OutType>(A4);\012}\012\012\012/** @brief Computes a Census tranform 3x3  filter\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KERN_SIZE     The size of the kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the box filter\012*/\012template <typename InType, typename OutType, const vx_uint16 KERN_SIZE>\012OutType ComputeCensusTransform(InType window[KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Input pixel\012	InType A0 = window[0][0], A1 = window[0][1], A2 = window[0][2];\012	InType A3 = window[1][0], A4 = window[1][1], A5 = window[1][2];\012	InType A6 = window[2][0], A7 = window[2][1], A8 = window[2][2];\012    \012    OutType bin_value = 0x00;\012\012	if (A4 > A0) //p(x,y)>=p(x-1,y1)\012		bin_value |= 0x80;\012	if (A4 > A1)\012		bin_value |= 0x40;\012	if (A4 > A2)\012		bin_value |= 0x20;\012	if (A4 > A3)\012		bin_value |= 0x10;\012	if (A4 > A5)\012		bin_value |= 0x08;\012	if (A4 > A6)\012		bin_value |= 0x04;\012	if (A4 > A7)\012		bin_value |= 0x02;\012	if (A4 > A8)\012		bin_value |= 0x01;\012\012	return static_cast<OutType>(bin_value);\012}\012\012\012\012/** @brief Selects and computes a filter\012@param InType       Data type of the input image\012@param OutType      Data type of the output image\012@param KernType     Data type of the kernel\012@param VEC_NUM     Vector size\012@param KERN_NUM     Amount of filter kernel\012@param KERN_SIZE    Filter kernel size\012@param WIN_COLS     Columns of the sliding window\012@param window       The sliding window\012@param kernel       The convolution kernels\012@param kernel_mult  Resulting pixels are 1. multiplied by this amount\012@param kernel_shift Resulting pixels are 2. shifted to the right by this amount\012@param kernel_type  The type of convolution\012@param output       The results (vector) (per clock cycle)\012*/\012template <typename InType, typename OutType, typename KernType, vx_uint16 VEC_NUM, vx_uint16 KERN_NUM, vx_uint16 KERN_SIZE, vx_uint16 WIN_COLS>\012void ComputeFilter(InType window[KERN_SIZE][WIN_COLS], KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE],\012	const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM], vx_image_t<OutType, VEC_NUM> output[KERN_NUM]) {\012\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	vx_image_t<OutType, VEC_NUM> output_vector[KERN_NUM] hls_register;\012\012	// Compute KERN_NUM different filter with VEC_NUM elements per clock cycle\012UNROLL_INTEL()\012	for (vx_uint16 kernId = 0; kernId < KERN_NUM; kernId++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint16 vecId = 0; vecId < VEC_NUM; vecId++) {\012UNROLL_XILINX()\012\012			// Window for single vector element\012#ifdef Xilinx\012			InType kernel_window[KERN_SIZE][KERN_SIZE];\012			#pragma HLS array_partition variable=kernel_window complete dim=0\012#elif Intel\012			InType kernel_window[KERN_SIZE][KERN_SIZE] hls_register;\012#endif\012\012			// Get window for single vector element\012UNROLL_INTEL()\012			for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012				for (vx_uint16 j = 0; j < KERN_SIZE; j++) {\012UNROLL_XILINX()\012					kernel_window[i][j] = window[i][j + vecId];\012				}\012			}\012\012			// Check, if input or output is signed\012			bool isSigned = (numeric_limits<InType>::is_signed) || (numeric_limits<OutType>::is_signed);\012\012			// Compute filter for single vector element\012			OutType result = 0;\012			switch (kernel_type[kernId]) {\012			case HIFLIPVX::GAUSSIAN_FILTER:\012				result = ComputeGaussian2d<InType, OutType, KernType, KERN_SIZE>(kernel[kernId], kernel_window, kernel_mult, kernel_shift);\012				break;\012			case HIFLIPVX::DERIVATIVE_X:\012				result = ComputeDerivativeX<InType, OutType, KernType, KERN_SIZE>(kernel[kernId], kernel_window, kernel_mult, kernel_shift);\012				break;\012			case HIFLIPVX::DERIVATIVE_Y:\012				result = ComputeDerivativeY<InType, OutType, KernType, KERN_SIZE>(kernel[kernId], kernel_window, kernel_mult, kernel_shift);\012				break;\012			case HIFLIPVX::CUSTOM_CONVOLUTION:\012				if (isSigned)\012					result = ComputeConvolve2d<InType, vx_int64, OutType, KernType, KERN_SIZE>(kernel[kernId], kernel_window, kernel_mult, kernel_shift);\012				else\012					result = ComputeConvolve2d<InType, vx_uint64, OutType, KernType, KERN_SIZE>(kernel[kernId], kernel_window, kernel_mult, kernel_shift);\012				break;\012			case HIFLIPVX::BOX_FILTER:\012				result = ComputeBox2d<InType, OutType, KERN_SIZE>(kernel_window, kernel_mult, kernel_shift);\012				break;\012			case HIFLIPVX::MEDIAN_FILTER:\012				if (KERN_SIZE == 3)\012					result = ComputeMedian3x3<InType, OutType, KERN_SIZE>(kernel_window);\012				else\012					result = ComputeMedian<InType, OutType, KERN_SIZE>(kernel_window);\012				break;\012			case HIFLIPVX::NON_MAX_SUPPRESSION:\012				result = ComputeNonMaxSuppression<InType, OutType, KERN_SIZE>(kernel_window, kernel_mult, kernel_shift);\012				break;\012			case HIFLIPVX::CENSUS_TRANSFORM:\012				result = ComputeCensusTransform<InType, OutType, KERN_SIZE>(kernel_window, kernel_mult, kernel_shift);\012				break;\012			default:\012				break;\012			}\012\012			output_vector[kernId].pixel[vecId] = result;\012		}\012	}\012	if (KERN_NUM > 0)\012		output[0] = output_vector[0];\012	if (KERN_NUM > 1)\012		output[1] = output_vector[1];\012}\012\012/// 2/2 overload of compute filter\012/** @brief Selects and computes a filter\012@param InType       Data type of the input image\012@param OutType      Data type of the output image\012@param KernType     Data type of the kernel\012@param VEC_NUM     Vector size\012@param KERN_NUM     Amount of filter kernel\012@param KERN_SIZE    Filter kernel size\012@param WIN_COLS     Columns of the sliding window\012@param window       The sliding window\012@param kernel       The convolution kernels\012@param kernel_mult  Resulting pixels are 1. multiplied by this amount\012@param kernel_shift Resulting pixels are 2. shifted to the right by this amount\012@param kernel_type  The type of convolution\012@param output       The results (vector) (per clock cycle)\012*/\012template <typename InType, typename OutType, typename KernType, vx_uint16 VEC_NUM, vx_uint16 KERN_NUM, vx_uint16 KERN_SIZE, vx_uint16 WIN_COLS>\012void ComputeFilter(InType window[KERN_SIZE][WIN_COLS], InType data_input[VEC_NUM],\012	 KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE],\012	const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM], vx_image_t<OutType, VEC_NUM> output[KERN_NUM]) {\012\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	vx_image_t<OutType, VEC_NUM> output_vector[KERN_NUM] hls_register;\012\012	// Compute KERN_NUM different filter with VEC_NUM elements per clock cycle\012UNROLL_INTEL()\012	for (vx_uint16 kernId = 0; kernId < KERN_NUM; kernId++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint16 vecId = 0; vecId < VEC_NUM; vecId++) {\012UNROLL_XILINX()\012\012			// Window for single vector element\012#ifdef Xilinx\012			InType kernel_window[KERN_SIZE][KERN_SIZE];\012			#pragma HLS array_partition variable=kernel_window complete dim=0\012#elif Intel\012			InType kernel_window[KERN_SIZE][KERN_SIZE] hls_register;\012#endif\012\012			// Get window for single vector element\012UNROLL_INTEL()\012			for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012				for (vx_uint16 j = 0; j < KERN_SIZE; j++) {\012UNROLL_XILINX()\012					kernel_window[i][j] = window[i][j + vecId];\012				}\012			}\012\012			// Check, if input or output is signed\012			bool isSigned = (numeric_limits<InType>::is_signed) || (numeric_limits<OutType>::is_signed);\012\012			// Compute filter for single vector element\012			OutType result = 0;\012			switch (kernel_type[kernId]) {\012			case HIFLIPVX::NON_MAX_SUPPRESSION_PHASE4:\012				result = ComputeNonMaxSuppressionPhase<InType, OutType, \012					KERN_SIZE>(kernel_window, data_input[vecId], kernel_mult, kernel_shift);\012				break;\012			default:\012				break;\012			}\012			output_vector[kernId].pixel[vecId] = result;\012		}\012	}\012	if (KERN_NUM > 0)\012		output[0] = output_vector[0];\012	if (KERN_NUM > 1)\012		output[1] = output_vector[1];\012}\012\012\012/** @brief  Checks the input parameters of the convolution filter\012@param InType       Data type of the input image (8-bit, 16-bit, 32-bit)\012@param OutType      Data type of the output image (8-bit, 16-bit, 32-bit)\012@param VEC_NUM      Amount of pixels computed in parallel (1, 2, 4, 8)\012@param KERN_NUM     Amount of pixels computed in parallel (1, 2)\012@param IMG_COLS     Image width\012@param KERN_SIZE    Kernel size (3, 5, 7, 9, 11)\012*/\012template<typename InType, typename OutType, vx_uint16 VEC_NUM, vx_uint16 KERN_NUM, vx_uint16 IMG_COLS, vx_uint16 KERN_SIZE>\012void CheckFilterParameters() {\012\012	// Check function parameters/types\012	const vx_uint16 src_size = sizeof(InType);\012	const vx_uint16 dst_size = sizeof(OutType);\012	const bool allowed_kernel_size = (KERN_SIZE == 3) || (KERN_SIZE == 5) || (KERN_SIZE == 7) || (KERN_SIZE == 9) || (KERN_SIZE == 11);\012	const bool allowed_vector_size = (VEC_NUM == 1) || (VEC_NUM == 2) || (VEC_NUM == 4) || (VEC_NUM == 8);\012	const bool allowed_data_type = (src_size == 1) || (src_size == 2) || (src_size == 4);\012	const bool allowed_kernel_type = (src_size == 1) || (src_size == 2);\012	const bool allowed_kernel_num = (KERN_NUM == 1) || (KERN_NUM == 2);\012	STATIC_ASSERT(allowed_kernel_size, kernel_size_must_be_3_5_7_9_11);\012	STATIC_ASSERT((IMG_COLS % VEC_NUM == 0), image_colums_are_not_multiple_of_vector_size);\012	STATIC_ASSERT((src_size == dst_size), size_of_in_and_out_type_must_be_equal);\012	STATIC_ASSERT(allowed_vector_size, vector_size_must_be_1_2_4_8);\012	STATIC_ASSERT(allowed_data_type, data_type_must_be_8_16_32_bit);\012	STATIC_ASSERT(allowed_kernel_type, kernel_data_type_must_be_8_16_bit);\012	STATIC_ASSERT(allowed_kernel_num, kernel_num_can_only_be_1__or_2);\012}\012\012/*********************************************************************************************************************/\012/* Main Functions */\012/*********************************************************************************************************************/\012\012/** @brief  Computes multiple 1d convolution filter of kernel_type type\012@param ScalarType   Data type of the input/output image (8-bit, 16-bit, 32-bit)\012@param KernelType   Data type of the kernel (8-bit, 16-bit, 32-bit)\012@param BufferType   (sizeof(InType) * VEC_NUM * (KERN_SIZE - 1)) == (sizeof(BufferType) * BUFFER_NUM)\012@param BUFFER_NUM   (sizeof(InType) * VEC_NUM * (KERN_SIZE - 1)) == (sizeof(BufferType) * BUFFER_NUM)\012@param VEC_PIX      The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM      Amount of pixels computed in parallel (1, 2, 4, 8)\012@param KERN_NUM     Amount of pixels computed in parallel (1, 2)\012@param IMG_COLS     Image width\012@param IMG_ROWS     Image height\012@param KERN_SIZE    Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE  Type of border (Constant, Replicated or Undefined)\012@param input        Input image\012@param output       Output image\012@param kernel       The convolution kernel\012@param kernel_mult  Resulting pixels are 1. multiplied by this amount\012@param kernel_shift Resulting pixels are 2. shifted to the right by this amount\012@param kernel_type  The type of convolution\012*/\012template <typename ScalarType, typename KernelType, typename BufferType, vx_uint16 BUFFER_NUM, vx_uint32 VEC_PIX, vx_uint16 VEC_NUM, vx_uint16 IMG_COLS, vx_uint16 IMG_ROWS, vx_uint16 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0 = vx_stream_e, int stream_type1 = vx_stream_e>\012#ifdef Xilinx\012void ComputeFilter1dFunc(vx_image<ScalarType, VEC_NUM> input [VEC_PIX], vx_image<ScalarType, VEC_NUM> output [VEC_PIX], KernelType kernel[KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type) {\012#elif Intel\012void ComputeFilter1dFunc(vx_image<ScalarType, VEC_NUM, stream_type0>& input, vx_image<ScalarType, VEC_NUM, stream_type1>& output, KernelType kernel[KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type) {\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	// Constants\012	const vx_uint16 VEC_COLS = IMG_COLS / VEC_NUM;\012	const vx_uint16 KERN_RAD = KERN_SIZE >> 1;\012	const vx_uint16 WIN_COLS = 2 * KERN_RAD + VEC_NUM + (VEC_NUM - (KERN_RAD % VEC_NUM)) % VEC_NUM;\012	const vx_uint16 OHD_COLS = (WIN_COLS - KERN_RAD) / VEC_NUM - 1;\012	const vx_uint16 LINE_BUFFER_WIDTH = VEC_NUM*(KERN_SIZE - 1);\012\012	// Linebuffer\012	BufferType linebuffer[BUFFER_NUM][VEC_COLS];\012\012	// Sliding window for complete vector\012	#ifdef Xilinx\012	ScalarType window_hor[1][WIN_COLS];\012	#pragma HLS array_partition variable=window_hor complete dim=0\012	ScalarType window_ver[KERN_SIZE][VEC_NUM];\012	#pragma HLS array_partition variable=window_ver complete dim=0\012	#elif Intel\012	ScalarType window_hor[1][WIN_COLS]hls_register;\012	ScalarType window_ver[KERN_SIZE][VEC_NUM]hls_register;\012	#endif\012\012	vx_uint16 op_x1= (VEC_COLS) + OHD_COLS;	\012    vx_uint16 op_x2= ((op_x1 & 0xFF00) >> (8 - 1)) * 8 ; //msb x 2	\012    vx_uint8 lim_x1=  (op_x2 & 0xFF) + 1;\012	if (lim_x1 == 0)\012		lim_x1++;\012    vx_uint8 lim_x2=  op_x1 & 0xFF;\012\012	// Compute the filter (pipelined)\012	vx_uint32 ptr_src = 0, ptr_dst = 0;\012#pragma ii 1\012	for (vx_uint16 y = 0; y < IMG_ROWS + KERN_RAD; y++) {\012#pragma ivdep array(linebuffer)\012		for (vx_uint16 x = 0; x < VEC_COLS + OHD_COLS; x++) {\012		#ifdef Xilinx\012			// Variables (Registers)\012		ScalarType input_buffer[VEC_NUM];\012		#pragma HLS array_partition variable=input_buffer complete dim=0\012      		ScalarType buffer[KERN_SIZE][VEC_NUM];\012		#pragma HLS array_partition variable=buffer complete dim=0\012      		ScalarType internal_buffer[VEC_NUM];\012		#pragma HLS array_partition variable=internal_buffer complete dim=0\012		#elif Intel\012					ScalarType input_buffer[VEC_NUM] hls_register;\012      		ScalarType buffer[KERN_SIZE][VEC_NUM] hls_register;\012      		ScalarType internal_buffer[VEC_NUM] hls_register;\012		#endif\012			vx_image_t<ScalarType, VEC_NUM> input_data;\012			vx_image_t<ScalarType, VEC_NUM> output_data;\012\012			// Read input data from global memory\012			if ((y < IMG_ROWS) && (x < VEC_COLS)) {\012				#ifdef Xilinx\012				input_data = input[ptr_src];\012				#elif Intel\012				input_data = input.read();\012				#endif\012				ptr_src++;\012			}\012UNROLL_INTEL()\012			for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012UNROLL_XILINX()\012				input_buffer[v] = input_data.pixel[v];\012			}\012\012			// Compute Horizontal Filter including sliding window\012			SlidingWindowHorizontal<ScalarType, KERN_RAD, VEC_COLS, VEC_NUM, WIN_COLS, BORDER_TYPE>(input_buffer, window_hor, x);\012			ComputeFilterHorizontal<ScalarType, KernelType, KERN_SIZE, WIN_COLS, VEC_NUM>(window_hor[0], kernel, kernel_mult, kernel_shift, kernel_type, internal_buffer);\012\012			// Compute linebuffer\012			vx_int16 xs = x - OHD_COLS;\012			if (xs >= 0) {\012				ReadFromLineBuffer<ScalarType, BufferType, BUFFER_NUM, VEC_NUM, KERN_SIZE, VEC_COLS>(internal_buffer, linebuffer, buffer, xs);\012			}\012\012			// Compute Vertical Filter including sliding window\012			SlidingWindowVertical<ScalarType, IMG_ROWS, KERN_RAD, VEC_NUM, KERN_SIZE, BORDER_TYPE>(buffer, window_ver, y);\012\012			if (xs >= 0) {\012				WriteToLineBuffer<ScalarType, BufferType, BUFFER_NUM, VEC_NUM, KERN_SIZE, VEC_COLS>(buffer, linebuffer, xs);\012			}\012\012			ComputeFilterVertical<ScalarType, KernelType, KERN_SIZE, VEC_NUM>(window_ver, kernel, kernel_mult, kernel_shift, kernel_type, output_data);\012\012			// Write output data to global memory\012			if ((y >= KERN_RAD) && (x >= OHD_COLS)) {\012				#ifdef Xilinx\012				output[ptr_dst] = output_data;\012				#elif Intel\012				output.write(output_data);\012				#endif\012				ptr_dst++;\012			}\012		}\012	}\012}\012\012/** @brief  Computes multiple 1d convolution filter of kernel_type type\012@param ScalarType   Data type of the input/output image (8-bit, 16-bit, 32-bit)\012@param KernType     Data type of the kernel (8-bit, 16-bit, 32-bit)\012@param VEC_PIX      The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM      Amount of pixels computed in parallel (1, 2, 4, 8)\012@param IMG_COLS     Image width\012@param IMG_ROWS     Image height\012@param KERN_SIZE    Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE  Type of border (Constant, Replicated or Undefined)\012@param input        Input image\012@param output       Output image\012@param kernel       The convolution kernel\012@param kernel_mult  Resulting pixels are 1. multiplied by this amount\012@param kernel_shift Resulting pixels are 2. shifted to the right by this amount\012@param kernel_type  The type of convolution\012*/\012template <typename ScalarType, typename KernelType, vx_uint32 VEC_PIX, vx_uint16 VEC_NUM, vx_uint16 IMG_COLS, vx_uint16 IMG_ROWS, vx_uint16 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0 = vx_stream_e, int stream_type1 = vx_stream_e>\012#ifdef Xilinx\012void ComputeFilter1d(vx_image<ScalarType, VEC_NUM> input [(IMG_ROWS*IMG_COLS) / VEC_NUM], vx_image<ScalarType, VEC_NUM> *output, KernelType kernel[KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type) {\012#elif Intel\012void ComputeFilter1d(vx_image<ScalarType, VEC_NUM, stream_type0>& input, vx_image<ScalarType, VEC_NUM, stream_type1>& output, KernelType kernel[KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type) {\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012\012	// Check parameter input\012	CheckFilterParameters<ScalarType, ScalarType, VEC_NUM, 1, IMG_COLS, KERN_SIZE>();\012\012	// Constants to compute optimum buffer width\012	const vx_uint16 DATA_WIDTH = sizeof(ScalarType) * VEC_NUM * (KERN_SIZE - 1);\012	const vx_uint16 BUFFER_UINT32 = DATA_WIDTH % 4;\012	const vx_uint16 BUFFER_UINT16 = DATA_WIDTH % 2;\012	const vx_uint16 BUFFER_NUM = (BUFFER_UINT32 == 0) ? (DATA_WIDTH >> 2) : ((BUFFER_UINT16 == 0) ? (DATA_WIDTH >> 1) : (DATA_WIDTH));\012	const vx_uint16 BUFFER_WIDTH = (BUFFER_UINT32 == 0) ? (4) : ((BUFFER_UINT16 == 0) ? (2) : (1));\012\012	// Sets the Buffer Data type to the maximum possible, to reduce the amount of BRAM used\012	if (BUFFER_WIDTH == 4)\012		ComputeFilter1dFunc<ScalarType, KernelType, vx_uint32, BUFFER_NUM, VEC_PIX, VEC_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1>(input, output, kernel, kernel_mult, kernel_shift, kernel_type);\012	else if (BUFFER_WIDTH == 2)\012		ComputeFilter1dFunc<ScalarType, KernelType, vx_uint16, BUFFER_NUM, VEC_PIX, VEC_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1>(input, output, kernel, kernel_mult, kernel_shift, kernel_type);\012	else if (BUFFER_WIDTH == 1)\012		ComputeFilter1dFunc<ScalarType, KernelType, vx_uint8, BUFFER_NUM, VEC_PIX, VEC_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1>(input, output, kernel, kernel_mult, kernel_shift, kernel_type);\012}\012\012/** @brief  Computes multiple 2d convolution filter of kernel_type type\012@param InType       Data type of the input image (8-bit, 16-bit, 32-bit)\012@param OutType      Data type of the output image (8-bit, 16-bit, 32-bit)\012@param KernType     Data type of the kernel (8-bit, 16-bit, 32-bit)\012@param BufferType   (sizeof(InType) * VEC_NUM * (KERN_SIZE - 1)) == (sizeof(BufferType) * BUFFER_NUM)\012@param BUFFER_NUM   (sizeof(InType) * VEC_NUM * (KERN_SIZE - 1)) == (sizeof(BufferType) * BUFFER_NUM)\012@param VEC_PIX      The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM      Amount of pixels computed in parallel (1, 2, 4, 8)\012@param KERN_NUM     Amount of pixels computed in parallel (1, 2)\012@param IMG_COLS     Image width\012@param IMG_ROWS     Image height\012@param KERN_SIZE    Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE  Type of border (Constant, Replicated or Undefined)\012@param input        Input image\012@param output1      1. Output image\012@param output2      2. Output image\012@param kernel       The convolution kernel\012@param kernel_mult  Resulting pixels are 1. multiplied by this amount\012@param kernel_shift Resulting pixels are 2. shifted to the right by this amount\012@param kernel_type  The type of convolution\012*/\012template <typename InType, typename OutType, typename KernType, typename BufferType, vx_uint16 BUFFER_NUM, vx_uint32 VEC_PIX, vx_uint16 VEC_NUM, vx_uint16 KERN_NUM, vx_uint16 IMG_COLS, vx_uint16 IMG_ROWS, vx_uint16 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0 = vx_stream_e, int stream_type1 = vx_stream_e, int stream_type2 = vx_stream_e>\012#ifdef Xilinx\012void ComputeFilter2dFunc(vx_image<InType, VEC_NUM, stream_type0> input [VEC_PIX],\012			 vx_image<OutType, VEC_NUM, stream_type1> output1 [VEC_PIX],\012			 vx_image<OutType, VEC_NUM, stream_type2> output2 [VEC_PIX],\012	KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM]) {\012#elif Intel\012void ComputeFilter2dFunc(vx_image<InType, VEC_NUM, stream_type0>& input ,\012			 vx_image<OutType, VEC_NUM, stream_type1>& output1 ,\012			 vx_image<OutType, VEC_NUM, stream_type2>& output2 ,\012	KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM]) {\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	// Constants\012	const vx_uint16 VEC_COLS = IMG_COLS / VEC_NUM;\012	const vx_uint16 KERN_RAD = KERN_SIZE / 2;\012	const vx_uint16 WIN_COLS = 2 * KERN_RAD + VEC_NUM + (VEC_NUM - (KERN_RAD % VEC_NUM)) % VEC_NUM;\012	const vx_uint16 OHD_COLS = (WIN_COLS - KERN_RAD) / VEC_NUM - 1;\012	const vx_uint16 LINE_BUFFER_WIDTH = VEC_NUM*(KERN_SIZE - 1);\012\012	// Linebuffer\012	BufferType linebuffer[BUFFER_NUM][VEC_COLS];\012\012#ifdef Xilinx\012	// Sliding window for complete vector\012	InType window[KERN_SIZE][WIN_COLS];\012#pragma HLS array_partition variable=window complete dim=0\012#elif Intel\012	InType window[KERN_SIZE][WIN_COLS] hls_register;\012#endif\012	// Compute the filter (pipelined)\012	vx_uint32 ptr_src = 0, ptr_dst = 0;\012\012\012#pragma ii 1\012	for (vx_uint16 y = 0; y < IMG_ROWS + KERN_RAD; y++) {\012#pragma ivdep array(linebuffer)\012		for (vx_uint16 x = 0; x < VEC_COLS + OHD_COLS; x++) {\012\012#ifdef Xilinx\012			InType input_buffer[VEC_NUM];\012			#pragma HLS array_partition variable=input_buffer complete dim=0\012#elif Intel\012			InType input_buffer[VEC_NUM] hls_register;\012#endif\012\012#ifdef Xilinx\012			InType buffer[KERN_SIZE][VEC_NUM];\012			#pragma HLS array_partition variable=buffer complete dim=0\012#elif Intel\012			InType buffer[KERN_SIZE][VEC_NUM] hls_register;\012#endif\012\012			// Input & Output\012			vx_image_t<InType, VEC_NUM> input_data;\012			vx_image_t<OutType, VEC_NUM> output_data[KERN_NUM];\012\012			// Read input data from global memory\012			#ifdef Xilinx\012			if ((y < IMG_ROWS) && (x < VEC_COLS)) {\012				input_data = input[ptr_src];\012				ptr_src++;\012			}\012			#elif Intel\012			if ((y < IMG_ROWS) && (x < VEC_COLS)) {\012				input_data = input.read();\012				ptr_src++;\012			}\012			#endif\012UNROLL_INTEL()\012			for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012UNROLL_XILINX()\012				input_buffer[v] = input_data.pixel[v];\012			}\012\012			// Read data from line_buffer to buffer\012			ReadFromLineBuffer<InType, BufferType, BUFFER_NUM, VEC_NUM, KERN_SIZE, VEC_COLS>(input_buffer, linebuffer, buffer, x);\012\012			// Move sliding window with replicated/constant border\012			SlidingWindow<InType, VEC_NUM, IMG_ROWS, KERN_RAD, VEC_COLS, WIN_COLS, KERN_SIZE, BORDER_TYPE>(buffer, window, x, y);\012\012			// Write data from buffer to line_buffer\012			WriteToLineBuffer<InType, BufferType, BUFFER_NUM, VEC_NUM, KERN_SIZE, VEC_COLS>(buffer, linebuffer, x);\012\012			// Compute filter\012			ComputeFilter<InType, OutType, KernType, VEC_NUM, KERN_NUM, KERN_SIZE, WIN_COLS>(window, kernel, kernel_mult, kernel_shift, kernel_type, output_data);\012\012			// Write output data to global memory\012			if ((y >= KERN_RAD) && (x >= OHD_COLS)) {\012				if (KERN_NUM > 0)\012				#ifdef Xilinx\012					output1[ptr_dst] = output_data[0];\012				#elif Intel\012					output1.write(output_data[0]);\012				#endif\012				if (KERN_NUM > 1)\012				#ifdef Xilinx\012					output2[ptr_dst] = output_data[1];\012				#elif Intel\012					output2.write( output_data[1]);\012				#endif\012				ptr_dst++;\012			}\012		}\012	}\012}\012// 2/3 overload for Intel deves, null pointer is invalid operation, \012//\012template <typename InType, typename OutType, typename KernType, typename BufferType, vx_uint16 BUFFER_NUM, vx_uint32 VEC_PIX, vx_uint16 VEC_NUM, vx_uint16 KERN_NUM, vx_uint16 IMG_COLS, vx_uint16 IMG_ROWS, vx_uint16 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0 = vx_stream_e, int stream_type1 = vx_stream_e>\012#ifdef Xilinx\012void ComputeFilter2dFunc(vx_image<InType, VEC_NUM, stream_type0> input [VEC_PIX],\012			 vx_image<OutType, VEC_NUM, stream_type1> output1 [VEC_PIX],\012	KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM]) {\012#elif Intel\012void ComputeFilter2dFunc(vx_image<InType, VEC_NUM, stream_type0>& input ,\012			 vx_image<OutType, VEC_NUM, stream_type1>& output1 ,\012	KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM]) {\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	// Constants\012	const vx_uint16 VEC_COLS = IMG_COLS / VEC_NUM;\012	const vx_uint16 KERN_RAD = KERN_SIZE / 2;\012	const vx_uint16 WIN_COLS = 2 * KERN_RAD + VEC_NUM + (VEC_NUM - (KERN_RAD % VEC_NUM)) % VEC_NUM;\012	const vx_uint16 OHD_COLS = (WIN_COLS - KERN_RAD) / VEC_NUM - 1;\012	const vx_uint16 LINE_BUFFER_WIDTH = VEC_NUM*(KERN_SIZE - 1);\012\012	// Linebuffer\012	BufferType linebuffer[BUFFER_NUM][VEC_COLS];\012\012#ifdef Xilinx\012	// Sliding window for complete vector\012	InType window[KERN_SIZE][WIN_COLS];\012#pragma HLS array_partition variable=window complete dim=0\012#elif Intel\012	InType window[KERN_SIZE][WIN_COLS] hls_register;\012#endif\012	// Compute the filter (pipelined)\012	vx_uint32 ptr_src = 0, ptr_dst = 0;\012	\012\012#pragma ii 1\012	for (vx_uint16 y = 0; y < IMG_ROWS + KERN_RAD; y++) {\012#pragma ivdep array(linebuffer)\012		for (vx_uint16 x = 0; x < VEC_COLS + OHD_COLS; x++) {\012\012#ifdef Xilinx\012			InType input_buffer[VEC_NUM];\012			#pragma HLS array_partition variable=input_buffer complete dim=0\012#elif Intel\012			InType input_buffer[VEC_NUM] hls_register;\012#endif\012\012#ifdef Xilinx\012			InType buffer[KERN_SIZE][VEC_NUM];\012			#pragma HLS array_partition variable=buffer complete dim=0\012#elif Intel\012			InType buffer[KERN_SIZE][VEC_NUM] hls_register;\012#endif\012\012			// Input & Output\012			vx_image_t<InType, VEC_NUM> input_data;\012			vx_image_t<OutType, VEC_NUM> output_data[KERN_NUM];\012\012			// Read input data from global memory\012			#ifdef Xilinx\012			if ((y < IMG_ROWS) && (x < VEC_COLS)) {\012				input_data = input[ptr_src];\012				ptr_src++;\012			}\012			#elif Intel\012			if ((y < IMG_ROWS) && (x < VEC_COLS)) {\012				input_data = input.read();\012				ptr_src++;\012			}\012			#endif\012UNROLL_INTEL()\012			for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012UNROLL_XILINX()\012				input_buffer[v] = input_data.pixel[v];\012			}\012\012			// Read data from line_buffer to buffer\012			ReadFromLineBuffer<InType, BufferType, BUFFER_NUM, VEC_NUM, KERN_SIZE, VEC_COLS>(input_buffer, linebuffer, buffer, x);\012\012			// Move sliding window with replicated/constant border\012			SlidingWindow<InType, VEC_NUM, IMG_ROWS, KERN_RAD, VEC_COLS, WIN_COLS, KERN_SIZE, BORDER_TYPE>(buffer, window, x, y);\012\012			// Write data from buffer to line_buffer\012			WriteToLineBuffer<InType, BufferType, BUFFER_NUM, VEC_NUM, KERN_SIZE, VEC_COLS>(buffer, linebuffer, x);\012\012			// Compute filter\012			ComputeFilter<InType, OutType, KernType, VEC_NUM, KERN_NUM, KERN_SIZE, WIN_COLS>(window, kernel, kernel_mult, kernel_shift, kernel_type, output_data);\012\012			// Write output data to global memory\012			if ((y >= KERN_RAD) && (x >= OHD_COLS)) {\012				if (KERN_NUM > 0)\012				#ifdef Xilinx\012					output1[ptr_dst] = output_data[0];\012				#elif Intel\012					output1.write(output_data[0]);\012				#endif\012				ptr_dst++;\012			}\012		}\012	}\012}\012\012\012// 3/3 overload for two stream (phase canny) \012//\012template <typename InType, typename OutType, typename KernType, typename BufferType, vx_uint16 BUFFER_NUM, vx_uint32 VEC_PIX, vx_uint16 VEC_NUM, vx_uint16 KERN_NUM, vx_uint16 IMG_COLS, vx_uint16 IMG_ROWS, vx_uint16 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0 = vx_stream_e, int stream_type1 = vx_stream_e>\012#ifdef Xilinx\012void ComputeFilter2dInFunc(vx_image<InType, VEC_NUM, stream_type0> input [VEC_PIX],\012			 vx_image<InType, VEC_NUM, stream_type0> input1 [VEC_PIX],\012			 vx_image<OutType, VEC_NUM, stream_type1> output1 [VEC_PIX],\012	KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM]) {\012#elif Intel\012void ComputeFilter2dInFunc(vx_image<InType, VEC_NUM, stream_type0>& input ,\012			 vx_image<InType, VEC_NUM, stream_type0>& input1,\012			 vx_image<OutType, VEC_NUM, stream_type1>& output1 ,\012	KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM]) {\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	// Constants\012	const vx_uint16 VEC_COLS = IMG_COLS / VEC_NUM;\012	const vx_uint16 KERN_RAD = KERN_SIZE / 2;\012	const vx_uint16 WIN_COLS = 2 * KERN_RAD + VEC_NUM + (VEC_NUM - (KERN_RAD % VEC_NUM)) % VEC_NUM;\012	const vx_uint16 OHD_COLS = (WIN_COLS - KERN_RAD) / VEC_NUM - 1;\012	const vx_uint16 LINE_BUFFER_WIDTH = VEC_NUM*(KERN_SIZE - 1);\012\012	// Linebuffer\012	BufferType linebuffer[BUFFER_NUM][VEC_COLS];\012\012#ifdef Xilinx\012	// Sliding window for complete vector\012	InType window[KERN_SIZE][WIN_COLS];\012#pragma HLS array_partition variable=window complete dim=0\012#elif Intel\012	InType window[KERN_SIZE][WIN_COLS] hls_register;\012#endif\012	// Compute the filter (pipelined)\012	vx_uint32 ptr_src = 0, ptr_dst = 0;\012	\012\012#pragma ii 1\012	for (vx_uint16 y = 0; y < IMG_ROWS + KERN_RAD; y++) {\012#pragma ivdep array(linebuffer)\012		for (vx_uint16 x = 0; x < VEC_COLS + OHD_COLS; x++) {\012\012#ifdef Xilinx\012			InType input_buffer[VEC_NUM];\012			#pragma HLS array_partition variable=input_buffer complete dim=0\012			InType input_buffer1[VEC_NUM];\012			#pragma HLS array_partition variable=input_buffer complete dim=0\012#elif Intel\012			InType input_buffer[VEC_NUM] hls_register;\012			InType input_buffer1[VEC_NUM] hls_register;\012#endif\012\012#ifdef Xilinx\012			InType buffer[KERN_SIZE][VEC_NUM];\012#elif Intel\012			InType buffer[KERN_SIZE][VEC_NUM] hls_register;\012#endif\012\012			// Input & Output\012			vx_image_t<InType, VEC_NUM> input_data;\012			vx_image_t<InType, VEC_NUM> input_data1;\012			vx_image_t<OutType, VEC_NUM> output_data[KERN_NUM];\012\012			// Read input data from global memory\012			#ifdef Xilinx\012			if ((y < IMG_ROWS) && (x < VEC_COLS)) {\012				input_data = input[ptr_src];\012				input_data1= input1[pts_src]		\012				ptr_src++;\012			}\012			#elif Intel\012			if ((y < IMG_ROWS) && (x < VEC_COLS)) {\012				input_data = input.read();\012				input_data1 = input1.read();\012				ptr_src++;\012			}\012			#endif\012UNROLL_INTEL()\012			for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012UNROLL_XILINX()\012				input_buffer[v] = input_data.pixel[v];\012				input_buffer1[v] = input_data1.pixel[v];\012			}\012\012			// Read data from line_buffer to buffer\012			ReadFromLineBuffer<InType, BufferType, BUFFER_NUM, VEC_NUM, KERN_SIZE, VEC_COLS>(input_buffer, linebuffer, buffer, x);\012\012			// Move sliding window with replicated/constant border\012			SlidingWindow<InType, VEC_NUM, IMG_ROWS, KERN_RAD, VEC_COLS, WIN_COLS, KERN_SIZE, BORDER_TYPE>(buffer, window, x, y);\012\012			// Write data from buffer to line_buffer\012			WriteToLineBuffer<InType, BufferType, BUFFER_NUM, VEC_NUM, KERN_SIZE, VEC_COLS>(buffer, linebuffer, x);\012\012			// Compute filter\012			ComputeFilter<InType, OutType, KernType, VEC_NUM, KERN_NUM, KERN_SIZE, WIN_COLS>(window, input_buffer1, kernel, kernel_mult, kernel_shift, kernel_type, output_data);\012\012			// Write output data to global memory\012			if ((y >= KERN_RAD) && (x >= OHD_COLS)) {\012				if (KERN_NUM > 0)\012				#ifdef Xilinx\012					output1[ptr_dst] = output_data[0];\012				#elif Intel\012					output1.write(output_data[0]);\012				#endif\012				ptr_dst++;\012			}\012		}\012	}\012}\012/******************************************************************************/\012\012/** @brief  Computes multiple 2d convolution filter of kernel_type type\012@param InType       Data type of the input image (8-bit, 16-bit, 32-bit)\012@param OutType      Data type of the output image (8-bit, 16-bit, 32-bit)\012@param KernType     Data type of the kernel (8-bit, 16-bit, 32-bit)\012@param VEC_PIX      The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM      Amount of pixels computed in parallel (1, 2, 4, 8)\012@param KERN_NUM     Amount of pixels computed in parallel (1, 2)\012@param IMG_COLS     Image width\012@param IMG_ROWS     Image height\012@param KERN_SIZE    Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE  Type of border (Constant, Replicated or Undefined)\012@param input        Input image\012@param output1      1. Output image\012@param output2      2. Output image\012@param kernel       The convolution kernel\012@param kernel_mult  Resulting pixels are 1. multiplied by this amount\012@param kernel_shift Resulting pixels are 2. shifted to the right by this amount\012@param kernel_type  The type of convolution\012*/\012template <typename InType, typename OutType, typename KernType, vx_uint32 VEC_PIX, vx_uint16 VEC_NUM, vx_uint16 KERN_NUM, vx_uint16 IMG_COLS, vx_uint16 IMG_ROWS, vx_uint16 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0 = vx_stream_e, int stream_type1 = vx_stream_e, int stream_type2 = vx_stream_e>\012#ifdef Xilinx\012void ComputeFilter2d(vx_image<InType, VEC_NUM, stream_type0> input [VEC_PIX], vx_image<OutType, VEC_NUM,stream_type1> output1 [VEC_PIX], vx_image<OutType, VEC_NUM,stream_type2> output2 [VEC_PIX], KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM]) {\012#elif Intel\012void ComputeFilter2d(vx_image<InType, VEC_NUM, stream_type0>& input, vx_image<OutType, VEC_NUM,stream_type1>& output1 , vx_image<OutType, VEC_NUM,stream_type2>& output2 , KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM]) {\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	// Check parameter input\012	CheckFilterParameters<InType, OutType, VEC_NUM, KERN_NUM, IMG_COLS, KERN_SIZE>();\012\012	// Constants to compute optimum buffer width\012	const vx_uint16 DATA_WIDTH = sizeof(InType) * VEC_NUM * (KERN_SIZE - 1);\012	const vx_uint16 BUFFER_UINT32 = DATA_WIDTH % 4;\012	const vx_uint16 BUFFER_UINT16 = DATA_WIDTH % 2;\012	const vx_uint16 BUFFER_NUM = (BUFFER_UINT32 == 0) ? (DATA_WIDTH >> 2) : ((BUFFER_UINT16 == 0) ? (DATA_WIDTH >> 1) : (DATA_WIDTH));\012	const vx_uint16 BUFFER_WIDTH = (BUFFER_UINT32 == 0) ? (4) : ((BUFFER_UINT16 == 0) ? (2) : (1));\012\012      // Sets the Buffer Data type to the maximum possible, to reduce the amount of BRAM used\012	if (BUFFER_WIDTH == 4)\012			ComputeFilter2dFunc<InType, OutType, KernType, vx_uint32, BUFFER_NUM, VEC_PIX, VEC_NUM, KERN_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1,stream_type2>(input, output1, output2, kernel, kernel_mult, kernel_shift, kernel_type);\012		else if (BUFFER_WIDTH == 2)\012			ComputeFilter2dFunc<InType, OutType, KernType, vx_uint16, BUFFER_NUM, VEC_PIX, VEC_NUM, KERN_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE, stream_type0,stream_type1,stream_type2>(input, output1, output2, kernel, kernel_mult, kernel_shift, kernel_type);\012		else if (BUFFER_WIDTH == 1)\012			ComputeFilter2dFunc<InType, OutType, KernType, vx_uint8, BUFFER_NUM, VEC_PIX, VEC_NUM, KERN_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE,stream_type0,stream_type1,stream_type2>(input, output1, output2, kernel, kernel_mult, kernel_shift, kernel_type);\012}\012\012//Overload to generated less outputs, due null references are not valid (Intel needs references)\012template <typename InType, typename OutType, typename KernType, vx_uint32 VEC_PIX, vx_uint16 VEC_NUM, vx_uint16 KERN_NUM, vx_uint16 IMG_COLS, vx_uint16 IMG_ROWS, vx_uint16 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0 = vx_stream_e, int stream_type1 = vx_stream_e>\012#ifdef Xilinx\012void ComputeFilter2d(vx_image<InType, VEC_NUM, stream_type0> input [VEC_PIX], vx_image<OutType, VEC_NUM,stream_type1> output1 [VEC_PIX], KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM]) {\012#elif Intel\012void ComputeFilter2d(vx_image<InType, VEC_NUM, stream_type0>& input, vx_image<OutType, VEC_NUM,stream_type1>& output1, KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM]) {\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	// Check parameter input\012	CheckFilterParameters<InType, OutType, VEC_NUM, KERN_NUM, IMG_COLS, KERN_SIZE>();\012\012	// Constants to compute optimum buffer width\012	const vx_uint16 DATA_WIDTH = sizeof(InType) * VEC_NUM * (KERN_SIZE - 1);\012	const vx_uint16 BUFFER_UINT32 = DATA_WIDTH % 4;\012	const vx_uint16 BUFFER_UINT16 = DATA_WIDTH % 2;\012	const vx_uint16 BUFFER_NUM = (BUFFER_UINT32 == 0) ? (DATA_WIDTH >> 2) : ((BUFFER_UINT16 == 0) ? (DATA_WIDTH >> 1) : (DATA_WIDTH));\012	const vx_uint16 BUFFER_WIDTH = (BUFFER_UINT32 == 0) ? (4) : ((BUFFER_UINT16 == 0) ? (2) : (1));\012\012      // Sets the Buffer Data type to the maximum possible, to reduce the amount of BRAM used\012	if (BUFFER_WIDTH == 4)\012			ComputeFilter2dFunc<InType, OutType, KernType, vx_uint32, BUFFER_NUM, VEC_PIX, VEC_NUM, KERN_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1>(input, output1, kernel, kernel_mult, kernel_shift, kernel_type);\012		else if (BUFFER_WIDTH == 2)\012			ComputeFilter2dFunc<InType, OutType, KernType, vx_uint16, BUFFER_NUM, VEC_PIX, VEC_NUM, KERN_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE, stream_type0,stream_type1>(input, output1, kernel, kernel_mult, kernel_shift, kernel_type);\012		else if (BUFFER_WIDTH == 1)\012			ComputeFilter2dFunc<InType, OutType, KernType, vx_uint8, BUFFER_NUM, VEC_PIX, VEC_NUM, KERN_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE,stream_type0,stream_type1>(input, output1, kernel, kernel_mult, kernel_shift, kernel_type);\012}\012\012//overload to received 2 streams as input, as example phase from canny edge\012template <typename InType, typename OutType, typename KernType, vx_uint32 VEC_PIX, vx_uint16 VEC_NUM, vx_uint16 KERN_NUM, vx_uint16 IMG_COLS, vx_uint16 IMG_ROWS, vx_uint16 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0 = vx_stream_e, int stream_type1 = vx_stream_e>\012#ifdef Xilinx\012void ComputeFilter2dIn(vx_image<InType, VEC_NUM, stream_type0> input [VEC_PIX],vx_image<InType, VEC_NUM, stream_type0> input1 [VEC_PIX] ,vx_image<OutType, VEC_NUM,stream_type1> output1 [VEC_PIX], KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM]) {\012#elif Intel\012void ComputeFilter2dIn(vx_image<InType, VEC_NUM, stream_type0>& input, vx_image<InType, VEC_NUM, stream_type0>& input1,vx_image<OutType, VEC_NUM,stream_type1>& output1, KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM]) {\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	// Check parameter input\012	CheckFilterParameters<InType, OutType, VEC_NUM, KERN_NUM, IMG_COLS, KERN_SIZE>();\012\012	// Constants to compute optimum buffer width\012	const vx_uint16 DATA_WIDTH = sizeof(InType) * VEC_NUM * (KERN_SIZE - 1);\012	const vx_uint16 BUFFER_UINT32 = DATA_WIDTH % 4;\012	const vx_uint16 BUFFER_UINT16 = DATA_WIDTH % 2;\012	const vx_uint16 BUFFER_NUM = (BUFFER_UINT32 == 0) ? (DATA_WIDTH >> 2) : ((BUFFER_UINT16 == 0) ? (DATA_WIDTH >> 1) : (DATA_WIDTH));\012	const vx_uint16 BUFFER_WIDTH = (BUFFER_UINT32 == 0) ? (4) : ((BUFFER_UINT16 == 0) ? (2) : (1));\012\012      // Sets the Buffer Data type to the maximum possible, to reduce the amount of BRAM used\012	if (BUFFER_WIDTH == 4)\012			ComputeFilter2dInFunc<InType, OutType, KernType, vx_uint32, BUFFER_NUM, VEC_PIX, VEC_NUM, KERN_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1>(input, input1, output1, kernel, kernel_mult, kernel_shift, kernel_type);\012		else if (BUFFER_WIDTH == 2)\012			ComputeFilter2dInFunc<InType, OutType, KernType, vx_uint16, BUFFER_NUM, VEC_PIX, VEC_NUM, KERN_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE, stream_type0,stream_type1>(input, input1, output1, kernel, kernel_mult, kernel_shift, kernel_type);\012		else if (BUFFER_WIDTH == 1)\012			ComputeFilter2dInFunc<InType, OutType, KernType, vx_uint8, BUFFER_NUM, VEC_PIX, VEC_NUM, KERN_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE,stream_type0,stream_type1>(input, input1, output1, kernel, kernel_mult, kernel_shift, kernel_type);\012}\012\012/*********************************************************************************************************************/\012/* Filter Function Definition */\012/*********************************************************************************************************************/\012\012/** @brief  Computes a Box filter over a window of the input image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param SEPARABLE   Is true, if separable filter should be used\012@param input       Input image\012@param output      Output image\012*/\012template<typename ScalarType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, vx_bool SEPARABLE, int stream_type0 = vx_stream_e, int stream_type1 = vx_stream_e>\012#ifdef Xilinx\012void HwBox(vx_image<ScalarType, VEC_NUM> input [VEC_PIX], vx_image<ScalarType, VEC_NUM> output [VEC_PIX]) {\012#elif Intel\012void HwBox(vx_image<ScalarType, VEC_NUM, stream_type0>& input , vx_image<ScalarType, VEC_NUM, stream_type1>& output ) {\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	// Check function parameters/types\012	STATIC_ASSERT(numeric_limits<ScalarType>::is_signed == false, scalar_type_must_be_unsigned);\012\012	// Kernel Type\012	typedef vx_uint16 KernelType;\012\012	// Kernel Parameters\012	const vx_uint8 KERN_NUM = 1;\012	vx_uint64 kernel_mult = 1;\012	vx_uint32 kernel_shift = 0;\012\012	if (SEPARABLE == vx_false_e) {\012\012		// Function Input\012		#ifdef Xilinx\012		KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE];\012		#pragma HLS array_partition variable=kernel_vector complete dim=0\012		#elif Intel\012		KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE] hls_register;\012		#endif\012\012		// Compute kernel and normalization (Compile-Time)\012UNROLL_INTEL()\012		for (vx_uint8 y = 0; y < KERN_SIZE; y++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012			for (vx_uint8 x = 0; x < KERN_SIZE; x++) {\012UNROLL_XILINX()\012				kernel_vector[0][y][x] = 1;\012			}\012		}\012		ComputeNormalization2d<KernelType, KERN_SIZE>(kernel_vector[0], kernel_mult, kernel_shift);\012\012		// Kernel normalization and type\012		const HIFLIPVX::FilterOperation kernel_type[KERN_NUM] = { HIFLIPVX::BOX_FILTER };\012\012		// Compute Filter\012		ComputeFilter2d<ScalarType, ScalarType, KernelType, VEC_PIX, VEC_NUM, KERN_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1>(input, output, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012\012	} else {\012\012		// Function Input\012		#ifdef Xilinx\012		KernelType kernel_vector[KERN_SIZE];\012		#pragma HLS array_partition variable=kernel_vector complete dim=0\012		#elif Intel\012		KernelType kernel_vector[KERN_SIZE]hls_register;\012		#endif\012		// Compute kernel and normalization (Compile-Time)\012UNROLL_INTEL()\012		for (vx_uint8 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012			kernel_vector[i] = 1;\012		}\012		ComputeNormalization1d<KernelType, KERN_SIZE>(kernel_vector, kernel_mult, kernel_shift);\012\012		// Kernel normalization and type\012		const HIFLIPVX::FilterOperation kernel_type = HIFLIPVX::BOX_FILTER;\012\012		// Compute Filter\012		ComputeFilter1d<ScalarType, KernelType, VEC_PIX, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1>(input, output, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012	}\012}\012\012/** @brief  Convolves the input with the client supplied convolution matrix. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned, signed)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       Input image\012@param output      Output image\012@param conv        The custom convolution kernel\012*/\012template<typename ScalarType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0 = vx_stream_e, int stream_type1 = vx_stream_e>\012#ifdef Xilinx\012void HwConvolve(vx_image<ScalarType, VEC_NUM> input [VEC_PIX], vx_image<ScalarType, VEC_NUM> output [VEC_PIX], const ScalarType conv[KERN_SIZE][KERN_SIZE]) {\012#elif Intel\012void HwConvolve(vx_image<ScalarType, VEC_NUM, stream_type0>& input , vx_image<ScalarType, VEC_NUM, stream_type1>& output , const ScalarType conv[KERN_SIZE][KERN_SIZE]) {\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Kernel Parameters\012	const vx_uint8 KERN_NUM = 1;\012	vx_uint64 kernel_mult = 1;\012	vx_uint32 kernel_shift = 0;\012\012	// Function Input\012	#ifdef Xilinx\012	ScalarType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE];\012	#pragma HLS array_partition variable=kernel_vector complete dim=0\012	#elif Intel\012	ScalarType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE] hls_register;\012	#endif\012	// Compute kernel and normalization (Compile-Time)\012UNROLL_INTEL()\012	for (vx_uint8 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint8 j = 0; j < KERN_SIZE; j++) {\012UNROLL_XILINX()\012			kernel_vector[0][i][j] = conv[i][j];\012		}\012	}\012	ComputeNormalization2d<ScalarType, KERN_SIZE>(kernel_vector[0], kernel_mult, kernel_shift);\012\012	// Kernel normalization and type\012	const HIFLIPVX::FilterOperation kernel_type[KERN_NUM] = { HIFLIPVX::CUSTOM_CONVOLUTION };\012\012	// Compute Filter\012	ComputeFilter2d<ScalarType, ScalarType, ScalarType, VEC_PIX, VEC_NUM, KERN_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1>(input, output, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012}\012\012/** @brief  Implements Dilation, which grows the white space in a Boolean image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       Input image\012@param output      Output image\012*/\012template<typename ScalarType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0 = vx_stream_e, int stream_type1 = vx_stream_e>\012#ifdef Xilinx\012void HwDilate(vx_image<ScalarType, VEC_NUM> input [VEC_PIX], vx_image<ScalarType, VEC_NUM> output [VEC_PIX]) {\012#elif Intel\012void HwDilate(vx_image<ScalarType, VEC_NUM, stream_type0>& input , vx_image<ScalarType, VEC_NUM, stream_type1>& output ) {\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012\012	// Check function parameters/types\012	STATIC_ASSERT(numeric_limits<ScalarType>::is_signed == false, scalar_type_must_be_unsigned);\012\012	// Kernel Parameters\012	typedef vx_uint16 KernelType;\012\012	#ifdef Xilinx// Function Input\012	KernelType kernel_vector[KERN_SIZE];\012	#pragma HLS array_partition variable=kernel_vector complete dim=0\012	#elif Intel\012	KernelType kernel_vector[KERN_SIZE] hls_register;\012	#endif\012	// Kernel normalization and type\012	const vx_uint64 kernel_mult = 1;\012	const vx_uint32 kernel_shift = 0;\012	const HIFLIPVX::FilterOperation kernel_type = HIFLIPVX::DILATE_IMAGE;\012\012	// Compute Filter\012	ComputeFilter1d<ScalarType, KernelType, VEC_PIX, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1>(input, output, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012}\012\012/** @brief  Implements Erosion, which shrinks the white space in a Boolean image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       Input image\012@param output      Output image\012*/\012template<typename ScalarType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0 = vx_stream_e, int stream_type1 = vx_stream_e>\012#ifdef Xilinx\012void HwErode(vx_image<ScalarType, VEC_NUM> input[VEC_PIX], vx_image<ScalarType, VEC_NUM> output[VEC_PIX]) {\012#elif Intel\012void HwErode(vx_image<ScalarType, VEC_NUM, stream_type0>& input, vx_image<ScalarType, VEC_NUM, stream_type1>& output) {\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	// Check function parameters/types\012	STATIC_ASSERT(numeric_limits<ScalarType>::is_signed == false, scalar_type_must_be_unsigned);\012\012	// Kernel Parameters\012	typedef vx_uint16 KernelType;\012\012	// Function Input\012	#ifdef Xilinx\012	KernelType kernel_vector[KERN_SIZE];\012	#pragma HLS array_partition variable=kernel_vector complete dim=0\012        #elif Intel\012	KernelType kernel_vector[KERN_SIZE] hls_register;\012	#endif\012	// Kernel normalization and type\012	const vx_uint64 kernel_mult = 1;\012	const vx_uint32 kernel_shift = 0;\012	const HIFLIPVX::FilterOperation kernel_type = HIFLIPVX::ERODE_IMAGE;\012\012	// Compute Filter\012	ComputeFilter1d<ScalarType, KernelType, VEC_PIX, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1>(input, output, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012}\012\012/** @brief  Computes a Gaussian filter over a window of the input image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param SEPARABLE   Is true, if separable filter should be used\012@param input       Input image\012@param output      Output image\012*/\012template<typename ScalarType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, vx_bool SEPARABLE, int stream_type0 = vx_stream_e, int stream_type1 = vx_stream_e>\012#ifdef Xilinx\012void HwGaussian(vx_image<ScalarType, VEC_NUM> input [VEC_PIX], vx_image<ScalarType, VEC_NUM> output [VEC_PIX]) {\012#elif Intel\012void HwGaussian(vx_image<ScalarType, VEC_NUM, stream_type0>& input , vx_image<ScalarType, VEC_NUM, stream_type1>& output ) {\012 #endif\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Check function parameters/types\012	STATIC_ASSERT(numeric_limits<ScalarType>::is_signed == false, scalar_type_must_be_unsigned);\012\012	// Kernel Type\012	typedef vx_uint16 KernelType;\012\012	// Kernel Parameters\012	const vx_uint8 KERN_NUM = 1;\012	vx_uint64 kernel_mult = 1;\012	vx_uint32 kernel_shift = 0;\012\012	if (SEPARABLE == vx_false_e) {\012\012		// Function Input\012		#ifdef Xilinx\012		KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE];\012		#pragma HLS array_partition variable=kernel_vector complete dim=0\012	        #elif Intel\012		KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE] hls_register;\012		#endif\012		// Compute kernel and normalization (Compile-Time)\012		ComputeGaussianKernels<KernelType, KERN_SIZE>(kernel_vector[0]);\012		ComputeNormalization2d<KernelType, KERN_SIZE>(kernel_vector[0], kernel_mult, kernel_shift);\012\012		// Set normalization and type\012		const HIFLIPVX::FilterOperation kernel_type[KERN_NUM] = { HIFLIPVX::GAUSSIAN_FILTER };\012\012		// Compute Filter\012		ComputeFilter2d<ScalarType, ScalarType, KernelType, VEC_PIX, VEC_NUM, KERN_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1>(input, output, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012\012	} else {\012\012		// Function Input\012		#ifdef Xilinx\012		KernelType kernel_vector[KERN_SIZE][KERN_SIZE];\012		#pragma HLS array_partition variable=kernel_vector complete dim=0\012		#elif Intel\012		KernelType kernel_vector[KERN_SIZE][KERN_SIZE] hls_register;\012		#endif\012		// Compute kernel and normalization (Compile-Time)\012		ComputeGaussianKernels<KernelType, KERN_SIZE>(kernel_vector);\012		ComputeNormalization1d<KernelType, KERN_SIZE>(kernel_vector[0], kernel_mult, kernel_shift);\012\012		// Kernel normalization and type\012		const HIFLIPVX::FilterOperation kernel_type = HIFLIPVX::GAUSSIAN_FILTER;\012\012		// Compute Filter\012		ComputeFilter1d<ScalarType, KernelType, VEC_PIX, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, stream_type0, stream_type1>(input, output, kernel_vector[0], kernel_mult, kernel_shift, kernel_type);\012	}\012}\012\012/** @brief  Computes a median pixel value over a window of the input image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       Input image\012@param output      Output image\012*/\012template<typename ScalarType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE,int stream_type0 = vx_stream_e, int stream_type1 = vx_stream_e>\012#ifdef Xilinx\012void HwMedian(vx_image<ScalarType, VEC_NUM, stream_type0> input [VEC_PIX], vx_image<ScalarType, VEC_NUM,stream_type1> output [VEC_PIX]) {\012#elif Intel\012void HwMedian(vx_image<ScalarType, VEC_NUM, stream_type0>& input , vx_image<ScalarType, VEC_NUM, stream_type1>& output ) {\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Check function parameters/types\012	STATIC_ASSERT(numeric_limits<ScalarType>::is_signed == false, scalar_type_must_be_unsigned);\012\012	// Kernel Type\012	typedef vx_uint16 KernelType;\012\012	// Kernel Parameters\012	const vx_uint8 KERN_NUM = 1;\012	const vx_uint64 kernel_mult = 1;\012	const vx_uint32 kernel_shift = 0;\012\012	// Function Input\012	#ifdef Xilinx\012	KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE];\012	#pragma HLS array_partition variable=kernel_vector complete dim=0\012	#elif Intel\012	KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE]hls_register;\012	#endif\012\012	// Kernel normalization and type\012	const HIFLIPVX::FilterOperation kernel_type[KERN_NUM] = { HIFLIPVX::MEDIAN_FILTER };\012\012	// Compute Filter\012	ComputeFilter2d<ScalarType, ScalarType, KernelType, VEC_PIX, VEC_NUM, KERN_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE,stream_type0,stream_type1>(input, output, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012}\012\012/** @brief  Implements the Scharr Image Filter Kernel. The output images dimensions should be the same as the dimensions of the input image.\012@param SrcType     Data type of the input image (unsigned)(8-bit, 16-bit, 32-bit)\012@param DstType     Data type of the output image (signed)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       The input image\012@param output1     The output image (x derivative)\012@param output2     The output image (y derivative)\012*/\012template <typename InType, typename OutType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_border_e BORDER_TYPE, int stream_type0 = vx_stream_e, int stream_type1 = vx_stream_e, int stream_type2 = vx_stream_e>\012#ifdef Xilinx\012void HwScharr3x3(vx_image<InType, VEC_NUM, stream_type0> input [VEC_PIX], vx_image<OutType, VEC_NUM, stream_type1> output1 [VEC_PIX], vx_image<OutType, VEC_NUM, stream_type2> output2 [VEC_PIX]) {\012#elif Intel\012void HwScharr3x3(vx_image<InType, VEC_NUM, stream_type0>& input , vx_image<OutType, VEC_NUM, stream_type1>& output1 , vx_image<OutType, VEC_NUM, stream_type2>& output2 ) {\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Check function parameters/types\012	STATIC_ASSERT(numeric_limits<InType>::is_signed == false, derivative_input_must_be_unsigned);\012	STATIC_ASSERT(numeric_limits<OutType>::is_signed == true, derivative_output_must_be_signed);\012\012	// Kernel Type\012	typedef vx_int16 KernelType;\012\012	// Kernel Parameters\012	const vx_uint8 KERN_NUM = 2;\012	const vx_uint8 KERN_SIZE = 3;\012	const vx_uint64 kernel_mult = 1;\012	const vx_uint32 kernel_shift = 5;\012\012	// Function Input\012	#ifdef Xilinx\012	KernelType kernel_vector[2][KERN_SIZE][KERN_SIZE] = {\012		{\012			{ 3, 0, -3 },\012			{ 10, 0, -10 },\012			{ 3, 0, -3 },\012		}, {\012			{ 3, 10, 3 },\012			{ 0, 0, 0 },\012			{ -3, -10, -3 },\012		} };\012	#pragma HLS array_partition variable=kernel_vector complete dim=0\012	#elif Intel\012	KernelType kernel_vector[2][KERN_SIZE][KERN_SIZE] hls_register= {\012		{\012			{ 3, 0, -3 },\012			{ 10, 0, -10 },\012			{ 3, 0, -3 },\012		}, {\012			{ 3, 10, 3 },\012			{ 0, 0, 0 },\012			{ -3, -10, -3 },\012		} };\012	#endif\012	// Kernel normalization and type\012	const HIFLIPVX::FilterOperation kernel_type[KERN_NUM] = { HIFLIPVX::DERIVATIVE_X, HIFLIPVX::DERIVATIVE_Y };\012\012	// Compute Filter\012	ComputeFilter2d<InType, OutType, KernelType, VEC_PIX, VEC_NUM, KERN_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input, output1, output2, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012}\012\012/** @brief  Implements the Sobel Image Filter Kernel. The output images dimensions should be the same as the dimensions of the input image.\012@param SrcType     Data type of the input image (unsigned)(8-bit, 16-bit, 32-bit)\012@param DstType     Data type of the output image (signed)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param stream_type0 Intel hls stream type for input, ignored in Xilinx\012@param stream_type1 Intel hls stream type for output, ignored in Xilinx\012@param stream_type2 Intel hls stream type for output, ignored in Xilinx\012@param input       The input image\012@param output1     The output image (x derivative)\012@param output2     The output image (y derivative)\012*/\012template <typename InType, typename OutType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, int stream_type0 = vx_stream_e, int stream_type1 = vx_stream_e, int stream_type2 = vx_stream_e>\012#ifdef Xilinx\012void HwSobel(vx_image<InType, VEC_NUM, stream_type0>input [VEC_PIX],vx_image<OutType, VEC_NUM, stream_type1> output1 [VEC_PIX], vx_image<OutType, VEC_NUM, stream_type2> output2 [VEC_PIX]) {\012#elif Intel\012void HwSobel(vx_image<InType, VEC_NUM, stream_type0> &input, vx_image<OutType, VEC_NUM, stream_type1> &output1, vx_image<OutType, VEC_NUM, stream_type2> &output2 ) {\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012\012	// Check function parameters/types\012	STATIC_ASSERT(numeric_limits<InType>::is_signed == false, input_must_be_unsigned);\012	STATIC_ASSERT(numeric_limits<OutType>::is_signed == true, output_must_be_signed);\012\012	// Kernel Type\012	typedef vx_int16 KernelType;\012\012	// Kernel Amount\012	const vx_uint8 KERN_NUM = 2;\012\012	// Kernel Normalization\012	vx_uint64 kernel_mult = 1;\012	vx_uint32 kernel_shift = 0;\012\012	// Function Input\012	#ifdef Xilinx\012	KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE];\012	#pragma HLS array_partition variable=kernel_vector complete dim=0\012	#elif Intel\012	KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE] hls_register;\012	#endif\012\012	// Compute kernel and normalization (Compile-Time)\012	ComputeSobelKernels<KernelType, KERN_SIZE>(kernel_vector[0], kernel_vector[1]);\012	ComputeNormalization2d<KernelType, KERN_SIZE>(kernel_vector[0], kernel_mult, kernel_shift);\012\012	// Kernel normalization and type\012	const HIFLIPVX::FilterOperation kernel_type[KERN_NUM] = { HIFLIPVX::DERIVATIVE_X, HIFLIPVX::DERIVATIVE_Y };\012\012	// Compute Filter\012	ComputeFilter2d<InType, OutType, KernelType, VEC_PIX, VEC_NUM, KERN_NUM, WIDTH, HEIGHT, KERN_SIZE,\012					BORDER_TYPE,stream_type0,stream_type1,stream_type2>(input, output1, output2, kernel_vector,\012					kernel_mult, kernel_shift, kernel_type);\012}\012\012/** @brief  Implements the Non-Max Suppression Kernel. The output images Find local maxima in an image, or otherwise suppress pixels that are not local maxima. Image dimensions should be the same as the dimensions of the input image.\012@param SrcType     Data type of the input image (unsigned)(8-bit, 16-bit, 32-bit)\012@param DstType     Data type of the output image (signed)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param stream_type0 Intel hls stream type for input, ignored in Xilinx\012@param stream_type1 Intel hls stream type for output, ignored in Xilinx\012@param stream_type2 Intel hls stream type for output, ignored in Xilinx\012@param input       The input image\012@param output1     The output image (x derivative)\012@param output2     The output image (y derivative)\012*/\012template<typename ScalarType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE,typename vx_type0 = vx_image<ScalarType, VEC_NUM, vx_stream_e>, typename vx_type1 = vx_image<ScalarType, VEC_NUM, vx_stream_e> >\012#ifdef Xilinx\012void HwNonMaximaSuppression(vx_image<ScalarType, VEC_NUM> input [VEC_PIX], vx_image<ScalarType, VEC_NUM> output [VEC_PIX]) {\012#elif Intel\012void HwNonMaximaSuppression(vx_type0 &input, vx_type1 &output){\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Check function parameters/types\012//ToDo: find conditions \012//\012	// Kernel Type\012	typedef vx_uint16 KernelType;\012\012	// Kernel Parameters\012	const vx_uint8 KERN_NUM = 1;\012	const vx_uint64 kernel_mult = 1;\012	const vx_uint32 kernel_shift = 0;\012\012	// Function Input\012	#ifdef Xilinx\012	KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE];\012	#pragma HLS array_partition variable=kernel_vector complete dim=0\012	#elif Intel\012	KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE]hls_register;\012	#endif\012\012	// Kernel normalization and type\012	const HIFLIPVX::FilterOperation kernel_type[KERN_NUM] = { HIFLIPVX::NON_MAX_SUPPRESSION };\012\012	// Compute Filter\012	ComputeFilter2d<ScalarType, ScalarType, KernelType, \012		VEC_PIX, VEC_NUM, KERN_NUM, WIDTH, HEIGHT, KERN_SIZE,\012		BORDER_TYPE>(input, output, kernel_vector,\012		kernel_mult, kernel_shift, kernel_type);\012}\012//variation of nonMaxSuppression for canny edge detector, receive phase as input\012\012template<typename ScalarType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE,typename vx_type0 = vx_image<ScalarType, VEC_NUM, vx_stream_e>, typename vx_type1 = vx_image<ScalarType, VEC_NUM, vx_stream_e> >\012#ifdef Xilinx\012void HwNonMaximaSuppressionPhase4(vx_image<ScalarType, VEC_NUM> input [VEC_PIX], vx_image<ScalarType, VEC_NUM> phase[VEC_PIX],vx_image<ScalarType, VEC_NUM> output [VEC_PIX]) {\012#elif Intel\012void HwNonMaximaSuppressionPhase4(vx_type0 &input, vx_type0 &phase, vx_type1 &output){\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Check function parameters/types\012//ToDo: find conditions \012//\012	// Kernel Type\012	typedef vx_uint16 KernelType;\012\012	// Kernel Parameters\012	const vx_uint8 KERN_NUM = 1;\012	const vx_uint64 kernel_mult = 1;\012	const vx_uint32 kernel_shift = 0;\012\012	// Function Input\012	#ifdef Xilinx\012	KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE];\012	#pragma HLS array_partition variable=kernel_vector complete dim=0\012	#elif Intel\012	KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE]hls_register;\012	#endif\012\012	// Kernel normalization and type\012	const HIFLIPVX::FilterOperation kernel_type[KERN_NUM] = \012		{ HIFLIPVX::NON_MAX_SUPPRESSION_PHASE4 };\012\012	// Compute Filter\012	ComputeFilter2dIn<ScalarType, ScalarType, KernelType, \012		VEC_PIX, VEC_NUM, KERN_NUM, WIDTH, HEIGHT, KERN_SIZE,\012		BORDER_TYPE>(input, phase, output, kernel_vector,\012		kernel_mult, kernel_shift, kernel_type);\012}\012\012\012/** @brief  Implements the Non-Max Suppression Kernel. The output images Find local maxima in an image, or otherwise suppress pixels that are not local maxima. Image dimensions should be the same as the dimensions of the input image.\012@param SrcType     Data type of the input image (unsigned)(8-bit, 16-bit, 32-bit)\012@param DstType     Data type of the output image (signed)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param stream_type0 Intel hls stream type for input, ignored in Xilinx\012@param stream_type1 Intel hls stream type for output, ignored in Xilinx\012@param stream_type2 Intel hls stream type for output, ignored in Xilinx\012@param input       The input image\012@param output1     The output image (x derivative)\012@param output2     The output image (y derivative)\012*/\012template<typename InType, typename OutType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE,typename vx_type0 = vx_image<InType, VEC_NUM, vx_stream_e>, typename vx_type1 = vx_image<OutType, VEC_NUM, vx_stream_e> >\012#ifdef Xilinx\012void HwCensusTransform(vx_image<Intype, VEC_NUM> input [VEC_PIX], vx_image<outType, VEC_NUM> output [VEC_PIX]) {\012#elif Intel\012void HwCensusTransform(vx_type0 &input, vx_type1 &output){\012#endif\012#ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Check function parameters/types\012//ToDo: find conditions \012//\012	// Kernel Type\012	typedef vx_uint16 KernelType;\012\012	// Kernel Parameters\012	const vx_uint8 KERN_NUM = 1;\012	const vx_uint64 kernel_mult = 1;\012	const vx_uint32 kernel_shift = 0;\012\012	// Function Input\012	#ifdef Xilinx\012	KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE];\012	#pragma HLS array_partition variable=kernel_vector complete dim=0\012	#elif Intel\012	KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE]hls_register;\012	#endif\012\012	// Kernel normalization and type\012	const HIFLIPVX::FilterOperation kernel_type[KERN_NUM] = { HIFLIPVX::CENSUS_TRANSFORM };\012\012	// Compute Filter\012	ComputeFilter2d<InType, OutType, KernelType, \012		VEC_PIX, VEC_NUM, KERN_NUM, WIDTH, HEIGHT, KERN_SIZE,\012		BORDER_TYPE>(input, output, kernel_vector,\012		kernel_mult, kernel_shift, kernel_type);\012}\012\012#endif /* SRC_IMG_FILTER_CORE_H_ */\012"}, {"path":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/img_helper.h", "name":"img_helper.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/img_helper.h", "content":"/**\012* Licence: GNU GPLv3 \\n\012* You may copy, distribute and modify the software as long as you track\012* changes/dates in source files. Any modifications to or software\012* including (via compiler) GPL-licensed code must also be made available\012* under the GPL along with build & install instructions.\012*\012* @file    img_helper.h\012* @author  Lester Kalms <lester.kalms@tu-dresden.de>\012* @version 1.3\012* @brief Description:\\n\012*  These are helper functions needed by different functions (e.g. static assertion).\012* All own Enumerations, Typedefs, Macros and Namespaces are contained in this file.\012*\012* Update 01-2020\012* To support Intel FPGA Devices, some changes and macros are added\012* - The unrolling pragma was redifined due the compiliers uses in differents lines of for-loop\012* - Intel requires special types to communicate with function in the pipe and I/O\012*   	vx_image identifies with vx_streamIntel_e this three types\012*   	to be compatible con original syntax of OpenVX the default vaule is the pixel structure\012*\012*/\012\012#ifndef SRC_IMG_HELPER_H_\012#define SRC_IMG_HELPER_H_\012\012\012\012/*! \\brief set this to SDSoC, when using SDSoC */\012//#define SDSOC\012\012/*********************************************************************************************************************/\012/* All includes libraries are here */\012/*********************************************************************************************************************/\012\012#define _USE_MATH_DEFINES\012\012#include <stdlib.h>\012#include <stdint.h>\012#include <stdio.h>\012#include <limits>\012#include <iostream>\012#include <cmath>\012#include <algorithm>\012\012#include \"vx_types.h\"\012#include <vector>\012#ifdef __SDSCC__\012#include \"sds_lib.h\"\012#endif\012\012#ifdef Intel\012#include \"HLS/hls.h\"\012#include <type_traits>\012#endif\012\012\012\012/******************************************************************************/\012/* Global function */\012/******************************************************************************/\012\012/*! \\brief Needed as image type for vectorization\012@param TYPE The data type for the pixels\012@param SIZE The vectorization degree\012*/\012template<class TYPE, const size_t SIZE>\012struct vx_image_t {\012	TYPE pixel[SIZE];\012};\012\012/******************************************************************************/\012/* Update to support Intel FPGA devices*/\012/******************************************************************************/\012\012/*! \\brief Enumeration to support Intel Streammings\012*/\012enum vx_streamIntel_e {\012	vx_streamIn_e,  ///< Streaming input interface to the Intel component\012	vx_streamOut_e, ///< Streaming output interface to the Intel component\012	vx_stream_e, 		///< Streaming interface to the Intel component\012	vx_streamNull_e ///< defaut value for no-streamming\012};\012\012\012#ifdef Xilinx\012//In Xillinx the stream parameter is ignored\012template<class TYPE, const size_t SIZE, int stream_type = vx_streamNull_e>\012using vx_image= typename vx_image_t<TYPE, SIZE>::type;\012\012template<class TYPE, const size_t SIZE, int stream_type = vx_streamNull_e>\012using vx_distribution= typename vx_image_t<TYPE, SIZE>::type;\012#elif Intel\012template<bool B, class T, class F>\012struct conditional { typedef T type; }; ///< implementing data-type functionalitie\012\012template<class T, class F>\012struct conditional<false, T, F> { typedef F type; };\012\012/*! \\brief Intel SDK defines 3 stream access, if an embeded system need to use the lybrary\012		   the stream_in and stream_out are required,.\012		   If the streams its to communicated funtions, the defaul is stream.\012		   read more about streammings: Intel High Level Synthesis Compiler Pro Editio, Reference manual 19.4\012		   Default: vx_image\012@param  TYPE	 Data type\012@param  SIZE     Vector size\012@param  stream_type     type of stream\012@param  buff_capacity   size of the buffer streamming\012*/\012template<class TYPE, const size_t SIZE,int stream_type = vx_streamNull_e, uint buff_capacity=256>\012using vx_image= typename conditional<stream_type == vx_streamIn_e,\012									ihc::stream_in<vx_image_t<TYPE, SIZE>>,\012		typename conditional<stream_type==vx_streamOut_e, \012									ihc::stream_out<vx_image_t<TYPE,SIZE>>,\012		typename conditional<stream_type==vx_stream_e, \012									ihc::stream<vx_image_t<TYPE,SIZE>,ihc::buffer<buff_capacity>>,\012						 vx_image_t<TYPE,SIZE> >::type //default value\012						 >::type\012						 >::type;\012\012/*! \\brief Intel SDK defines 3 stream access, if an embeded system need to use the lybrary\012		   the stream_in and stream_out are required,.\012		   Default: vx_distribution\012@param  TYPE	 Data type\012@param  SIZE     Vector size\012@param  stream_type     type of stream\012@param  buff_capacity   size of the buffer streamming\012*/\012template<class TYPE, const size_t SIZE,int stream_type = vx_streamNull_e, uint buff_capacity=64>\012using vx_distribution= typename conditional<stream_type == vx_streamIn_e,\012									ihc::stream_in<TYPE>,\012		typename conditional<stream_type==vx_streamOut_e, \012									ihc::stream_out<TYPE>,\012		typename conditional<stream_type==vx_stream_e, \012									ihc::stream<TYPE,ihc::buffer<buff_capacity>>,\012						 TYPE >::type //default value\012						 >::type\012						 >::type;\012\012#endif\012\012//To redefine the pragmas used by each manufacturer using a macro.\012#ifdef Xilinx\012        #define UNROLL_XILINX() _Pragma(\"HLS unroll\")\012        #define UNROLL_INTEL()\012#elif Intel\012        #define UNROLL_INTEL() _Pragma(\"unroll\")\012        #define UNROLL_XILINX()\012		#define SIDE_FIFO_CAPACITY 32\012#endif\012\012/*! \\brief Creates an image object\012@param  ImageType The output image type (use \"struct vx_image<...>\" for vectorization of 2, 4 and 8)\012@param  PixelType The data type of the image pixels\012@param  COLS      The image columns\012@param  ROWS      The image rows\012@return           Pointer to the allocated memory\012*/\012template<typename ImageType, typename PixelType, vx_uint32 COLS, vx_uint32 ROWS, int VEC_NUM = 1>\012__inline ImageType *CreateImage() {\012\012#ifdef Xilinx\012#ifdef __SDSCC__\012	return (ImageType *)sds_alloc(sizeof(PixelType)*COLS*ROWS);\012#else\012	return (ImageType *)(new PixelType[COLS*ROWS]);\012#endif\012#elif Intel\012	return (ImageType *)(new PixelType[COLS*ROWS/VEC_NUM]);\012#endif\012}\012\012/*! \\brief Destroys an image object\012@param  ImageType The image type\012@param  image     The image\012*/\012template<typename ImageType>\012__inline void DestroyImage(ImageType *image) {\012#ifdef __SDSCC__\012	return sds_free(image);\012#else\012	return delete[] image;\012#endif\012}\012\012/*********************************************************************************************************************/\012/* Own Macros */\012/*********************************************************************************************************************/\012\012// Maximum and Minumum values of datatypes\012#define VX_INT8_MIN     static_cast<int8_t>(0-128)         /*!< \\brief Minimum of signed 8 bit type */\012#define VX_INT16_MIN    static_cast<int16_t>(0-32768)      /*!< \\brief Minimum of signed 16 bit type */\012#define VX_INT32_MIN    static_cast<int32_t>(0-2147483648) /*!< \\brief Minimum of signed 32 bit type */\012#define VX_INT8_MAX     static_cast<int8_t>(127)           /*!< \\brief Maximum of signed 8 bit type */\012#define VX_INT16_MAX    static_cast<int16_t>(32767)        /*!< \\brief Maximum of signed 16 bit type */\012#define VX_INT32_MAX    static_cast<int32_t>(2147483647)   /*!< \\brief Maximum of signed 32 bit type */\012#define VX_UINT8_MAX    static_cast<uint8_t>(0xff)         /*!< \\brief Maximum of unsigned 8 bit type */\012#define VX_UINT16_MAX   static_cast<uint16_t>(0xffff)      /*!< \\brief Maximum of unsigned 16 bit type */\012#define VX_UINT32_MAX   static_cast<uint32_t>(0xffffffff)  /*!< \\brief Maximum of unsigned 32 bit type */\012\012#ifndef M_PI\012#define M_PI 3.14159265358979323846 /*!< \\brief PI if not defined by cmath */\012#endif\012\012/*! \\brief Gets the datatype of an integer:\012* \\details The output is of type <tt>\\ref vx_type_e</tt> and is 8, 16, 32, 64 bit signed or unsigned\012*/\012#define GET_TYPE(TYPE) (const vx_type_e)( \\\012	(std::numeric_limits<TYPE>::is_integer == true) ? ( \\\012		(std::numeric_limits<TYPE>::is_signed == false) ? ( \\\012			(sizeof(TYPE) == 1) ? (VX_TYPE_UINT8) : ( \\\012				(sizeof(TYPE) == 2) ? (VX_TYPE_UINT16) : ( \\\012					(sizeof(TYPE) == 4) ? (VX_TYPE_UINT32) : ( \\\012						(sizeof(TYPE) == 8) ? (VX_TYPE_UINT64) : ( \\\012							VX_TYPE_INVALID))))) :  ( \\\012			(sizeof(TYPE) == 1) ? (VX_TYPE_INT8) : ( \\\012				(sizeof(TYPE) == 2) ? (VX_TYPE_INT16) : ( \\\012					(sizeof(TYPE) == 4) ? (VX_TYPE_INT32) : ( \\\012						(sizeof(TYPE) == 8) ? (VX_TYPE_INT64) : ( \\\012							VX_TYPE_INVALID)))))) : ( \\\012	VX_TYPE_INVALID) \\\012)\012\012#define VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM) (const vx_uint32) \\\012	((static_cast<vx_uint32>(HEIGHT)*static_cast<vx_uint32>(WIDTH)) / static_cast<vx_uint32>(VEC_NUM))\012\012/*********************************************************************************************************************/\012/* Own enums  */\012/*********************************************************************************************************************/\012\012/*! \\brief Contains the different pixelwise and filter operation types\012*/\012namespace HIFLIPVX {\012\012	/*! \\brief Perfroms a windowed filter function on an image\012	*/\012	enum FilterOperation {\012		GAUSSIAN_FILTER,     /*!< \\brief Gaussian filter (optimized for kernel structure) */\012		DERIVATIVE_X,        /*!< \\brief Scharr/Sobel derivative filter (optimized for kernel structure) */\012		DERIVATIVE_Y,        /*!< \\brief Scharr/Sobel derivative filter (optimized for kernel structure) */\012		CUSTOM_CONVOLUTION,  /*!< \\brief Costum convolution filter */\012		BOX_FILTER,          /*!< \\brief Box filter (optimized for kernel structure) */\012		MEDIAN_FILTER,       /*!< \\brief Median filter (optimized for kernel structure) */\012		ERODE_IMAGE,         /*!< \\brief Erode image filter (sperable kernel only) */\012		DILATE_IMAGE,        /*!< \\brief Dilate image filter (sperable kernel only) */\012		NON_MAX_SUPPRESSION,  /*!< \\brief Do Non-Maxima Suppression */\012		NON_MAX_SUPPRESSION_PHASE4,  /*!< \\brief Do Non-Maxima Suppression */\012        CENSUS_TRANSFORM 	 /*!< \\brief Census transform (optimized for kernel structure) */\012	};\012\012	/*! \\brief Performs an pixelwise operation on an image (same data type for input/output)\012	*/\012	enum PixelwiseOperationA {\012		COPY_DATA,    /*!< \\brief Copy a data object to another. */\012		BITWISE_NOT,  /*!< \\brief Performs a bitwise NOT operation on a input images. */\012		BITWISE_AND,  /*!< \\brief Performs a bitwise AND operation between two unsigned images. */\012		BITWISE_OR,   /*!< \\brief Performs a bitwise INCLUSIVE OR operation between two unsigned images. */\012		BITWISE_XOR,  /*!< \\brief Performs a bitwise EXCLUSIVE OR (XOR) operation between two unsigned images. */\012		MAX,          /*!< \\brief Implements a pixel-wise maximum kernel. */\012		MIN,          /*!< \\brief Implements a pixel-wise minimum kernel. */\012		ABSOLUTE_DIFFERENCE,   /*!< \\brief Computes the absolute difference between two images */\012		ARITHMETIC_ADDITION,   /*!< \\brief Performs addition between two images */\012		ARITHMETIC_SUBTRACTION, /*!< \\brief Performs subtraction between two images */\012		MAGNITUDE,               /*!< \\brief Implements the Gradient Magnitude Computation Kernel */\012		PHASE4,					/*!< \\brief Implements the Phase for 4 direction, avoiding arctan*/\012		MULTIPLY                 /*!< \\brief Performs element-wise multiplication between two images and a scalar value. */\012	};\012\012	/*! \\brief Performs an pixelwise operation on an image (vary data type for input/output)\012	*/\012	enum PixelwiseOperationB {\012		AC_IMAGE,    /*!< \\brief  Accumulates an input image into output image. */\012		AC_SQUARED,  /*!< \\brief  Accumulates a squared value from an input image to an output image. */\012		AC_WEIGHTED, /*!< \\brief  Accumulates a weighted value from an input image to an output image.  */\012		THRESHOLD    /*!< \\brief  Thresholds an input image and produces an output Boolean image. */\012	};\012}\012\012/*********************************************************************************************************************/\012/* Static Assertion (COMPILE TIME) */\012/*********************************************************************************************************************/\012\012// note that we wrap the non existing type inside a struct to avoid warning\012// messages about unused variables when static assertions are used at function\012// scope\012// the use of sizeof makes sure the assertion error is not ignored by SFINAE\012template <bool>\012struct StaticAssertion;\012template <>\012struct StaticAssertion<true>\012{\012}; // StaticAssertion<true>\012template<int i>\012struct StaticAssertionTest\012{\012}; // StaticAssertionTest<int>\012\012#define CONCATENATE(arg1, arg2)   CONCATENATE1(arg1, arg2)\012#define CONCATENATE1(arg1, arg2)  CONCATENATE2(arg1, arg2)\012#define CONCATENATE2(arg1, arg2)  arg1##arg2\012\012/*! \\brief Pre-C++11 Static Assertions Without Boost\012* \\details: from  http://stackoverflow.com/questions/1980012/boost-static-assert-without-boost/1980156\012*\012* <code>STATIC_ASSERT(expression, message)</code>\012*\012* When the static assertion test fails, a compiler error message that somehow\012* contains the \"STATIC_ASSERTION_FAILED_AT_LINE_xxx_message\" is generated.\012*\012* /!\\ message has to be a valid C++ identifier, that is to say it must not\012* contain space characters, cannot start with a digit, etc.\012*\012* STATIC_ASSERT(true, this_message_will_never_be_displayed);\012*/\012#define STATIC_ASSERT(expression, message)\\\012struct CONCATENATE(__static_assertion_at_line_, __LINE__)\\\012{\\\012	StaticAssertion<static_cast<bool>((expression))> CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _), message);\\\012};\\\012typedef StaticAssertionTest<sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))> CONCATENATE(__static_assertion_test_at_line_, __LINE__)\012\012/*********************************************************************************************************************/\012/* HW: Helper Functions for arithmetic computation  */\012/*********************************************************************************************************************/\012\012/*! \\brief Gets the maximum value of a certain data type\012@param Type  The data type that should be evaluated\012@return      The maximum value for \"Type\"\012*/\012template<typename Type>\012Type ComputeMax() {\012 #ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012	const vx_type_e MAX_TYPE = GET_TYPE(Type);\012	return\012		(MAX_TYPE == VX_TYPE_UINT8) ? (VX_UINT8_MAX) : (\012		(MAX_TYPE == VX_TYPE_UINT16) ? (VX_UINT16_MAX) : (\012			(MAX_TYPE == VX_TYPE_UINT32) ? (VX_UINT32_MAX) : (\012			(MAX_TYPE == VX_TYPE_INT8) ? (VX_INT8_MAX) : (\012				(MAX_TYPE == VX_TYPE_INT16) ? (VX_INT16_MAX) : (\012				(MAX_TYPE == VX_TYPE_INT32) ? (VX_INT32_MAX) : (\012					VX_TYPE_INVALID))))));\012}\012\012/*! \\brief Gets the minimum value of a certain data type\012@param Type  The data type that should be evaluated\012@return      The minimum value for \"Type\"\012*/\012template<typename Type>\012Type ComputeMin() {\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	const vx_type_e MIN_TYPE = GET_TYPE(Type);\012	return\012		(MIN_TYPE == VX_TYPE_UINT8) ? (0) : (\012		(MIN_TYPE == VX_TYPE_UINT16) ? (0) : (\012			(MIN_TYPE == VX_TYPE_UINT32) ? (0) : (\012			(MIN_TYPE == VX_TYPE_INT8) ? (VX_INT8_MIN) : (\012				(MIN_TYPE == VX_TYPE_INT16) ? (VX_INT16_MIN) : (\012				(MIN_TYPE == VX_TYPE_INT32) ? (VX_INT32_MIN) : (\012					VX_TYPE_INVALID))))));\012}\012\012/*! \\brief Saturates a function to a maximum and minimum value\012@param Type    The data type of the value\012@param data    The input value\012@param max_val The maximum value\012@param min_val The minimum value\012@return        The saturated value\012*/\012template<typename Type>\012Type SaturateMaxMin(Type data, Type max_val, Type min_val) {\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	if (data > max_val)\012		return max_val;\012	else if (data < min_val)\012		return min_val;\012	else\012		return data;\012}\012\012/*! \\brief An arithmetic right shift that simulates the behavior of division. For signed values there is a different behavior between shift and division when rounding.\012@param Type             The data type of the value\012@param SIGNED_DATA_TYPE If value is signed\012@param data             The input value\012@param shift            The shift value\012@return                 The result\012*/\012template<typename Type, bool SIGNED_DATA_TYPE>\012Type ShiftArithmeticRight(Type data, vx_uint16 shift) {\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	Type a = data >> shift;\012	if ((SIGNED_DATA_TYPE == true) && (a < 0)) {\012		a += 1;\012	}\012	return a;\012}\012\012/** @brief Computes square root: Rounding to floor or to nearest integer\012@param OutType		The data type of the output\012@param InType		The data type of the input\012@param ROUND_POLICY Rounding policy (to zero & nearest even)\012@param CHECK_MAX	Is true, if the maximum value should be checked (needed for rounding to nearest even)\012@param value		The input value\012@return				The square root of the input value\012*/\012template<typename OutType, typename InType, bool CHECK_MAX, vx_round_policy_e ROUND_POLICY>\012OutType SqrtLester(InType value) {\012#ifdef Xilinx\012#pragma HLS INLINE\012#endif\012	const OutType MAX_VAL = ComputeMax<OutType>();\012\012	// Number of stages (latency)\012	const vx_uint8 N = sizeof(OutType) * 8;\012\012	// Variables\012	OutType   A1 = 0;  // A^1 Intermediate result\012	InType A2 = 0;  // A^2 Square of the intermediate result\012\012	// Each stage computes 1 bit of the resulting vector\012	UNROLL_INTEL()\012	for (vx_uint8 n = N - 1; n < N; n--) {\012	UNROLL_XILINX()\012		// Add new bit of position n and compute (A1 + B1)^2\012		OutType B1 = static_cast<OutType>( 1) << (n);\012		InType  B2 = static_cast<InType >(B1) << (n);\012		InType  AB = static_cast<InType >(A1) << (n);\012		InType  A2_next = A2 + B2 + (AB << 1); // A*A + B*B + 2*A*B\012\012		// Store if tmp does not exceed value\012		if (A2_next <= value) {\012			A1 |= B1;\012			A2 = A2_next;\012		}\012	}\012\012	// Round to the nearest integer and check for overflow\012	if (ROUND_POLICY == VX_ROUND_POLICY_TO_NEAREST_EVEN) {\012		if (CHECK_MAX) {\012			if (((value - A2) > static_cast<InType>(A1)) && (A1 != MAX_VAL))\012				A1++;\012		} else {\012			if ((value - A2) > static_cast<InType>(A1))\012				A1++;\012		}\012	}\012\012	// Return result\012	return A1;\012}\012\012/*********************************************************************************************************************/\012/* HW: Helper Functions to Create Kernels (COMPILE TIME) */\012/*********************************************************************************************************************/\012\012/** @brief Computes the Gaussian Kernel using the Sigma values (not compile time in all SDx versions)\012@param ScalarType Data type of the kernel\012@param KERN_SIZE  The size of the kernel\012@param kernel     The computed gaussian kernel\012@param sigma      The input sigma value\012@return           The fraction size of the fixed-point result\012*/\012template <typename ScalarType, const vx_uint8 KERN_SIZE>\012const vx_uint16 ComputeGaussianKernelSigma(ScalarType kernel[KERN_SIZE][KERN_SIZE], const double sigma) {\012 #ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Constants\012	const vx_uint16 K_RAD = (vx_uint16)KERN_SIZE / (vx_uint16)2;\012	const double s = 2.0 * sigma * sigma;\012\012	// Variables\012	double sum = 0.0;\012	double doubleKernel[KERN_SIZE][KERN_SIZE];\012//#pragma HLS array_partition variable=doubleKernel complete dim=0\012\012	// Creates the gaussian kernel\012UNROLL_INTEL()\012	for (vx_uint8 x = 0; x < KERN_SIZE; x++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint8 y = 0; y < KERN_SIZE; y++) {\012UNROLL_XILINX()\012			const vx_uint32 a = static_cast<vx_uint32>((vx_uint16)x - K_RAD);\012			const vx_uint32 b = static_cast<vx_uint32>((vx_uint16)y - K_RAD);\012			const double c = static_cast<double>(a*a + b*b);\012			const double r = sqrt(c);\012			doubleKernel[x][y] = (exp(-(r*r) / s)) / (M_PI * s);\012			sum += doubleKernel[x][y];\012		}\012	}\012\012	// Normalizes the gaussian kernel\012UNROLL_INTEL()\012	for (vx_uint8 x = 0; x < KERN_SIZE; x++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint8 y = 0; y < KERN_SIZE; y++) {\012UNROLL_XILINX()\012			doubleKernel[x][y] /= sum;\012		}\012	}\012\012	// Computes the fraction for the fixed point representation\012	vx_int32 e_max = VX_INT32_MIN;\012UNROLL_INTEL()\012	for (vx_uint8 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint8 j = 0; j < KERN_SIZE; j++) {\012UNROLL_XILINX()\012			int e = 0;\012			frexp(doubleKernel[i][j], &e);\012			e_max = std::max(e_max, (vx_int32)e);\012		}\012	}\012	const vx_int32 fraction = 8 * sizeof(ScalarType) - e_max;\012	const vx_uint16 kernFraction = static_cast<vx_uint16>(std::min(std::max(fraction, (vx_int32)0), (vx_int32)31));\012\012	// Computes and stores the fixed point kernel\012	vx_uint32 shift = 1;\012UNROLL_INTEL()\012	for (vx_uint16 i = 0; i < kernFraction; i++) {\012UNROLL_XILINX()\012		shift *= 2;\012	}\012UNROLL_INTEL()\012	for (vx_uint8 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint8 j = 0; j < KERN_SIZE; j++) {\012UNROLL_XILINX()\012			kernel[i][j] = static_cast<ScalarType>(doubleKernel[i][j] * static_cast<double>(shift));\012		}\012	}\012\012	// Returns the fraction\012	return kernFraction;\012}\012\012/** @brief Convolute an array with the convolution array [1 2 1]\012@param ScalarType      Data type of the kernel\012@param KERN_SIZE       The size of the final kernel\012@param BUFFER_SIZE     The amount of kernels that can be stored in \"kernel_buffer\"\012@param kernel_buffer   Buffers input and output kernel\012@param cur_kernel_ptr  Pointer where the input kernel is stored\012@param cur_kernel_size The size of the input kernel\012*/\012template<typename ScalarType, vx_uint8 KERN_SIZE, vx_int16 BUFFER_SIZE>\012void ComputeConvolution(ScalarType kernel_buffer[BUFFER_SIZE][KERN_SIZE], const vx_int16 cur_kernel_ptr, const vx_int16 cur_kernel_size) {\012 #ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Constants\012	const vx_int16 kernel_size = cur_kernel_size + 2;\012	const vx_int16 kernel_rad = kernel_size >> 1;\012\012	// Standard convolution kernel\012	ScalarType convoltion[3] = { 1, 2, 1 };\012\012	// convolute kernel\012UNROLL_INTEL()\012	for (vx_int32 j = 0; j < kernel_size; j++) {\012UNROLL_XILINX()\012		const vx_int32 range = std::min((j < kernel_rad) ? (j + 1) : (kernel_size - j), (vx_int32)3);\012		const vx_int32 start_0 = std::max(2 - j, (vx_int32)0);\012		const vx_int32 start_1 = std::max(j - 2, (vx_int32)0);\012		ScalarType sum = 0;\012UNROLL_INTEL()\012		for (vx_int32 k = 0; k < range; k++) {\012UNROLL_XILINX()\012			sum += (convoltion[start_0 + k] * kernel_buffer[cur_kernel_ptr][start_1 + k]);\012		}\012		kernel_buffer[cur_kernel_ptr + 1][j] = sum;\012	}\012}\012\012/** @brief Computes 2d kernel from two 1d kernels\012@param ScalarType Data type of the kernel\012@param KERN_SIZE  The size of the kernel\012@param src1       The 1. 1d kernel\012@param src2       The 2. 1d kernel\012@param dst        The resulting 2d kernel\012*/\012template<typename ScalarType, vx_uint8 KERN_SIZE>\012void ComputeKernel(ScalarType src1[KERN_SIZE], ScalarType src2[KERN_SIZE], ScalarType dst[KERN_SIZE][KERN_SIZE]) {\012 #ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012UNROLL_INTEL()\012	for (vx_uint8 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint8 j = 0; j < KERN_SIZE; j++) {\012UNROLL_XILINX()\012			dst[i][j] = src1[i] * src2[j];\012		}\012	}\012}\012\012/** @brief Computes the 1d kernels for the sobel filter\012@param ScalarType Data type of the kernel\012@param KERN_SIZE  The size of the kernel\012@param sobel_x    Stores the sobel kernel in x-direction\012@param sobel_y    Stores the sobel kernel in y-direction\012*/\012template<typename ScalarType, vx_uint8 KERN_SIZE>\012void ComputeSobelKernels(ScalarType sobel_x[KERN_SIZE][KERN_SIZE], ScalarType sobel_y[KERN_SIZE][KERN_SIZE]) {\012 #ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Constants and variables\012	const vx_int16 ONE = static_cast<vx_int16>(1);\012	const vx_int16 THREE = static_cast<vx_int16>(3);\012	const vx_int16 BUFFER_SIZE = (((vx_int16)KERN_SIZE - THREE) >> ONE) + ONE;\012	vx_int16 buffer_ptr = 0;\012\012	// Sobel 1d kernel\012	ScalarType buffer_0[BUFFER_SIZE][KERN_SIZE];\012	buffer_0[0][0] = 1;\012	buffer_0[0][1] = 2;\012	buffer_0[0][2] = 1;\012	ScalarType buffer_1[BUFFER_SIZE][KERN_SIZE];\012	buffer_1[0][0] = -1;\012	buffer_1[0][1] = 0;\012	buffer_1[0][2] = 1;\012\012	// vx_uint8 kernel for higher kernel size\012UNROLL_INTEL()\012	for (vx_uint8 i = 3; i < KERN_SIZE; i += 2) {\012UNROLL_XILINX()\012		ComputeConvolution<ScalarType, KERN_SIZE, BUFFER_SIZE>(buffer_0, buffer_ptr, (vx_int16)i);\012		ComputeConvolution<ScalarType, KERN_SIZE, BUFFER_SIZE>(buffer_1, buffer_ptr, (vx_int16)i);\012		buffer_ptr++;\012	}\012\012	// Compute the 2d kernel\012	ComputeKernel<ScalarType, KERN_SIZE>(buffer_0[buffer_ptr], buffer_1[buffer_ptr], sobel_x);\012	ComputeKernel<ScalarType, KERN_SIZE>(buffer_1[buffer_ptr], buffer_0[buffer_ptr], sobel_y);\012}\012\012/** @brief Computes the Gaussian kernel\012@param ScalarType Data type of the kernel\012@param KERN_SIZE  The size of the kernel\012@param gaussian   Stores the gaussian kernel\012*/\012template<typename ScalarType, vx_uint8 KERN_SIZE>\012void ComputeGaussianKernels(ScalarType gaussian[KERN_SIZE][KERN_SIZE]) {\012 #ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	const vx_int16 ONE = static_cast<vx_int16>(1);\012	const vx_int16 THREE = static_cast<vx_int16>(3);\012\012	// Constants and variables\012	const vx_int16 BUFFER_SIZE = (((vx_int16)KERN_SIZE - THREE) >> ONE) + ONE;\012	vx_int16 buffer_ptr = 0;\012\012	// Gaussian 1d kernel\012	ScalarType buffer_0[BUFFER_SIZE][KERN_SIZE];\012	buffer_0[0][0] = 1;\012	buffer_0[0][1] = 2;\012	buffer_0[0][2] = 1;\012\012	// Computer Gaussian kernel with bigger kernel sizes\012UNROLL_INTEL()\012	for (vx_uint8 i = 3; i < KERN_SIZE; i += 2) {\012UNROLL_XILINX()\012		ComputeConvolution<ScalarType, KERN_SIZE, BUFFER_SIZE>(buffer_0, buffer_ptr, (vx_int16)i);\012		buffer_ptr++;\012	}\012\012	// Compute the 2d kernel from the 1d kernel\012	ComputeKernel<ScalarType, KERN_SIZE>(buffer_0[buffer_ptr], buffer_0[buffer_ptr], gaussian);\012}\012\012/** @brief Computes the normalization with given sum of kernel coefficients\012@param kernel_sum Sum of the kernel coefficients\012@param norm_mult  For normalization: multiply with this value\012@param norm_shift For normalization: shift the multiplied result with this value\012*/\012void ComputeNormalization(const vx_uint64 kernel_sum, vx_uint64 &norm_mult, vx_uint32 &norm_shift) {\012 #ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Constants\012	const vx_uint32 MAX_SHIFT = static_cast<vx_uint32>(48);\012	const vx_uint32 MIN_SHIFT = static_cast<vx_uint32>(15);\012	const vx_uint64 ONE = static_cast<vx_uint64>(1);\012	const vx_uint64 ZERO = static_cast<vx_uint64>(0);\012\012	// Variables\012	vx_uint16 new_shift = 0;\012	vx_uint16 new_mult = 1;\012	vx_uint32 old_shift = 0;\012	vx_uint64 old_mult = 1;\012	vx_uint64 norm_mult_a = 1;\012	vx_uint32 norm_shift_a = 0;\012	vx_uint64 norm_mult_b = 1;\012	vx_uint32 norm_shift_b = 0;\012	vx_uint64 temp = 0;\012	bool is_power_two = false;\012\012	// Compute Mult and Shift (Not Power of two)\012	old_mult = temp = (ONE << MAX_SHIFT) / kernel_sum;\012UNROLL_INTEL()\012	for (vx_uint32 i = 0; i < MAX_SHIFT; i++) {\012UNROLL_XILINX()\012		if (temp > ZERO) {\012			temp = temp >> static_cast<vx_uint32>(1);\012			old_shift = i;\012		}\012	}\012	if (old_shift > 16) {\012		new_shift = static_cast<vx_uint16>(MAX_SHIFT - (old_shift - MIN_SHIFT));\012		new_mult = static_cast<vx_uint16>(old_mult >> (old_shift - MIN_SHIFT));\012	} else {\012		new_shift = static_cast<vx_uint16>(MAX_SHIFT);\012		new_mult = static_cast<vx_uint16>(old_mult);\012	}\012	norm_mult_a = static_cast<vx_uint64>(new_mult);\012	norm_shift_a = static_cast<vx_uint32>(new_shift);\012\012	// Compute Mult and Shift (Power of two)\012UNROLL_INTEL()\012	for (vx_uint32 i = 0; i < sizeof(vx_uint32) * 8; i++) {\012UNROLL_XILINX()\012		if ((kernel_sum & (ONE << i)) != ZERO)\012			norm_shift_b = i;\012	}\012\012	// Check if scaling is by a power of two\012	is_power_two = (kernel_sum & (kernel_sum - ONE)) == ZERO;\012\012	// Compute Normalization and Multiplication\012	norm_mult = (is_power_two) ? (norm_mult_b) : (norm_mult_a);\012	norm_shift = (is_power_two) ? (norm_shift_b) : (norm_shift_a);\012}\012\012/** @brief Computes the normalization of a 2d kernel ((a * norm_mult) >> norm_shift)\012@param KernType   Data type of the kernel\012@param KERN_SIZE  The size of the kernel\012@param kernel     The kernel itself\012@param norm_mult  For normalization: multiply with this value\012@param norm_shift For normalization: shift the multiplied result with this value\012*/\012template <typename KernType, vx_uint8 KERN_SIZE>\012void ComputeNormalization2d(KernType kernel[KERN_SIZE][KERN_SIZE], vx_uint64 &norm_mult, vx_uint32 &norm_shift) {\012 #ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Variables\012	vx_uint64 kernel_sum = 0;\012\012	// Sum the kernel values\012UNROLL_INTEL()\012	for (vx_uint8 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012UNROLL_INTEL()\012		for (vx_uint8 j = 0; j < KERN_SIZE; j++) {\012UNROLL_XILINX()\012			kernel_sum += static_cast<vx_uint64>(std::abs(static_cast<vx_int64>(kernel[i][j])));\012		}\012	}\012\012	// Compute Normalization\012	ComputeNormalization(kernel_sum, norm_mult, norm_shift);\012}\012\012/** @brief Computes the normalization of a 1d kernel ((a * norm_mult) >> norm_shift)\012@param KernType   Data type of the kernel\012@param KERN_SIZE  The size of the kernel\012@param kernel     The kernel itself\012@param norm_mult  For normalization: multiply with this value\012@param norm_shift For normalization: shift the multiplied result with this value\012*/\012template <typename KernType, vx_uint8 KERN_SIZE>\012void ComputeNormalization1d(KernType kernel[KERN_SIZE], vx_uint64 &norm_mult, vx_uint32 &norm_shift) {\012 #ifdef Xilinx\012#pragma HLS INLINE\012 #endif\012\012	// Variables\012	vx_uint64 kernel_sum = 0;\012\012	// Sum the kernel values for normalization (pre-compile)\012UNROLL_INTEL()\012	for (vx_uint8 i = 0; i < KERN_SIZE; i++) {\012UNROLL_XILINX()\012		kernel_sum += static_cast<vx_uint64>(std::abs(static_cast<vx_int64>(kernel[i])));\012	}\012\012	// Compute Normalization\012	ComputeNormalization(kernel_sum, norm_mult, norm_shift);\012}\012\012#endif /* SRC_IMG_HELPER_H_ */\012"}, {"path":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/img_pixelop_base.h", "name":"img_pixelop_base.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/img_pixelop_base.h", "content":"/**\012* Licence: GNU GPLv3 \\n\012* You may copy, distribute and modify the software as long as you track\012* changes/dates in source files. Any modifications to or software\012* including (via compiler) GPL-licensed code must also be made available\012* under the GPL along with build & install instructions.\012*\012* @file    img_pixelop_base.h\012* @author  Lester Kalms <lester.kalms@tu-dresden.de>\012* @version 1.3\012* @brief Description:\\n\012*  These are all pixel operation functions (Call from here)\012*/\012\012#ifndef SRC_IMG_PIXELOP_BASE_H_\012#define SRC_IMG_PIXELOP_BASE_H_\012\012#include \"img_pixelop_core.h\"\012#ifdef Xilinx\012	#include \"img_pixelop_component_xilinx.h\"\012#endif\012/*********************************************************************************************************************/\012/* Pixelwise Operations (Same Data Type) */\012/*********************************************************************************************************************/\012\012/** @brief Copy data from an input data object into another data object. The input and output object must have the same object type and meta data.\012@param DataType        Data type of the image pixels\012@param VEC_SIZE        Amount of pixels computed in parallel\012@param IMG_PIXEL       Amount of pixels in the image\012@param input1          Input image\012@param output          Output image\012*/\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e>\012#ifdef Xilinx \012void ImgCopy(vx_image<DataType, VEC_SIZE> input1[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> output[IMG_PIXEL / VEC_SIZE]) {\012#elif Intel\012void ImgCopy(vx_image<DataType, VEC_SIZE, stream_type0> &input1 , vx_image<DataType, VEC_SIZE, stream_type1> &output) {\012#endif\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012	PixelwiseSameType<DataType, VEC_SIZE, IMG_PIXEL, HIFLIPVX::COPY_DATA, VX_CONVERT_POLICY_WRAP, VX_ROUND_POLICY_TO_ZERO, 0>(input1, input1, output);\012}\012\012\012/** @brief Performs a bitwise NOT operation on a input image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType      Data type of the image pixels\012@param VEC_SIZE        Amount of pixels computed in parallel\012@param IMG_PIXEL       Amount of pixels in the image\012@param input1          Input image\012@param output          Output image\012*/\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e>\012#ifdef Xilinx \012void ImgNot(vx_image<DataType, VEC_SIZE> input1[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> output[IMG_PIXEL / VEC_SIZE]) {\012#elif Intel\012void ImgNot(vx_image<DataType, VEC_SIZE, stream_type0> &input1 , vx_image<DataType, VEC_SIZE, stream_type1> &output) {\012#endif\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012	PixelwiseSameType<DataType, VEC_SIZE, IMG_PIXEL, HIFLIPVX::BITWISE_NOT, VX_CONVERT_POLICY_WRAP, VX_ROUND_POLICY_TO_ZERO, 0>(input1, input1, output);\012}\012\012\012/** @brief Performs a bitwise AND operation between two images.The output image dimensions should be the same as the dimensions of the input images.\012@param DataType      Data type of the image pixels\012@param VEC_SIZE        Amount of pixels computed in parallel\012@param IMG_PIXEL       Amount of pixels in the image\012@param input1          Input image\012@param input2          Input image\012@param output          Output image\012*/\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012#ifdef Xilinx \012void ImgAnd(vx_image<DataType, VEC_SIZE> input1[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> input2[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> output[IMG_PIXEL / VEC_SIZE]) {\012#elif Intel\012void ImgAnd(vx_image<DataType, VEC_SIZE, stream_type0> &input1 , vx_image<DataType, VEC_SIZE, stream_type1> &input2, vx_image<DataType, VEC_SIZE, stream_type2> &output) {\012#endif\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012	PixelwiseSameType<DataType, VEC_SIZE, IMG_PIXEL, HIFLIPVX::BITWISE_AND, VX_CONVERT_POLICY_WRAP, VX_ROUND_POLICY_TO_ZERO, 0>(input1, input2, output);\012}\012\012/** @brief Performs a bitwise INCLUSIVE OR operation between two images. The output image dimensions should be the same as the dimensions of the input images.\012@param DataType      Data type of the image pixels\012@param VEC_SIZE        Amount of pixels computed in parallel\012@param IMG_PIXEL       Amount of pixels in the image\012@param input1          Input image\012@param input2          Input image\012@param output          Output image\012*/\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012#ifdef Xilinx \012void ImgOr(vx_image<DataType, VEC_SIZE> input1[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> input2[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> output[IMG_PIXEL / VEC_SIZE]) {\012#elif Intel\012void ImgOr(vx_image<DataType, VEC_SIZE, stream_type0> &input1 , vx_image<DataType, VEC_SIZE, stream_type1> &input2, vx_image<DataType, VEC_SIZE, stream_type2> &output) {\012#endif\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012	PixelwiseSameType<DataType, VEC_SIZE, IMG_PIXEL, HIFLIPVX::BITWISE_OR, VX_CONVERT_POLICY_WRAP, VX_ROUND_POLICY_TO_ZERO, 0>(input1, input2, output);\012}\012\012/** @brief Performs a bitwise EXCLUSIVE OR (XOR) operation between two images. The output image dimensions should be the same as the dimensions of the input images.\012@param DataType      Data type of the image pixels\012@param VEC_SIZE        Amount of pixels computed in parallel\012@param IMG_PIXEL       Amount of pixels in the image\012@param input1          Input image\012@param input2          Input image\012@param output          Output image\012*/\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012#ifdef Xilinx \012void ImgXor(vx_image<DataType, VEC_SIZE> input1[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> input2[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> output[IMG_PIXEL / VEC_SIZE]) {\012#elif Intel\012void ImgXor(vx_image<DataType, VEC_SIZE, stream_type0> &input1 , vx_image<DataType, VEC_SIZE, stream_type1> &input2, vx_image<DataType, VEC_SIZE, stream_type2> &output) {\012#endif\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012	PixelwiseSameType<DataType, VEC_SIZE, IMG_PIXEL, HIFLIPVX::BITWISE_XOR, VX_CONVERT_POLICY_WRAP, VX_ROUND_POLICY_TO_ZERO, 0>(input1, input2, output);\012}\012\012/** @brief Implements a pixel-wise maximum kernel. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType      Data type of the image pixels\012@param VEC_SIZE        Amount of pixels computed in parallel\012@param IMG_PIXEL       Amount of pixels in the image\012@param input1          Input image\012@param input2          Input image\012@param output          Output image\012*/\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012#ifdef Xilinx \012void ImgMax(vx_image<DataType, VEC_SIZE> input1[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> input2[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> output[IMG_PIXEL / VEC_SIZE]) {\012#elif Intel\012void ImgMax(vx_image<DataType, VEC_SIZE, stream_type0> &input1 , vx_image<DataType, VEC_SIZE> &input2, vx_image<DataType, VEC_SIZE, stream_type2> &output) {\012#endif\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012	PixelwiseSameType<DataType, VEC_SIZE, IMG_PIXEL, HIFLIPVX::MAX, VX_CONVERT_POLICY_WRAP, VX_ROUND_POLICY_TO_ZERO, 0>(input1, input2, output);\012}\012\012/** @brief Implements a pixel-wise minimum kernel. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType      Data type of the image pixels\012@param VEC_SIZE        Amount of pixels computed in parallel\012@param IMG_PIXEL       Amount of pixels in the image\012@param input1          Input image\012@param input2          Input image\012@param output          Output image\012*/\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012#ifdef Xilinx \012void ImgMin(vx_image<DataType, VEC_SIZE> input1[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> input2[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> output[IMG_PIXEL / VEC_SIZE]) {\012#elif Intel\012void ImgMin(vx_image<DataType, VEC_SIZE, stream_type0> &input1 , vx_image<DataType, VEC_SIZE> &input2, vx_image<DataType, VEC_SIZE, stream_type2> &output) {\012#endif\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012	PixelwiseSameType<DataType, VEC_SIZE, IMG_PIXEL, HIFLIPVX::MIN, VX_CONVERT_POLICY_WRAP, VX_ROUND_POLICY_TO_ZERO, 0>(input1, input2, output);\012}\012\012/** @brief Computes the absolute difference between two images. The output image dimensions should be the same as the dimensions of the input images.\012@param DataType      Data type of the image pixels\012@param VEC_SIZE        Amount of pixels computed in parallel\012@param IMG_PIXEL       Amount of pixels in the image\012@param CONV_POLICY     The round conversion <tt>\\ref vx_convert_policy_e</tt>\012@param input1          Input image\012@param input2          Input image\012@param output          Output image\012*/\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, vx_convert_policy_e CONV_POLICY, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012#ifdef Xilinx \012void ImgAbsDiff(vx_image<DataType, VEC_SIZE> input1[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> input2[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> output[IMG_PIXEL / VEC_SIZE]) {\012#elif Intel\012void ImgAbsDiff(vx_image<DataType, VEC_SIZE, stream_type0> &input1 , vx_image<DataType, VEC_SIZE> &input2, vx_image<DataType, VEC_SIZE, stream_type2> &output) {\012#endif\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012	PixelwiseSameType<DataType, VEC_SIZE, IMG_PIXEL, HIFLIPVX::ABSOLUTE_DIFFERENCE, CONV_POLICY, VX_ROUND_POLICY_TO_ZERO, 0>(input1, input2, output);\012}\012\012/** @brief Performs addition between two images. The output image dimensions should be the same as the dimensions of the input images.\012@param DataType      Data type of the image pixels\012@param VEC_SIZE        Amount of pixels computed in parallel\012@param IMG_PIXEL       Amount of pixels in the image\012@param CONV_POLICY     The round conversion <tt>\\ref vx_convert_policy_e</tt>\012@param input1          Input image\012@param input2          Input image\012@param output          Output image\012*/\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, vx_convert_policy_e CONV_POLICY,int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012#ifdef Xilinx \012void ImgAdd(vx_image<DataType, VEC_SIZE> input1[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> input2[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> output[IMG_PIXEL / VEC_SIZE]) {\012#elif Intel\012void ImgAdd(vx_image<DataType, VEC_SIZE, stream_type0> &input1 , vx_image<DataType, VEC_SIZE> &input2, vx_image<DataType, VEC_SIZE, stream_type2> &output) {\012#endif\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012	PixelwiseSameType<DataType, VEC_SIZE, IMG_PIXEL, HIFLIPVX::ARITHMETIC_ADDITION, CONV_POLICY, VX_ROUND_POLICY_TO_ZERO, 0>(input1, input2, output);\012}\012\012\012/** @brief Performs subtraction between two images.The output image dimensions should be the same as the dimensions of the input images.\012@param DataType      Data type of the image pixels\012@param VEC_SIZE        Amount of pixels computed in parallel\012@param IMG_PIXEL       Amount of pixels in the image\012@param CONV_POLICY     The round conversion <tt>\\ref vx_convert_policy_e</tt>\012@param input1          Input image\012@param input2          Input image\012@param output          Output image\012*/\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, vx_convert_policy_e CONV_POLICY, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012#ifdef Xilinx \012void ImgSubtract(vx_image<DataType, VEC_SIZE> input1[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> input2[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> output[IMG_PIXEL / VEC_SIZE]) {\012#elif Intel\012void ImgSubtract(vx_image<DataType, VEC_SIZE, stream_type0> &input1 , vx_image<DataType, VEC_SIZE> &input2, vx_image<DataType, VEC_SIZE, stream_type2> &output) {\012#endif\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012	PixelwiseSameType<DataType, VEC_SIZE, IMG_PIXEL, HIFLIPVX::ARITHMETIC_SUBTRACTION, CONV_POLICY, VX_ROUND_POLICY_TO_ZERO, 0>(input1, input2, output);\012}\012\012/** @brief Implements the Gradient Magnitude Computation Kernel. The output image dimensions should be the same as the dimensions of the input images.\012@param DataType      Data type of the image pixels\012@param VEC_SIZE        Amount of pixels computed in parallel\012@param IMG_PIXEL       Amount of pixels in the image\012@param ROUND_POLICY    The round policy <tt>\\ref vx_round_policy_e</tt>\012@param input1          Input image\012@param input2          Input image\012@param output          Output image\012*/\012//template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, vx_round_policy_e ROUND_POLICY, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, vx_round_policy_e ROUND_POLICY,typename vx_type0, typename vx_type1, typename vx_type2>\012void ImgMagnitudeXilinx(vx_image<DataType, VEC_SIZE> input1[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> input2[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> output[IMG_PIXEL / VEC_SIZE]) {\012#ifdef Xilinx\012#pragma HLS INLINE \012#endif\012	PixelwiseSameType<DataType, VEC_SIZE, IMG_PIXEL, HIFLIPVX::MAGNITUDE, VX_CONVERT_POLICY_SATURATE, ROUND_POLICY, 0, vx_type0, vx_type1, vx_type2>(input1, input2, output);\012}\012\012/*@brief wrapper function for Intel FPGAs. stream arguments are valid only in template.\012 */\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, vx_round_policy_e ROUND_POLICY, \012typename vx_type0, typename vx_type1, typename vx_type2, \012vx_type0 &input0, vx_type1 &input1, vx_type2 &output2, \012int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012void ImgMagnitudeIntel(){\012	PixelwiseSameType<DataType, VEC_SIZE, IMG_PIXEL, HIFLIPVX::MAGNITUDE, VX_CONVERT_POLICY_SATURATE, ROUND_POLICY, 0, vx_type0, vx_type1, vx_type2>(input0, input1, output2);\012}\012\012/**@brief Wrapper class for Xilinx/Intel integration\012 * @see ImgMagnitud implementation\012 */\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, vx_round_policy_e ROUND_POLICY, \012         typename vx_type0, typename vx_type1, typename vx_type2, \012	 vx_type0 &input0, vx_type1 &input1, vx_type2 &output2,\012         int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012struct ImgMagnitude{\012	ImgMagnitude(){\012#ifdef Xilinx\012	ImgMagnitudeXilinx<DataType, VEC_NUM, IMG_PIXEL, ROUND_POLICY>(input0, input1, output2);\012#elif __INTELFPGA_COMPILER__\012	ihc::launch((ImgMagnitudeIntel<DataType, VEC_NUM, IMG_PIXEL, ROUND_POLICY, vx_type0, vx_type1, vx_type2, input0, input1, output2>));\012#endif\012	}\012     	void vxReleaseNode(){\012#ifdef Xilinx\012#elif __INTELFPGA_COMPILER__\012	ihc::collect((ImgMagnitudeIntel<DataType, VEC_NUM, IMG_PIXEL, ROUND_POLICY, vx_type0, vx_type1, vx_type2, input0, input1, output2>));\012#endif\012	}\012};\012\012\012/** @brief Implements the Phase Computation Kernel for 4 degreess. The output image dimensions should be the same as the dimensions of the input images.\012@param DataType      Data type of the image pixels\012@param VEC_SIZE        Amount of pixels computed in parallel\012@param IMG_PIXEL       Amount of pixels in the image\012@param ROUND_POLICY    The round policy <tt>\\ref vx_round_policy_e</tt>\012@param input1          Input image\012@param input2          Input image\012@param output          Output image\012*/\012//template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, vx_round_policy_e ROUND_POLICY, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, vx_round_policy_e ROUND_POLICY,typename vx_type0, typename vx_type1, typename vx_type2>\012void ImgPhase4Xilinx(vx_image<DataType, VEC_SIZE> input1[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> input2[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> output[IMG_PIXEL / VEC_SIZE]) {\012#ifdef Xilinx\012#pragma HLS INLINE \012#endif\012	PixelwiseSameType<DataType, VEC_SIZE, IMG_PIXEL, HIFLIPVX::PHASE4, VX_CONVERT_POLICY_SATURATE, ROUND_POLICY, 0, vx_type0, vx_type1, vx_type2>(input1, input2, output);\012}\012\012/*@brief wrapper function for Intel FPGAs. stream arguments are valid only in template.\012 */\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, vx_round_policy_e ROUND_POLICY, \012typename vx_type0, typename vx_type1, typename vx_type2, \012vx_type0 &input0, vx_type1 &input1, vx_type2 &output2, \012int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012void ImgPhase4Intel(){\012	PixelwiseSameType<DataType, VEC_SIZE, IMG_PIXEL, HIFLIPVX::PHASE4, VX_CONVERT_POLICY_SATURATE, ROUND_POLICY, 0, vx_type0, vx_type1, vx_type2>(input0, input1, output2);\012}\012\012/**@brief Wrapper class for Xilinx/Intel integration\012 * @see ImgPhase4 implementation\012 */\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, vx_round_policy_e ROUND_POLICY, \012         typename vx_type0, typename vx_type1, typename vx_type2, \012	 vx_type0 &input0, vx_type1 &input1, vx_type2 &output2,\012         int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012struct ImgPhase4{\012	ImgPhase4(){\012#ifdef Xilinx\012	ImgPhase4Xilinx<DataType, VEC_NUM, IMG_PIXEL, ROUND_POLICY>(input0, input1, output2);\012#elif __INTELFPGA_COMPILER__\012	ihc::launch((ImgPhase4Intel<DataType, VEC_NUM, IMG_PIXEL, ROUND_POLICY, vx_type0, vx_type1, vx_type2, input0, input1, output2>));\012#endif\012	}\012     	void vxReleaseNode(){\012#ifdef Xilinx\012#elif __INTELFPGA_COMPILER__\012	ihc::collect((ImgPhase4Intel<DataType, VEC_NUM, IMG_PIXEL, ROUND_POLICY, vx_type0, vx_type1, vx_type2, input0, input1, output2>));\012#endif\012	}\012};\012\012\012/** @brief Performs element-wise multiplication between two images and a scalar value. The output image dimensions should be the same as the dimensions of the input images.\012@param DataType      Data type of the image pixels\012@param VEC_SIZE        Amount of pixels computed in parallel\012@param IMG_PIXEL       Amount of pixels in the image\012@param CONV_POLICY     The round conversion <tt>\\ref vx_convert_policy_e</tt>\012@param ROUND_POLICY    The round policy <tt>\\ref vx_round_policy_e</tt>\012@param SCALE           A number multiplied to each product before overflow handling.\012@param input1          Input image\012@param input2          Input image\012@param output          Output image\012*/\012\012template<typename DataType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, vx_convert_policy_e CONV_POLICY, vx_round_policy_e ROUND_POLICY, vx_uint32 SCALE, int stream_type0= vx_stream_e, int stream_type1= vx_stream_e, int stream_type2= vx_stream_e>\012#ifdef Xilinx \012void ImgMultiply(vx_image<DataType, VEC_SIZE> input1[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> input2[IMG_PIXEL / VEC_SIZE], vx_image<DataType, VEC_SIZE> output[IMG_PIXEL / VEC_SIZE]) {\012#elif Intel\012void ImgMultiply(vx_image<DataType, VEC_SIZE, stream_type0> &input1 , vx_image<DataType, VEC_SIZE> &input2, vx_image<DataType, VEC_SIZE, stream_type2> &output) {\012#endif\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012	PixelwiseSameType<DataType, VEC_SIZE, IMG_PIXEL, HIFLIPVX::MULTIPLY, CONV_POLICY, ROUND_POLICY, SCALE>(input1, input2, output);\012}\012\012#endif /* SRC_IMG_PIXELOP_BASE_H_ */\012"}, {"path":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/img_pixelop_core.h", "name":"img_pixelop_core.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/img_pixelop_core.h", "content":"/**\012* Licence: GNU GPLv3 \\n\012* You may copy, distribute and modify the software as long as you track\012* changes/dates in source files. Any modifications to or software\012* including (via compiler) GPL-licensed code must also be made available\012* under the GPL along with build & install instructions.\012*\012* @file    img_pixelop_core.h\012* @author  Lester Kalms <lester.kalms@tu-dresden.de>\012* @version 1.3\012* @brief Description:\\n\012*  These are all core functions needed for the pixel operation functions (Do not call functions from here)\012*/\012\012#ifndef SRC_IMG_PIXELOP_CORE_H_\012#define SRC_IMG_PIXELOP_CORE_H_\012\012#include \"img_helper.h\"\012#ifdef Intel \012#include \"HLS/math.h\"  \012//#include \"HLS/hls_float.h\"\012#endif\012/******************************************************************************/\012/* Compute Magnitude */\012/******************************************************************************/\012\012/*! \\brief Compute Magnitude of one pixel (signed) \012    \\details Tested for 8, 16 and 32 bit | exact OpenVX results\012@param ScalarInt       Data type of the image pixels\012@param ScalarUint      Data type of the image pixels\012@param CompInt         Data type for the computation\012@param CompUint        Data type for the computation\012@param CONV_POLICY     Conversion policy (wrap & saturate)\012@param ROUND_POLICY    Rounding policy (to zero & nearest even)\012@param input1          1. input pixel\012@param input2          2. input pixel\012@return                Result\012*/\012template<typename ScalarInt, typename ScalarUint, typename CompInt, \012typename CompUint, vx_convert_policy_e CONV_POLICY, const vx_round_policy_e ROUND_POLICY>\012ScalarInt MagnitudeSigned(ScalarInt input1, ScalarInt input2) {\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012\012	const vx_uint32 COMPUTE_TYPE = sizeof(CompUint);\012\012	// Get max value for overflow\012	const ScalarUint MAX_VAL = static_cast<ScalarUint>(ComputeMax<ScalarInt>());\012\012	// Compute magnitude for signed input/output\012	CompInt A = static_cast<CompInt>(input1);\012	CompInt B = static_cast<CompInt>(input2);\012	CompUint AA = static_cast<CompUint>(A*A);\012	CompUint BB = static_cast<CompUint>(B*B);\012	CompUint C = AA + BB;\012\012	// Square Root\012	ScalarUint D = 0;\012	if (COMPUTE_TYPE == 8) {\012		if (ROUND_POLICY == VX_ROUND_POLICY_TO_NEAREST_EVEN)\012			D = static_cast<ScalarUint>(sqrt(static_cast<double>(C)) + 0.5);\012		else\012			D = static_cast<ScalarUint>(sqrt(static_cast<double>(C)));\012	} else {\012		D = SqrtLester<ScalarUint, CompUint, true, ROUND_POLICY>(C);\012	}\012\012	// Overflow (Saturation) - due to conversion back to signed\012	ScalarUint E = 0;\012	if (CONV_POLICY == VX_CONVERT_POLICY_SATURATE)\012		E = std::min(D, MAX_VAL);\012	else if (CONV_POLICY == VX_CONVERT_POLICY_WRAP)\012		E = D;\012\012	// Return result\012	return static_cast<ScalarInt>(E);\012}\012\012/*! \\brief Compute Magnitude of one pixel (unsigned) \012    \\details Tested for 8, 16 and 32 bit | exact OpenVX results if MAX_VALUE and CHECK_MAX are true \\n\012@param ScalarUint      Data type of the image pixels\012@param CompUint        Data type for the computation\012@param CONV_POLICY     Conversion policy (wrap & saturate)\012@param ROUND_POLICY    Rounding policy (to zero & nearest even)\012@param input1          1. input pixel\012@param input2          2. input pixel\012@return                Result\012*/\012template<typename ScalarUint, typename CompUint, vx_convert_policy_e CONV_POLICY, vx_round_policy_e ROUND_POLICY>\012ScalarUint MagnitudeUnsigned(ScalarUint input1, ScalarUint input2) {\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012\012	const vx_uint32 COMPUTE_TYPE = sizeof(CompUint);\012\012	// Get max value for overflow\012	const ScalarUint MAX_VAL = static_cast<ScalarUint>(ComputeMax<ScalarUint>());\012\012	// Compute magnitude for unsigned input/output\012	CompUint A = static_cast<CompUint>(input1);\012	CompUint B = static_cast<CompUint>(input2);\012	CompUint AA = A*A;\012	CompUint BB = B*B;\012	CompUint C = AA + BB;\012\012	// Square Root\012	ScalarUint D = 0;\012	if (COMPUTE_TYPE == 8) {\012		if (ROUND_POLICY == VX_ROUND_POLICY_TO_NEAREST_EVEN)\012			D = static_cast<ScalarUint>(sqrt(static_cast<double>(C)) + 0.5);\012		else\012			D = static_cast<ScalarUint>(sqrt(static_cast<double>(C)));\012	} else {\012		D = SqrtLester<ScalarUint, CompUint, true, ROUND_POLICY>(C);\012	}\012\012	// Overflow (Saturation) - if C alrady has overflow\012	ScalarUint E = 0;\012	if (CONV_POLICY == VX_CONVERT_POLICY_SATURATE)\012		E = (C >= AA && C >= BB) ? (D) : (MAX_VAL);\012	else if (CONV_POLICY == VX_CONVERT_POLICY_WRAP)\012		E = D;\012\012	// Return result\012	return static_cast<ScalarUint>(E);\012}\012\012\012/******************************************************************************/\012/* Compute Pixel-wise Phase */\012/******************************************************************************/\012\012/*! \\brief Compute Phase of one pixel (signed) \012@param ScalarInt      Data type of the image pixels\012@param CompUint        Data type for the computation\012@param CONV_POLICY     Conversion policy (wrap & saturate)\012@param ROUND_POLICY    Rounding policy (to zero & nearest even)\012@param input1          1. input pixel\012@param input2          2. input pixel\012@return                Result\012*/\012template<typename ScalarInt, typename ScalarUint, typename CompInt, typename CompUint, vx_convert_policy_e CONV_POLICY, const vx_round_policy_e ROUND_POLICY>\012ScalarInt Phase4Signed(ScalarInt input1, ScalarInt input2) {\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012\012	const vx_uint32 COMPUTE_TYPE = sizeof(CompUint);\012\012	// Get max value for overflow\012	const ScalarUint MAX_VAL = static_cast<ScalarUint>(ComputeMax<ScalarInt>());\012\012	// Compute magnitude for signed input/output\012	CompInt A = static_cast<CompInt>(input1);\012	CompInt B = static_cast<CompInt>(input2);\012	float C = static_cast<float>(A/(float)B);\012\012	//compute 4 phase regions. Horizontal =1, Diag. Pos=2, Diag. Neg =3, Vertical = 0\012	//https://livrepository.liverpool.ac.uk/3028893/1/200832211_Jan2018.pdf\012    CompInt D = static_cast<CompInt> (2 * fabs(A));	\012    B = ( fabs(B));	\012\012	ScalarUint E = 0;\012	if ( D <= B ){\012	//Horizontal\012	    if ( D > 0)\012			E = 1;\012	else if( D < (5*B) ){\012		//vertical\012		if (C < 0)\012			E = 0;\012		//positive diagonal\012		else	\012			E = 2;\012		}\012	}\012	//negative diagonal\012	else\012	{\012			E = 3;\012	} \012\012	// Return result\012	return static_cast<ScalarInt>(E);\012}\012\012\012\012/*********************************************************************************************************************/\012/* Compute Pixel-wise Multiplication */\012/*********************************************************************************************************************/\012\012/** @brief Performs element-wise multiplication between two images and a scalar value.\012@param ScalarType      Data type of the image pixels\012@param CompType        Data type for the computation\012@param IS_SIGNED       Is true if it is a signed value\012@param CONV_POLICY     Conversion policy (wrap & saturate)\012@param ROUND_POLICY    Rounding policy (to zero & nearest even)\012@param SCALE           A positive fixed-point (16-bit fraction) number multiplied to each product before overflow handling (between 0.0 and 1.0)\012@param input1          1. input pixel\012@param input2          2. input pixel\012@return                Result\012*/\012template<typename ScalarType, typename CompType, bool IS_SIGNED, vx_type_e SCALAR_TYPE, vx_convert_policy_e CONV_POLICY, vx_round_policy_e ROUND_POLICY, vx_uint32 SCALE>\012ScalarType Multiply(ScalarType input1, ScalarType input2) {\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012\012	// Check function parameters/types\012	STATIC_ASSERT(SCALE <= 0x10000, scale_value_must_be_between_1_and_0_It_is_fixed_point_and_has_16_bit_fraction);\012\012	// Get (Max and Min)\012	const CompType MIN_VAL = static_cast<CompType>(ComputeMin<ScalarType>());\012	const CompType MAX_VAL = static_cast<CompType>(ComputeMax<ScalarType>());\012\012	// Check if scaling is by a power of two\012	const bool IS_POWER_TWO = (SCALE & (SCALE - 1)) == 0;\012\012	// Compute the amount of bits data needs to be shiftet, if it is power of two\012	vx_uint32 SHIFT = 0;\012	for (vx_uint32 i = 0; i < sizeof(SCALE) * 8; i++) {\012		if ((SCALE & static_cast<vx_uint32>(1 << i)) != 0)\012			SHIFT = 16 - i;\012	}\012\012	// Constants	\012	const CompType MULT_INT = static_cast<CompType>(SCALE);\012	const CompType ROUND_POWER_2 = (SHIFT > 0) ? (static_cast<CompType>(1) << (SHIFT - 1)) : (static_cast<CompType>(0));\012	const CompType ROUND_NORMAL = static_cast<CompType>(1) << (15);\012	const vx_uint16 SHIFT_POWER_2 = static_cast<vx_uint16>(SHIFT);\012	const vx_uint16 SHIFT_NORMAL = 16;\012	\012	// Store result\012	CompType D = 0, result = 0;\012\012	// Compute Pixelwise Multiplication\012	if (MULT_INT > 0) {\012\012		// Compute Multiplicaion\012		CompType A = static_cast<CompType>(input1);\012		CompType B = static_cast<CompType>(input2);\012		CompType C = A*B;\012\012		// Multiply and round to nearest integer\012		if (ROUND_POLICY == VX_ROUND_POLICY_TO_NEAREST_EVEN) {\012\012			// Shift bits, if scale it is a power of two\012			if (IS_POWER_TWO) {\012				D = (C + ROUND_POWER_2);				\012				D = ShiftArithmeticRight<CompType, IS_SIGNED>(D, SHIFT_POWER_2);\012\012			// Multiply by scale, if it is not a power of two\012			} else {\012				if ((SCALAR_TYPE == VX_TYPE_UINT32) || (SCALAR_TYPE == VX_TYPE_INT32)) {\012					D = ShiftArithmeticRight<CompType, IS_SIGNED>(C, SHIFT_NORMAL);\012					D = (D * MULT_INT + ROUND_NORMAL);\012				} else {\012					D = (C * MULT_INT + ROUND_NORMAL);\012					D = ShiftArithmeticRight<CompType, IS_SIGNED>(D, SHIFT_NORMAL);\012				}\012			}		\012\012		// Multiply and truncate the least significant values\012		} else if (ROUND_POLICY == VX_ROUND_POLICY_TO_ZERO) {\012\012			// Shift bits, if scale it is a power of two\012			if (IS_POWER_TWO) {\012				D = ShiftArithmeticRight<CompType, IS_SIGNED>(C, SHIFT_POWER_2);\012\012			// Multiply by scale, if it is not a power of two\012			} else {\012				if ((SCALAR_TYPE == VX_TYPE_UINT32) || (SCALAR_TYPE == VX_TYPE_INT32)) {\012					D = ShiftArithmeticRight<CompType, IS_SIGNED>(C, SHIFT_NORMAL);\012					D = (D * MULT_INT);\012				} else {\012					D = (C * MULT_INT);\012					D = ShiftArithmeticRight<CompType, IS_SIGNED>(D, SHIFT_NORMAL);\012				}\012			}\012		}\012	\012		// Saturate the result \012		if (CONV_POLICY == VX_CONVERT_POLICY_SATURATE) {\012			if (IS_SIGNED) {\012				result = SaturateMaxMin<CompType>(D, MAX_VAL, MIN_VAL);\012			} else {\012				result = std::min(D, MAX_VAL);\012			}\012		} else if (CONV_POLICY == VX_CONVERT_POLICY_WRAP) {\012			result = D;\012		}\012	}\012\012	// Return result\012	return static_cast<ScalarType>(result);\012}\012\012/*********************************************************************************************************************/\012/* Arithmetic Operations */\012/*********************************************************************************************************************/\012\012/** @brief Computes an arithmetic operation\012@param ScalarType      Data type of the image pixels\012@param OPERATION_TYPE  Operation type (e.g. arithmetic add, sub, mul)\012@param CONV_POLICY     Conversion policy (wrap & saturate)\012@param ROUND_POLICY    Rounding policy (to zero & nearest even)\012@param SCALE           A positive fixed-point (16-bit fraction) number multiplied to each product before overflow handling (between 0.0 and 1.0)\012@param input1          1. input pixel\012@param input2          2. input pixel\012@return                result\012*/\012template<typename ScalarType, HIFLIPVX::PixelwiseOperationA OPERATION_TYPE, vx_convert_policy_e CONV_POLICY, vx_round_policy_e ROUND_POLICY, vx_uint32 SCALE>\012ScalarType Arithmetic(ScalarType input1, ScalarType input2) {\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012\012	const bool IS_SIGNED = std::numeric_limits<ScalarType>::is_signed;\012	const vx_type_e SCALAR_TYPE = GET_TYPE(ScalarType);\012\012	// Convert for computation\012	const vx_int64 a = static_cast<vx_int64>(input1);\012	const vx_int64 b = static_cast<vx_int64>(input2);\012	\012	// Get (Max and Min)\012	const vx_int64 MIN_VAL = static_cast<vx_int64>(ComputeMin<ScalarType>());\012	const vx_int64 MAX_VAL = static_cast<vx_int64>(ComputeMax<ScalarType>());\012\012	// Result\012	vx_int64 result = 0;	\012\012	// ABSOLUTE_DIFFERENCE\012	if (OPERATION_TYPE == HIFLIPVX::ABSOLUTE_DIFFERENCE) {\012		const vx_int64 c = abs(a - b);\012\012		if (IS_SIGNED) {\012			if (CONV_POLICY == VX_CONVERT_POLICY_SATURATE)				\012				result = std::min(c , MAX_VAL);\012			else if (CONV_POLICY == VX_CONVERT_POLICY_WRAP)\012				result = c;\012		} else {\012			if (CONV_POLICY == VX_CONVERT_POLICY_SATURATE)\012				result = c;\012			else if (CONV_POLICY == VX_CONVERT_POLICY_WRAP)\012				result = c;\012		}\012\012	// ARITHMETIC_ADDITION\012	} else if (OPERATION_TYPE == HIFLIPVX::ARITHMETIC_ADDITION) {\012		const vx_int64 c = a + b;\012\012		if (IS_SIGNED) {\012			if (CONV_POLICY == VX_CONVERT_POLICY_SATURATE)\012				result = SaturateMaxMin<vx_int64>(c, MAX_VAL, MIN_VAL);\012			else if (CONV_POLICY == VX_CONVERT_POLICY_WRAP)\012				result = c;\012		} else {\012			if (CONV_POLICY == VX_CONVERT_POLICY_SATURATE)\012				result = std::min(c, MAX_VAL);\012			else if (CONV_POLICY == VX_CONVERT_POLICY_WRAP)\012				result = c;\012		}\012\012	// ARITHMETIC_SUBTRACTION\012	} else if (OPERATION_TYPE == HIFLIPVX::ARITHMETIC_SUBTRACTION) {\012		const vx_int64 c = a - b;\012\012		if (IS_SIGNED) {\012			if (CONV_POLICY == VX_CONVERT_POLICY_SATURATE)\012				result = SaturateMaxMin<vx_int64>(c, MAX_VAL, MIN_VAL);\012			else if (CONV_POLICY == VX_CONVERT_POLICY_WRAP)\012				result = c;\012		} else {\012			if (CONV_POLICY == VX_CONVERT_POLICY_SATURATE)\012				result = std::max(c, MIN_VAL);\012			else if (CONV_POLICY == VX_CONVERT_POLICY_WRAP)\012				result = c;\012		}\012\012	// MAGNITUDE\012	} else if (OPERATION_TYPE == HIFLIPVX::MAGNITUDE) {		\012		if (SCALAR_TYPE == VX_TYPE_INT8)\012			result = MagnitudeSigned<ScalarType, vx_uint8, vx_int16, vx_uint16, CONV_POLICY, ROUND_POLICY>(input1, input2);\012		else if (SCALAR_TYPE == VX_TYPE_INT16)\012			result = MagnitudeSigned<ScalarType, vx_uint16, vx_int32, vx_uint32, CONV_POLICY, ROUND_POLICY>(input1, input2);\012		else if (SCALAR_TYPE == VX_TYPE_INT32)\012			result = MagnitudeSigned<ScalarType, vx_uint32, vx_int64, vx_uint64, CONV_POLICY, ROUND_POLICY>(input1, input2);\012		else if (SCALAR_TYPE == VX_TYPE_UINT8)\012			result = MagnitudeUnsigned<ScalarType, vx_uint16, CONV_POLICY, ROUND_POLICY>(input1, input2);\012		else if (SCALAR_TYPE == VX_TYPE_UINT16)\012			result = MagnitudeUnsigned<ScalarType, vx_uint32, CONV_POLICY, ROUND_POLICY>(input1, input2);\012		else if (SCALAR_TYPE == VX_TYPE_UINT32)\012			result = MagnitudeUnsigned<ScalarType, vx_uint64, CONV_POLICY, ROUND_POLICY>(input1, input2);\012	\012	//PHASE\012	} else if (OPERATION_TYPE == HIFLIPVX::PHASE4) {		\012		if (SCALAR_TYPE == VX_TYPE_INT8)\012			result = Phase4Signed<ScalarType, vx_uint8, vx_int8, vx_uint16, CONV_POLICY, ROUND_POLICY>(input1, input2);\012\012	// MULTIPLY\012	} else if (OPERATION_TYPE == HIFLIPVX::MULTIPLY) {\012		if (IS_SIGNED) {\012			result = Multiply<ScalarType, vx_int64, IS_SIGNED, SCALAR_TYPE, CONV_POLICY, ROUND_POLICY, SCALE>(input1, input2);\012		} else {\012			result = Multiply<ScalarType, vx_uint64, IS_SIGNED, SCALAR_TYPE, CONV_POLICY, ROUND_POLICY, SCALE>(input1, input2);\012		}\012	}\012\012	return static_cast<ScalarType>(result);\012}\012\012/*********************************************************************************************************************/\012/* Pixelwise Operations */\012/*********************************************************************************************************************/\012\012/** @brief Performs a pixelwise operation on an image or between two images\012@param ScalarType      Data type of the image pixels\012@param OPERATION_TYPE  Operation type (e.g. bitwise or, and, xor, not | arithmetic add, sub, mul)\012@param CONV_POLICY     Conversion policy (wrap & saturate)\012@param ROUND_POLICY    Rounding policy (to zero & nearest even)\012@param SCALE           A positive fixed-point (16-bit fraction) number multiplied to each product before overflow handling (between 0.0 and 1.0)\012@param src1            1. input pixel\012@param src2            2. input pixel\012@param dst             result\012*/\012template<typename ScalarType, HIFLIPVX::PixelwiseOperationA OPERATION_TYPE, vx_convert_policy_e CONV_POLICY, vx_round_policy_e ROUND_POLICY, vx_uint32 SCALE>\012void PixelwiseComputeSameType(ScalarType src1, ScalarType src2, ScalarType &dst) {\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012\012	// Copy a data object to another.\012	if (OPERATION_TYPE == HIFLIPVX::COPY_DATA)\012		dst = src1;\012\012	// Performs a bitwise NOT operation on a input images.\012	else if (OPERATION_TYPE == HIFLIPVX::BITWISE_NOT)\012		dst = ~(src1);\012\012	// Performs a bitwise AND operation between two unsigned images.\012	else if (OPERATION_TYPE == HIFLIPVX::BITWISE_AND)\012		dst = src1 & src2;\012\012	// Performs a bitwise INCLUSIVE OR operation between two unsigned images.\012	else if (OPERATION_TYPE == HIFLIPVX::BITWISE_OR)\012		dst = src1 | src2;\012\012	// Performs a bitwise EXCLUSIVE OR (XOR) operation between two unsigned images.\012	else if (OPERATION_TYPE == HIFLIPVX::BITWISE_XOR)\012		dst = src1 ^ src2;\012\012	// Implements a pixel-wise maximum kernel.\012	else if (OPERATION_TYPE == HIFLIPVX::MAX)\012		dst = std::max(src1, src2);\012\012	// Implements a pixel - wise minimum kernel.\012	else if (OPERATION_TYPE == HIFLIPVX::MIN)\012		dst = std::min(src1, src2);\012\012	// Computes arithmetic operations\012	else if ((OPERATION_TYPE == HIFLIPVX::ABSOLUTE_DIFFERENCE) ||\012(OPERATION_TYPE == HIFLIPVX::ARITHMETIC_ADDITION) || (OPERATION_TYPE ==\012HIFLIPVX::ARITHMETIC_SUBTRACTION) || (OPERATION_TYPE == HIFLIPVX::MULTIPLY) ||\012(OPERATION_TYPE == HIFLIPVX::MAGNITUDE) || (OPERATION_TYPE == HIFLIPVX::PHASE4))\012		dst = Arithmetic<ScalarType, OPERATION_TYPE, CONV_POLICY, ROUND_POLICY, SCALE>(src1, src2);\012\012	else\012		dst = 0;\012}\012\012/** @brief  Checks if the input parameters are valid\012@param ScalarType      Data type of the image pixels\012@param VEC_SIZE        Amount of pixels computed in parallel\012@param IMG_PIXEL       Amount of pixels in the image\012@return                Data beats (IMG_PIXEL / VEC_SIZE)\012*/\012template<typename ScalarType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL>\012vx_uint32 PixelwiseCheckSameType() {\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012\012	// Constants\012	const vx_type_e SCALAR_TYPE = GET_TYPE(ScalarType);\012	const bool SCALAR_TYPE_CORRECT =\012		(SCALAR_TYPE == VX_TYPE_UINT8) || (SCALAR_TYPE == VX_TYPE_UINT16) || (SCALAR_TYPE == VX_TYPE_UINT32) ||\012		(SCALAR_TYPE == VX_TYPE_INT8) || (SCALAR_TYPE == VX_TYPE_INT16) || (SCALAR_TYPE == VX_TYPE_INT32);\012\012	// Check function parameters/types\012	STATIC_ASSERT(SCALAR_TYPE_CORRECT, data_type_error__uint_and_int_8_to_32_bit_allowed);\012	STATIC_ASSERT((IMG_PIXEL % VEC_SIZE) == 0, image_pixels_are_not_multiple_of_vector_size);\012	STATIC_ASSERT((VEC_SIZE == 1) || (VEC_SIZE == 2) || (VEC_SIZE == 4) || (VEC_SIZE == 8), _vec_size_musst_be_1_2_4_8__use_vx_image_for_2_4_8);\012\012	// Return vector pixel\012	return IMG_PIXEL / static_cast<vx_uint32>(VEC_SIZE);\012}\012\012/*********************************************************************************************************************/\012/* Pixelwise Same Data Type */\012/*********************************************************************************************************************/\012\012/** @brief Performs a pixelwise operation on an image or between two images (Top function)\012@param ScalarType      Data type of the image pixels\012@param VEC_SIZE        Amount of pixels computed in parallel\012@param IMG_PIXEL       Amount of pixels in the image\012@param OPERATION_TYPE  Operation type (e.g. bitwise or, and, xor, not | arithmetic add, sub, mul)\012@param CONV_POLICY     Conversion policy (wrap & saturate)\012@param ROUND_POLICY    Rounding policy (to zero & nearest even)\012@param SCALE           A positive fixed-point (16-bit fraction) number multiplied to each product before overflow handling (between 0.0 and 1.0)\012@param in1             1. input image\012@param in2             2. input image\012@param out             Output image\012*/\012template<typename ScalarType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, HIFLIPVX::PixelwiseOperationA OPERATION_TYPE, vx_convert_policy_e CONV_POLICY, vx_round_policy_e ROUND_POLICY, vx_uint32 SCALE,typename vx_type0, typename vx_type1,typename vx_type2>\012#ifdef Xilinx \012void PixelwiseSameType(vx_image<ScalarType, VEC_SIZE> input1[IMG_PIXEL / VEC_SIZE], vx_image<ScalarType, VEC_SIZE> input2[IMG_PIXEL / VEC_SIZE], vx_image<ScalarType, VEC_SIZE> output[IMG_PIXEL / VEC_SIZE]) {\012#elif Intel\012void PixelwiseSameType(vx_type0 &input1, vx_type1 &input2, vx_type2 &output) {\012#endif\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012\012	// Variables\012	vx_image<ScalarType, VEC_SIZE> src1, src2, dst = { 0 };\012\012	// Check if input correct\012	const vx_uint32 vector_pixels = PixelwiseCheckSameType<ScalarType, VEC_SIZE, IMG_PIXEL>();\012\012	// Computes pixelwise operations (pipelined)\012	for (vx_uint32 i = 0; i < vector_pixels; i++) {\012//#pragma ii 1\012\012		// Read input\012#ifdef Xilinx \012		src1 = input1[i];\012#elif Intel\012		src1 = input1.read();\012#endif\012		if ((OPERATION_TYPE != HIFLIPVX::BITWISE_NOT) || (OPERATION_TYPE == HIFLIPVX::COPY_DATA))\012#ifdef Xilinx \012			src2 = input2[i];\012#elif Intel\012			src2 = input2.read();\012#endif\012\012		// Computes a vector of pixelwise operations in parallel\012\012UNROLL_INTEL()\012		for (vx_uint16 j = 0; j < VEC_SIZE; j++) {\012UNROLL_XILINX()\012			PixelwiseComputeSameType<ScalarType, OPERATION_TYPE, CONV_POLICY, ROUND_POLICY, SCALE>(src1.pixel[j], src2.pixel[j], dst.pixel[j]);\012		}\012\012		// Write output\012#ifdef Xilinx \012		output[i] = dst;\012#elif Intel\012		output.write(dst);\012#endif\012	}\012}\012template<typename ScalarType, vx_uint8 VEC_SIZE, vx_uint32 IMG_PIXEL, HIFLIPVX::PixelwiseOperationA OPERATION_TYPE, vx_convert_policy_e CONV_POLICY, vx_round_policy_e ROUND_POLICY, vx_uint32 SCALE>\012void PixelwiseSameType(ScalarType input1[IMG_PIXEL / VEC_SIZE], ScalarType input2[IMG_PIXEL / VEC_SIZE], ScalarType output[IMG_PIXEL / VEC_SIZE]) {\012 #ifdef Xilinx \012#pragma HLS INLINE \012 #endif  \012\012	// Variables\012	ScalarType src1 = 0, src2 = 0, dst = 0;\012\012	// Check if input correct\012	const vx_uint32 vector_pixels = PixelwiseCheckSameType<ScalarType, VEC_SIZE, IMG_PIXEL>();\012\012	// Computes pixelwise operations (pipelined)\012	for (vx_uint32 i = 0; i < vector_pixels; i++) {\012//#pragma ii 1\012\012		// Read input\012		src1 = input1[i];\012		if ((OPERATION_TYPE != HIFLIPVX::BITWISE_NOT) || (OPERATION_TYPE == HIFLIPVX::COPY_DATA))\012			src2 = input2[i];\012\012		// Compute 1 pixelwise operation\012		PixelwiseComputeSameType<ScalarType, OPERATION_TYPE, CONV_POLICY, ROUND_POLICY, SCALE>(src1, src2, dst);\012\012		// Write output\012		output[i] = dst;\012	}\012}\012\012#endif /* SRC_IMG_PIXELOP_CORE_H_ */\012"}, {"path":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/link_OpenCLIntel.h", "name":"link_OpenCLIntel.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/link_OpenCLIntel.h", "content":"#ifndef SRC_IMG_LINK_OPENCL_INTEL_H_ \012#define SRC_IMG_LINK_OPENCL_INTEL_H_ \012#include \"definitions.h\"\012\012/*********************************************************************************************************************/\012/** @brief	Transfer data from openCL Avalon Memory Master interface to streaming interface\012 * @param SrcType     Data type of the input image (unsigned)(8-bit, 16-bit, 32-bit) \012 * @param StreamType  Data type of the streamming where dara from DRAM are write\012 * @param stream_out  Stream object where dara from DRAM are write\012 * @param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8) \012 * @param WIDTH       Image width  \012 * @param HEIGHT      Image height \012 * @param COALESCED   size of the burst petition to DRAM\012 * */\012using namespace ihc;  \012//forcing a Burst Coalesced LSU/\012using burst_coalesced = lsu<style<BURST_COALESCED>>;\012template<typename SrcType, typename StreamType, StreamType &stream_out,typename DramTypeIn, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, uint COALESCED>\012//void vxReadDram(){\012void vxReadDram(DramTypeIn *dram_in){\012\012	vx_image<SrcType, VEC_NUM> data[COALESCED];\012auto aux_dram=&(*dram_in[0]);\012//using burst_coalesced =ihc::lsu<ihc::style<ihc::BURST_COALESCED>>;\012	#pragma ii 1\012	for (auto i = 0; i < WIDTH * HEIGHT/(VEC_NUM*COALESCED); i++){\012//	First version		\012		UNROLL_INTEL()\012		for (vx_uint8 j = 0; j < COALESCED; ++j) \012    //		 data[j]= (*dram_in)[i*COALESCED + j];\012    		// data[j]= dram_in[i*COALESCED + j];\012    		//data[j]= burst_coalesced::load(*dram_in[i*COALESCED + j]);\012//    		data[j]= burst_coalesced::load(dram_in[i*COALESCED + j]);\012    		data[j]= burst_coalesced::load(&aux_dram[i*COALESCED + j]);\012   // 		data[j]= burst_coalesced::load(&dram_in);\012//7\012\012		for (vx_uint8 j = 0; j < COALESCED; ++j) \012			stream_out.write(data[j]);	\012	} \012}\012\012//template<typename SrcType, typename StreamType, StreamType &stream_out,typename DramTypeIn, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, uint COALESCED = 8>\012//void vxReadDram(DramTypeIn *dram_in){\012//	vx_image<SrcType, VEC_NUM> data[COALESCED];\012//	for (auto i = 0; i < WIDTH * HEIGHT/(VEC_NUM*COALESCED); i++){\012////	First version		\012//		for (int j = 0; j < COALESCED; ++j) \012//    		 data[j]= (*dram_in)[i*COALESCED + j];\012//\012//		for (int j = 0; j < COALESCED; ++j) \012//			stream_out.write(data[j]);	\012//	} \012//}\012\012\012/*********************************************************************************************************************/\012/** @brief	Transfer data from openCL  streaming interface to Avalon Memory Master\012 * @param SrcType     Data type of the input image (unsigned)(8-bit, 16-bit, 32-bit) G\012 * @param StreamType  Data type of the streamming\012 * @param stream_out  Stream object source to DRAM\012 * @param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8) \012 * @param WIDTH       Image width  \012 * @param HEIGHT      Image height \012 * @param COALESCED   size of the burst petition to DRAM\012 * */\012template<typename DstType, typename StreamType, StreamType &stream_in,typename DramTypeOut, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, uint COALESCED = 8>\012void vxWriteDram(DramTypeOut *dram_out){\012	vx_image<DstType, VEC_NUM> data[COALESCED];\012\012	for (auto i = 0; i < WIDTH * HEIGHT/(VEC_NUM*COALESCED); i++){\012\012		for (vx_uint8 j = 0; j < COALESCED; ++j)\012			data[j]=hls_fpga_reg(stream_in.read()); \012   \012		UNROLL_INTEL()\012		for (vx_uint8 j = 0; j < COALESCED; ++j) \012	    	(*dram_out)[i*COALESCED+j] = data[j];	\012	  //  	(*dram_out)[i*COALESCED+j] = stream_in.read();	\012		\012	} \012}\012\012/*********************************************************************************************************************/\012/** @brief	Transfer data from openCL  streaming interface to Avalon Memory Master\012 * @param SrcType     Data type of the input image (unsigned)(8-bit, 16-bit, 32-bit) G\012 * @param StreamType  Data type of the streamming\012 * @param stream_out  Stream object source to DRAM\012 * @param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8) \012 * @param WIDTH       Image width  \012 * @param HEIGHT      Image height \012 * @param COALESCED   size of the burst petition to DRAM\012 * */\012template<typename DstType, typename StreamType, StreamType &stream_in,typename DramTypeOut, vx_uint8 VEC_NUM, vx_uint16 WIDTH, uint COALESCED = 8>\012void vxDistributionWriteDram(DramTypeOut *dram_out){\012	vx_distribution<DstType, VEC_NUM> data[COALESCED];\012\012	for (auto i = 0; i < WIDTH /(VEC_NUM*COALESCED); i++){\012		for (vx_uint8 j = 0; j < COALESCED; ++j)\012			data[j]=hls_fpga_reg(stream_in.read()); \012   \012		UNROLL_INTEL()\012		for (vx_uint8 j = 0; j < COALESCED; ++j) \012	    	(*dram_out)[i*COALESCED+j] = data[j];	\012	} \012}\012/*********************************************************************************************************************/\012/** @brief	Copy data from one stream to simultaneous access in graph\012 * @param SrcType     Data type of the input image (unsigned)(8-bit, 16-bit, 32-bit) G\012 * @param WIDTH       Image width  \012 * @param HEIGHT      Image height \012 * @param StreamBase  Stream to copy \012 * @param stream_out  Stream copy\012 * */\012template<typename SrcType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, \012	typename StreamType, StreamType &stream_base, StreamType &stream_out0, StreamType &stream_out1>\012void SplitStream(){\012	vx_image<SrcType, VEC_NUM> data;\012	for (auto i = 0; i < WIDTH * HEIGHT/(VEC_NUM); i++){\012		data = stream_base.read();\012		stream_out0.write(data);		\012		stream_out1.write(data);		\012	}\012}\012\012/*********************************************************************************************************************/\012/*********************************************************************************************************************/\012/***************CLASS WRAPPER******************************************************************************************/\012/** @brief	Transfer task to launch functions\012 * @param SrcType     Data type of the input image (unsigned)(8-bit, 16-bit, 32-bit) \012 * @param StreamType  Data type of the streamming\012 * @param stream_out  Stream object source to DRAM\012 * @param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8) \012 * @param WIDTH       Image width  \012 * @param HEIGHT      Image height \012 * @param COALESCED   size of the burst petition to DRAM\012 * */\012\012template<typename SrcType, typename StreamType, StreamType &input0, typename DramTypeIn, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, uint COALESCED>\012struct vxDramRead\012{\012    vxDramRead(DramTypeIn *dram_in){\012	//ihc::launch((vxReadDram<SrcType, decltype(input0), input0, DramTypeIn, VEC_NUM, WIDTH, HEIGHT, COALESCED>)); \012	ihc::launch((vxReadDram<SrcType, decltype(input0), input0, DramTypeIn, VEC_NUM, WIDTH, HEIGHT, COALESCED>), dram_in); \012	}\012    void vxReleaseNode(){\012//	ihc::collect((vxReadDram<SrcType, decltype(input0), input0, DramTypeIn, VEC_NUM, WIDTH, HEIGHT,COALESCED>)); \012	}\012};\012\012template<typename SrcType, typename StreamType, StreamType &input0, typename DramTypeOut, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, uint COALESCED = 8>\012struct vxDramWrite\012{\012   /*  @see vxWriteDram(DramTypeOut *dram_out)*/\012    vxDramWrite(DramTypeOut *dram_in){\012	ihc::launch((vxWriteDram<SrcType, decltype(input0), input0, DramTypeOut, VEC_NUM, WIDTH, HEIGHT, COALESCED>), dram_in); \012	}\012    void vxReleaseNode(){\012	ihc::collect((vxWriteDram<SrcType, decltype(input0), input0, DramTypeOut, VEC_NUM, WIDTH, HEIGHT, COALESCED>)); \012	}\012};\012\012\012template<typename SrcType, typename StreamType, StreamType &input0, typename DramTypeOut, vx_uint8 VEC_NUM, vx_uint16 WIDTH, uint COALESCED = 8>\012struct vxDistributionDramWrite\012{\012   /*  @see vxWriteDram(DramTypeOut *dram_out)*/\012    vxDistributionDramWrite(DramTypeOut *dram_in){\012	ihc::launch((vxDistributionWriteDram<SrcType, decltype(input0), input0, DramTypeOut, VEC_NUM, WIDTH, COALESCED>), dram_in); \012	}\012    void vxReleaseNode(){\012	ihc::collect((vxDistributionWriteDram<SrcType, decltype(input0), input0, DramTypeOut, VEC_NUM, WIDTH, COALESCED>)); \012	}\012};\012\012template<typename SrcType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, \012	typename StreamType, StreamType &stream_base, StreamType &stream_out0, StreamType &stream_out1>\012struct vxSplitStream\012{\012    vxSplitStream(){\012	ihc::launch((SplitStream <SrcType, VEC_NUM, WIDTH, HEIGHT, decltype(stream_base), stream_base, stream_out0, stream_out1>)); \012	}\012    void vxReleaseNode(){\012//	ihc::collect((SplitStream <SrcType, VEC_NUM, WIDTH, HEIGHT, StreamType, stream_base, stream_out0, stream_out1>)); \012	}\012};\012#endif\012"}, {"path":"/opt/intelFPGA_pro/19.4/hls/include/HLS/lsu.h", "name":"lsu.h", "has_active_debug_locs":false, "absName":"/opt/intelFPGA_pro/19.4/hls/include/HLS/lsu.h", "content":"/**************************************************************************\012 *                                                                        *\012 *  A library that allows controlling the LSU of a given load/store site  *\012 *  Copyright 2019, Intel Corporation                                     *\012 *  All Rights Reserved.                                                  *\012 *                                                                        *\012 *  Author: Mohammad Fawaz                                                *\012 *                                                                        *\012 **************************************************************************/\012\012#ifndef __HLS_LSU_H__\012#define __HLS_LSU_H__\012\012namespace ihc {\012// Forward declarations. These are defined in HLS/hls.h\012template <typename _DT, class... _Params> class mm_master;\012template <template <int> class _Type, class... _T> struct GetValue;\012\012enum style_t {\012  BURST_COALESCED = 0,\012  PIPELINED,\012};\012\012template <int _N> struct style {\012  static constexpr enum style_t value = (style_t)_N;\012  static constexpr enum style_t defaultValue = BURST_COALESCED;\012};\012\012template <int _N> struct static_coalescing {\012  static constexpr int value = _N;\012  static constexpr int defaultValue = 1;\012};\012\012template <class... _LSUParams> class lsu final {\012public:\012  lsu() = delete;\012\012#ifdef HLS_X86\012  template <class _DT, class... _MMParams>\012  static _DT &load(mm_master<_DT, _MMParams...> &Ptr) {\012    return *Ptr;\012  }\012\012  template <class _DT> static _DT &load(_DT *Ptr) { return *Ptr; }\012\012  template <class _DT, class... _MMParams>\012  static void store(mm_master<_DT, _MMParams...> &Ptr, _DT Val) {\012    *Ptr = Val;\012  }\012\012  template <class _DT> static void store(_DT *Ptr, _DT Val) { *Ptr = Val; }\012#else\012  template <class _DT, class... _MMParams>\012  static _DT &load(mm_master<_DT, _MMParams...> &Ptr) {\012    CheckLoad();\012    return *__builtin_fpga_mem(&*Ptr, _style == BURST_COALESCED, 0, 0, 0, 0,\012                               _static_coalescing);\012  }\012\012  template <class _DT> static _DT &load(_DT *Ptr) {\012    CheckLoad();\012    return *__builtin_fpga_mem(Ptr, _style == BURST_COALESCED, 0, 0, 0, 0,\012                               _static_coalescing);\012  }\012\012  template <class _DT, class... _MMParams>\012  static void store(mm_master<_DT, _MMParams...> &Ptr, _DT Val) {\012    CheckStore();\012    *__builtin_fpga_mem(&*Ptr, _style == BURST_COALESCED, 0, 0, 0, 0,\012                        _static_coalescing) = Val;\012  }\012\012  template <class _DT> static void store(_DT *Ptr, _DT Val) {\012    CheckStore();\012    *__builtin_fpga_mem(Ptr, _style == BURST_COALESCED, 0, 0, 0, 0,\012                        _static_coalescing) = Val;\012  }\012#endif\012\012private:\012  static constexpr int _style = GetValue<ihc::style, _LSUParams...>::value;\012  static constexpr int _static_coalescing =\012      GetValue<ihc::static_coalescing, _LSUParams...>::value;\012\012  static void CheckLoad() {\012    static_assert(_style == BURST_COALESCED || _style == PIPELINED,\012                  \"Invalid LSU style choice for a load operation\");\012  }\012  static void CheckStore() {\012    static_assert(_style == BURST_COALESCED || _style == PIPELINED,\012                  \"Invalid LSU style choice for a store operation\");\012  }\012};\012} // namespace ihc\012\012#endif //__HLS_LSU_H__\012"}, {"path":"/opt/intelFPGA_pro/19.4/hls/include/HLS/math.h", "name":"math.h", "has_active_debug_locs":false, "absName":"/opt/intelFPGA_pro/19.4/hls/include/HLS/math.h", "content":"#ifndef __HLS_MATH_H__\012#define __HLS_MATH_H__\012\012/* This file is used to overlay math.h on linux and windows.\012The table below describes what is currently available on each platform\012We are currently supporting gcc 4.4.7 and MSVC 10 respectively, so that \012is the versions we are currenlty trying to mimic.\012All floating point functions that are available, has an f at the end for \012single precison floating point, so sin(double), but sinf(float)\012Y = Supported\012N = Not supported yet\012E = Support in extendedmath.h\012- = Not available on that platform with the supported underlying compiler, \012 ****************************************************************\012 * Function Name            Linux    Windows  Notes        *\012 * abs                          -    N        Integer math *\012 * labs                         -    N        Integer math *\012 * atof                         -    N                     *\012 * cos(float/double)            Y    Y                     *\012 * sin(float/double)            Y    Y                     *\012 * tan(float/double)            Y    Y                     *\012 * acos(float/double)           Y    Y                     *\012 * asin(float/double)           Y    Y                     *\012 * atan(float/double)           Y    Y                     *\012 * atan2(float/double)          Y    Y                     *\012 * cosh(float/double)           Y    Y                     *\012 * sinh(float/double)           Y    Y                     *\012 * tanh(float/double)           Y    Y                     *\012 * acosh(float/double)          Y    Y        C99/C++11    *\012 * asinh(float/double)          Y    Y        C99/C++11    *\012 * atanh(float/double)          Y    Y        C99/C++11    *\012 * exp(float/double)            Y    Y                     *\012 * frexp(float/double)          Y    Y                     *\012 * ldexp(float/double)          Y    Y                     *\012 * log(float/double)            Y    Y                     *\012 * log10(float/double)          Y    Y                     *\012 * modf(float/double)           Y    Y                     *\012 * exp2(float/double)           Y    Y        C99/C++11    *\012 * exp10(float/double)          Y    E                     *\012 * expm1(float/double)          Y    Y        C99/C++11    *\012 * ilogb(float/double)          Y    Y        C++11        *\012 * log1p(float/double)          Y    Y        C99/C++11    * \012 * log2(float/double)           Y    Y        C99/C++11    *\012 * logb(float/double)           Y    Y        C++11        *\012 * scalbn(float/double)         N    N        C99/C++11    *\012 * scalbln(float/double)        N    N        C99/C++11    *\012 * pow(float/double)            Y    Y                     *\012 * sqrt(float/double)           Y    Y                     *\012 * cbrt(float/double)           Y    Y        C99/C++11    *\012 * hypot(float/double)          Y    Y        C99/C++11    *\012 * erf(float/double)            Y    Y        C99/C++11    *\012 * erfc(float/double)           Y    Y        C99/C++11    *\012 * tgamma(float/double)         Y    Y        C99/C++11    *\012 * lgamma(float/double)         Y    Y        C99/C++11    *\012 * lgamma_r(float/double)       Y    E        C99/C++11    *\012 * ceil(float/double)           Y    Y                     *\012 * floor(float/double)          Y    Y                     *\012 * fmod(float/double)           Y    Y                     *\012 * trunc(float/double)          Y    Y        C++11        *\012 * round(float/double)          Y    Y        C++11        *\012 * lround(float/double)         N    N        C++11        *\012 * llround(float/double)        N    N        C++11        *\012 * rint(float/double)           Y    Y        C99/C++11    *\012 * lrint(float/double)          N    N        C++11        *\012 * llrint(float/double)         N    N        C++11        *\012 * nearbyint(float/double)      N    N        C++11        *\012 * remainder(float/double)      Y    Y        C++11        *\012 * drem                         N    -        obsolete name for remanider *\012 * remquo(float/double)         Y    Y        C++11        *\012 * significand                  N    -        non standard *\012 * copysign(float/double)       Y    Y        C99/C++11    *\012 * nan(float/double)            N    N        C99/C++11    *\012 * nextafter(float/double)      Y    Y        C99/C++11    *\012 * nexttoward(float/double)     N    N        C99/C++11    *\012 * fdim(float/double)           Y    Y        C++11        *\012 * fmin(float/double)           Y    Y        C++11        *\012 * fmax(float/double)           Y    Y        C++11        *\012 * fabs(float/double)           Y    Y                     *\012 * fma(float/double)            Y    Y        C++11        *\012 * fpclassify(float/double)     Y    N        C++11        *\012 * isfinite(float/double)       Y    Y        C++11        *\012 * finite(float/double)         Y    E        BSD name for isfinite _finite for windows    *\012 * isinf(float/double)          Y    Y        C++11        *\012 * isnan(float/double)          Y    Y        C++11        *\012 * isnormal(float/double)       Y    N        C++11        *\012 * signbit(float/double)        Y    N        C++11        *\012 * isgreater(float/double)      N    -        C++11        *\012 * isgreaterequal(float/double) N    -        C++11        *\012 * isless(float/double)         N    -        C++11        *\012 * islessequal(float/double)    N    -        C++11        *\012 * islessgreater(float/double)  N    -        C++11        *\012 * isunordered(float/double)    Y    N        C++11        *\012 ****************************************************************/\012\012#include <math.h>\012\012#if defined(__INTELFPGA_COMPILER__)\012#ifdef HLS_SYNTHESIS\012#define __PUREF __attribute__((const))\012\012// FPGA, remap to current internal OpenCL names\012extern \"C\" {\012\012/********** Supported trig builtins **********/\012double __PUREF __acl__cosfd(double __x);\012#define cos(__x) __acl__cosfd(__x)\012\012float __PUREF __acl__flush_denorm_cosf(float __x);\012#define cosf(__x) __acl__flush_denorm_cosf(__x)\012\012double __PUREF __acl__sinfd(double __x);\012#define sin(__x) __acl__sinfd(__x)\012\012float __PUREF __acl__flush_denorm_sinf(float __x);\012#define sinf(__x) __acl__flush_denorm_sinf(__x)\012\012double __PUREF __acl__wrapper_tanfd(double __x);\012#define tan(__x) __acl__wrapper_tanfd(__x)\012\012float __PUREF __acl__flush_denorm_tanf(float __x);\012#define tanf(__x) __acl__flush_denorm_tanf(__x)\012\012double __PUREF __acl__acosfd(double __x);\012#define acos(__x) __acl__acosfd(__x)\012\012float __PUREF __acl__flush_denorm_acosf(float __x);\012#define acosf(__x) __acl__flush_denorm_acosf(__x)\012\012double __PUREF __acl__asinfd(double __x);\012#define asin(__x) __acl__asinfd(__x)\012\012float __PUREF __acl__flush_denorm_asinf(float __x);\012#define asinf(__x) __acl__flush_denorm_asinf(__x)\012\012double __PUREF __acl__atanfd(double __x);\012#define atan(__x) __acl__atanfd(__x)\012\012float __PUREF __acl__flush_denorm_atanf(float __x);\012#define atanf(__x) __acl__flush_denorm_atanf(__x)\012\012double __PUREF __acl__atan2fd(double __x, double __y);\012#define atan2(__x, __y) __acl__atan2fd(__x, __y)\012\012float __PUREF __acl__atan2f(float __x, float __y);\012#define atan2f(__x, __y) __acl__atan2f(__x, __y)\012\012double __PUREF __acl__coshfd(double __x);\012#define cosh(__x) __acl__coshfd(__x)\012\012float __PUREF __acl__coshf(float __x);\012#define coshf(__x) __acl__coshf(__x)\012\012double __PUREF __acl__sinhfd(double __x);\012#define sinh(__x) __acl__sinhfd(__x)\012\012float __PUREF __acl__sinhf(float __x);\012#define sinhf(__x) __acl__sinhf(__x)\012\012double __PUREF __acl__tanhfd(double __x);\012#define tanh(__x) __acl__tanhfd(__x)\012\012float __PUREF __acl__tanhf(float __x);\012#define tanhf(__x) __acl__tanhf(__x)\012\012double __PUREF __acl__acoshfd(double __x);\012#define acosh(__x) __acl__acoshfd(__x)\012\012double __PUREF __acl__asinhfd(double __x);\012#define asinh(__x) __acl__asinhfd(__x)\012\012double __PUREF __acl__atanhfd(double __x);\012#define atanh(__x) __acl__atanhfd(__x)\012\012double __PUREF __acl__expfd(double __x);\012#define exp(__x) __acl__expfd(__x)\012\012float __PUREF __acl__flush_denorm_expf(float __x);\012#define expf(__x) __acl__flush_denorm_expf(__x)\012\012double __PUREF __acl_frexpd(double __x, int* __y);\012#define frexp(__x, __y)  __acl_frexpd(__x, __y)\012\012float __PUREF __acl_frexpf(float __x, int* __y);\012#define frexpf(__x, __y)  __acl_frexpf(__x, __y)\012\012double __PUREF __acl__ldexpfd(double __x, int __y);\012#define ldexp(__x, __y) __acl__ldexpfd(__x, __y)\012\012float __PUREF __acl__ldexpf(float __x, int __y);\012#define ldexpf(__x, __y) __acl__ldexpf(__x, __y)\012 \012double __PUREF __acl__logfd(double __x);\012#define log(__x) __acl__logfd(__x)\012\012float __PUREF __acl__flush_denorm_logf(float __x);\012#define logf(__x) __acl__flush_denorm_logf(__x)\012\012double __PUREF __acl__log10fd(double __x);\012#define log10(__x) __acl__log10fd(__x)\012\012float __PUREF __acl__log10f(float __x);\012#define log10f(__x) __acl__log10f(__x)\012\012double __PUREF __acl_modfd(double __x, double * __y);\012#define modf(__x, __y) __acl_modfd(__x, __y)\012\012float __PUREF __acl_modff(float __x, float* __y);\012#define modff(__x, __y) __acl_modff(__x, __y)\012\012double __PUREF __acl__exp2fd(double __x);\012#define exp2(__x) __acl__exp2fd(__x)\012\012float __PUREF __acl__exp2f(float __x);\012#define exp2f(__x) __acl__exp2f(__x)\012\012#if defined (__linux__)\012\012double __PUREF __acl__exp10fd(double __x);\012#define exp10(__x) __acl__exp10fd(__x)\012\012float __PUREF __acl__exp10f(float __x);\012#define exp10f(__x) __acl__exp10f(__x)\012\012#endif //linux\012\012inline double __x_expm1 (double __x) {\012  return __acl__expfd(__x) - 1.0;\012}\012#define expm1(__x) __x_expm1(__x)\012\012float __PUREF __acl__expm1f(float);      \012#define expm1f(__x) __acl__expm1f(__x)\012\012int __PUREF __acl__ilogbfd(double __x);\012#define ilogb(__x) __acl__ilogbfd(__x)\012\012int __PUREF __acl__ilogbf(float __x);\012#define ilogbf(__x) __acl__ilogbf(__x)\012\012double __PUREF __acl__ln1pxfd(double __x);\012#define log1p(__x) __acl__ln1pxfd(__x)\012\012float __PUREF __acl__ln1pxf(float __x);\012#define log1pf(__x) __acl__ln1pxf(__x)\012\012double __PUREF __acl__log2fd(double __x);\012#define log2(__x) __acl__log2fd(__x)\012\012float __PUREF __acl__log2f(float __x);\012#define log2f(__x) __acl__log2f(__x)\012\012double __PUREF __acl__powfd(double __x, double __y);\012#define pow(__x,__y) __acl__powfd(__x, __y)\012\012float __PUREF __acl__powf(float __x, float __y);\012#define powf(__x,__y) __acl__powf(__x, __y)\012\012double __PUREF __acl__sqrtfd(double  __x);\012#define sqrt(__x) __acl__sqrtfd(__x)\012\012float __PUREF __acl__flush_denorm_sqrtf(float __x);\012#define sqrtf(__x) __acl__flush_denorm_sqrtf(__x)\012\012// Only have the float version built-in.\012inline double __x_cbrt(double __x) {\012  return exp(log(__x) / 3.0);\012}\012#define cbrt(__x) __x_cbrt(__x)\012\012float __PUREF __acl__cbrtf(float);\012#define cbrtf(__x) __acl__cbrtf(__x)\012\012inline double __x_hypot(double __x, double __y) {\012  return sqrt(__x*__x + __y*__y);\012}\012#define hypot(__x,__y) __x_hypot(__x,__y)\012\012float __PUREF __acl__hypotf(float, float);\012#define hypotf(__x,__y) __acl__hypotf(__x,__y)\012\012/************ Error & Gamma Functions *********/\012double __PUREF __acl__ceilfd(double __x);\012#define ceil(__x) __acl__ceilfd(__x)\012\012float __PUREF __acl__ceilf(float __x);\012#define ceilf(__x) __acl__ceilf(__x)\012\012double __PUREF __acl__floorfd(double __x);\012#define floor(__x) __acl__floorfd(__x)\012\012float __PUREF __acl__floorf(float __x);\012#define floorf(__x) __acl__floorf(__x)\012\012double __PUREF __acl__fmodfd(double __x, double __y);\012#define fmod(__x,__y) __acl__fmodfd(__x, __y)\012\012float __PUREF __acl__fmodf(float __x, float __y);\012#define fmodf(__x,__y) __acl__fmodf(__x, __y)\012\012double __PUREF __acl__truncfd(double __x);\012#define trunc(__x) __acl__truncfd(__x)\012\012float __PUREF __acl__truncf(float __x);\012#define truncf(__x) __acl__truncf(__x)\012\012double __PUREF __acl__roundfd(double __x);\012#define round(__x) __acl__roundfd(__x)\012\012float __PUREF __acl__roundf(float __x);\012#define roundf(__x) __acl__roundf(__x)\012\012double __PUREF __acl__rintfd(double __x);\012#define rint(__x) __acl__rintfd(__x)\012\012float __PUREF __acl__rintf(float __x);\012#define rintf(__x) __acl__rintf(__x)\012\012double __PUREF __acl__copysignfd(double __x, double __y);\012#define copysign(__x, __y) __acl__copysignfd(__x, __y)\012\012float __PUREF __acl__copysignf(float __x, float __y);\012#define copysignf(__x, __y) __acl__copysignf(__x, __y)\012\012double __PUREF __acl__fdimfd(double __x, double __y);\012#define fdim(__x,__y) __acl__fdimfd(__x, __y)\012\012float __PUREF __acl__fdimf(float __x, float __y);\012#define fdimf(__x,__y) __acl__fdimf(__x, __y)\012\012double __PUREF __acl__fminfd(double __x, double __y);\012#define fmin(__x,__y) __acl__fminfd(__x, __y)\012\012float __PUREF __acl__fminf(float __x, float __y);\012#define fminf(__x,__y) __acl__fminf(__x, __y)\012\012double __PUREF __acl__fmaxfd(double __x, double __y);\012#define fmax(__x,__y) __acl__fmaxfd(__x, __y)\012\012float __PUREF __acl__fmaxf(float __x, float __y);\012#define fmaxf(__x,__y) __acl__fmaxf(__x, __y)\012\012double __PUREF __acl__fabsfd(double __x);\012#define fabs(__x) __acl__fabsfd(__x)\012\012float __PUREF __acl__fabsf(float __x);\012#define fabsf(__x) __acl__fabsf(__x)\012\012/********** Classification ******************/\012#if defined (__linux__)\012long __PUREF __acl__isfinitefd(double __x);\012#define __finite(__x) __acl__isfinitefd(__x)\012\012int __PUREF __acl__isfinitef(float __x);\012#define __finitef(__x) __acl__isfinitef(__x)\012\012#define finite(__x) __acl__isfinitefd(__x)\012#define finitef(__x) __acl__isfinitef(__x)\012\012long __PUREF __acl__isinffd(double __x);\012#define __isinf(__x) __acl__isinffd(__x)\012\012int __PUREF __acl__isinff(float __x);\012#define __isinff(__x) __acl__isinff(__x)\012\012long __PUREF __acl__isnanfd(double __x);\012#define __isnan(__x) __acl__isnanfd(__x)\012\012int __PUREF __acl__isnanf(float __x);\012#define __isnanf(__x) __acl__isnanf(__x)\012\012inline int __x_fpclassifyfd(double __x) {\012  if (isnan(__x)) return 0; // FP_NAN\012  if (isinf(__x)) return 1; // FP_INFINITE\012  unsigned long in_bits = *((unsigned long*)&__x);\012  if ((in_bits == 0x0000000000000000) || (in_bits == 0x8000000000000000)) return 2; // FP_ZERO\012  if ((in_bits & 0x7ff0000000000000) == 0) return 3; // FP_SUBNORMAL\012  return 4; // FP_NORMAL\012}\012#define __fpclassify(__x) __x_fpclassifyfd(__x)\012\012inline int __x_fpclassifyf(float __x) {\012  if (isnan(__x)) return 0; // FP_NAN\012  if (isinf(__x)) return 1; // FP_INFINITE\012  unsigned in_bits = *((unsigned*)&__x);\012  if ((in_bits == 0x00000000) || (in_bits == 0x80000000)) return 2; // FP_ZERO\012  if ((in_bits & 0x7f800000) == 0) return 3; // FP_SUBNORMAL\012  return 4; // FP_NORMAL\012}\012#define __fpclassifyf(__x) __x_fpclassifyf(__x)\012\012inline long __x_signbitfd(double __x) { unsigned long xbits = *((unsigned long*)&__x); return xbits >> 63 << 7; }\012#define __signbit(__x) __x_signbitfd(__x)\012\012inline int __x_signbitf(float __x) { unsigned xbits = *((unsigned*)&__x); return xbits >> 31 << 3; }\012#define __signbitf(__x) __x_signbitf(__x)\012\012#endif //linux\012\012#if defined (_MSC_VER)\012  // Pull in CPP Library version information. \012  long long __PUREF __acl__isnanfd(double __x);\012  int __PUREF __acl__isnanf(float __x);\012  long long __PUREF __acl__isfinitefd(double __x);\012  int __PUREF __acl__isfinitef(float __x);\012  \012  #if (_CPPLIB_VER >= 650)\012    // Support isnan(x) for MSVC 2015+  in fpga components.\012    #ifndef isnan \012      #define isnan(x) \\\012        (sizeof (x) == sizeof (float) ? __acl__isnanf(x) :  __acl__isnanfd(x))\012    #endif // #ifndef isnan\012\012    #ifndef isfinite\012      #define isfinite(x) \\\012        (sizeof (x) == sizeof (float) ? __acl__isfinitef(x) : __acl__isfinitefd(x))\012    #endif // #ifndef isfinite\012\012    #ifndef isinf\012      #define isinf(x) \\\012        (sizeof (x) == sizeof (float) ? !__acl__isfinitef(x) : !__acl__isfinitefd(x))\012    #endif // #ifndef isinf\012\012  #endif // #if (_CPPLIB_VER >= 650)\012  // MSVC handles _isnanf and _isnanfd in 2 different places (math.h and float.h)\012  // So it is messy to support them. Use isnan instead.\012\012#endif // #if defined(MSC_VER)\012\012/********** Other builtins **********/\012/* They have to be put in the end because they are dependent on functions above */\012float __PUREF __acl__flush_denorm(float __x);\012inline float __PUREF __acl__flush_denorm_signed_zero(float __x) {\012  unsigned in_bits = *((unsigned*)&__x);\012  if (((in_bits & 0x7f800000) == 0) && (in_bits != 0x80000000)) in_bits = 0;\012  return *((float*)&in_bits);\012}\012\012inline float __x_acoshf(float __x) {\012  unsigned float_nan = 0x7fffffff;\012  return (float)(isnan(__x) ? (__x) : \012          (((__x) < 1.0f) ? *((float*)&float_nan) : \012           __acl__flush_denorm((float)(log(((double)(__x)) + sqrt(((double)(__x)) + 1.0) * sqrt(((double)(__x))-1.0))))));\012}\012#define acoshf(__x) __x_acoshf(__x)\012\012inline float __x_asinhf(float __x) {\012  float absx = fabsf(__x); \012  double myx = (double) __x; \012  return (float) ((isnan(__x) || isinf(__x)) ? (__x) : \012          __acl__flush_denorm((absx < 0x1.0p-28f) ? (__x) : \012           ((absx > 0x1.0p+28f) ? copysignf(((float)(log((double)(absx)) + 0.693147180559945309417232121458176568)), __x) : \012            ((absx > 2.0f) ? copysignf(((float)(log(((double)(absx)) + sqrt(myx * myx + 1.0)))), __x) : \012             copysignf(((float)(log1p(absx + myx * myx / (1.0 + sqrt(myx * myx + 1.0))))), __x)))));\012}\012#define asinhf(__x) __x_asinhf(__x)\012\012inline float __x_atanhf(float __x) {\012  unsigned float_nan = 0x7fffffff;\012  float absx = fabsf(__acl__flush_denorm_signed_zero(__x));\012  double __dx = (double)(absx); \012  double __dxs = (double)(__acl__flush_denorm_signed_zero(__x)); \012  return (float)__acl__flush_denorm_signed_zero((isnan(__x) ? *((float*)&float_nan) : \012          ((*((unsigned*)&absx) > 0x3f800000) ? *((float*)&float_nan) : \012           ((*((unsigned*)&absx) < 0x3f000000) ? (float) copysign(ldexp(log1p( 2.0 * ( __dx + __dx*__dx / (1.0-__dx) )), -1), __dxs) : \012            (float)copysign(ldexp(log1p(2.0 * __dx / (1.0-__dx)), -1), __dxs)))));\012}\012#define atanhf(__x) __x_atanhf(__x)\012\012inline double __x_erffd(double __x) { double x_sqr = __x * __x; return copysign(sqrt(1.0 - exp(-x_sqr * (((4.0 / 0X1.921FB54442D18P+1) + 0.147*x_sqr) / (1.0+0.147*x_sqr)))),__x); }\012#define erf(__x) __x_erffd(__x)\012\012inline float __x_erff(float __x) { float x_sqr = (__x) * (__x); return copysignf(sqrtf(1.0f - expf(-x_sqr * (((4.0f * 0X1.45F306DC9C883P-2f) + 0.147f*x_sqr) / (1.0f+0.147f*x_sqr)))),__x); }\012#define erff(__x) __x_erff(__x)\012\012inline double __x_erfcfd(double __x) { return 1.0 - erf(__x); }\012#define erfc(__x) __x_erfcfd(__x)\012\012inline float __x_erfcf(float __x) { return 1.0f - erff(__x); }\012#define erfcf(__x) __x_erfcf(__x)\012\012inline double __x_fmafd(double __x, double __y, double __z) {\012  if (!isnan(__x) && !isinf(__x) && !isnan(__y) && !isinf(__y) && isinf(__z)) return __z;\012  if (isnan(__x)) return __x;\012  if (isnan(__y)) return __y;\012  if (isnan(__z)) return __z;\012  return __x*__y+__z;\012}\012#define fma(__x,__y,__z) __x_fmafd(__x,__y,__z)\012\012float __PUREF __acl__fused_mad(float __x, float __y, float __z);\012inline float __x_fmaf(float __x, float __y, float __z) {\012  if (!isnan(__x) && !isinf(__x) && !isnan(__y) && !isinf(__y) && isinf(__z)) return __z;\012  if (isnan(__x)) return __x;\012  if (isnan(__y)) return __y;\012  if (isnan(__z)) return __z;\012  float ix = __acl__flush_denorm(__x);\012  float iy = __acl__flush_denorm(__y);\012  float iz = __acl__flush_denorm(__z);\012  return __acl__fused_mad(ix, iy, iz);\012}\012#define fmaf(__x,__y,__z) __x_fmaf(__x,__y,__z)\012\012// Every invoking of Gamma function uses Stirling's approximation\012inline double __x_lgammafd(double __x) { return (__x-0.5)*log(__x) - (__x) + 0.91893853320467; }\012#define lgamma(__x) __x_lgammafd(__x)\012\012inline float __x_lgammaf(float __x) { return isinf(__x) ? (__x) : ((fabsf(__x)-0.5f)*logf(fabsf(__x)) - fabsf(__x) + 0.91893853320467f); }\012#define lgammaf(__x) __x_lgammaf(__x)\012\012#if defined (__linux__)\012\012inline double __x_lgammafd_r(double __x, int *__sign) {\012  double i = lgamma(__x);\012  *__sign = (int)((i < 0.0) ? 1 : 0);\012  return i;\012}\012#define lgamma_r(__x,__sign) __x_lgammafd_r(__x,__sign)\012\012inline float __x_lgammaf_r(float __x, int *__sign) {\012  float i = lgammaf(__x);\012  *__sign = (int)((i < 0.0) ? 1 : 0);\012  return i;\012}\012#define lgammaf_r(__x,__sign) __x_lgammaf_r(__x,__sign)\012\012#endif\012\012inline double __x_tgammafd(double __x) { return exp(lgamma(__x)); }\012#define tgamma(__x) __x_tgammafd(__x)\012\012inline float __x_tgammaf(float __x) { return expf(lgammaf(__x)); }\012#define tgammaf(__x) __x_tgammaf(__x)\012\012#if defined (__linux__)\012inline double __x_logbfd(double __x) {\012  if (isnan(__x) || isinf(__x)) return __x;\012  long exponent = *((long*)&__x);\012  exponent = (exponent >> 52) & 0x00000000000007ff;\012  if (exponent == 0) return exponent;\012  return ((double)(exponent - 1023));\012}\012\012inline double __x_nextafterfd(double __x, double __y) {\012  if (isnan(__x)) return __x;\012  if (isnan(__y)) return __y;\012  unsigned long temp = 9223372036854775808U;\012  unsigned long x_int = *((unsigned long*)&__x);\012  unsigned long y_int = *((unsigned long*)&__y);\012  if (x_int & temp) x_int = temp - x_int;\012  if (y_int & temp) y_int = temp - y_int;\012  if (x_int==y_int) return __x;\012  x_int += (x_int < y_int) ? 1 : -1;\012  x_int = (x_int < 0) ? temp - x_int : x_int;\012  return *((double*)&x_int);\012}\012\012inline double __x_remquofd(double __x, double __y, int *__quo) {\012  double fx = __x;\012  double fy = __y;\012  double xr = fabs(fx);\012  double yr = fabs(fy);\012  unsigned long mask_x = *((unsigned long*)&xr);\012  unsigned long mask_y = *((unsigned long*)&yr);\012  unsigned long sign_x = *((unsigned long*)&fx) >> 63;\012  unsigned long sign_y = *((unsigned long*)&fy) >> 63;\012  if (isnan(fx) || isnan(fy) || isinf(fx) || (*((unsigned long*)&yr) == 0))\012  { *__quo = 0; return __builtin_nan(\"\"); } \012  if (isinf(fy) || (mask_x == 0)) { *__quo = 0; return fx; }\012  if (mask_x == mask_y) { *__quo = (sign_x == sign_y) ? 1 : -1; return copysign((double)0.0,fx); }\012  int ex = ilogb(fx);\012  int ey = ilogb(fy);\012  unsigned q = 0;\012  double xxp = ldexp(xr, 1);\012  if (ex-ey >= 0) { \012    int i;\012    yr = ldexp(yr, -ey);\012    xr = ldexp(xr, -ex);\012    for(i = ex-ey; i > 0; i--) {\012      q <<= 1;\012      if(xr >= yr) {\012        xr -= yr;\012        q += 1;\012      }\012      xr += xr;\012    }\012    q <<= 1;\012    if( xr > yr ) {\012      xr -= yr;\012      q += 1;\012    }\012    xxp = ldexp(xr, ey+1);\012    xr = ldexp(xr, ey);\012  }\012  double abs_fy = fabs(fy);\012  if ((abs_fy < xxp) || ((abs_fy == xxp) && (q & 0x00000001))) {\012    double abs_xr = fabs(xr);\012    bool adjust = (*((unsigned long*)&abs_xr) == 0);\012    double yyp = ldexp(fabs(fy),1);\012    xxp -= yyp;\012    xr = adjust ? ldexp(xxp,-1) : xxp; q += 1; }\012  q = q & 0x07f;\012  if (sign_x != sign_y) q = -q;\012  if ((sign_x == 1) && (mask_x != 0)) xr = -xr;\012  *__quo = q;\012  return xr; \012}\012#endif\012#if defined (_MSC_VER)\012inline double __x_logbfd(double __x) {\012  if (isnan(__x) || isinf(__x)) return __x;\012  long long exponent = *((long long*)&__x);\012  exponent = (exponent >> 52) & 0x00000000000007ff;\012  if (exponent == 0) return exponent;\012  return ((double)(exponent - 1023));\012}\012\012inline double __x_nextafterfd(double __x, double __y) {\012  if (isnan(__x)) return __x;\012  if (isnan(__y)) return __y;\012  unsigned long long temp = 9223372036854775808U;\012  unsigned long long x_int = *((unsigned long long*)&__x);\012  unsigned long long y_int = *((unsigned long long*)&__y);\012  if (x_int & temp) x_int = temp - x_int;\012  if (y_int & temp) y_int = temp - y_int;\012  if (x_int==y_int) return __x;\012  x_int += (x_int < y_int) ? 1 : -1;\012  x_int = (x_int < 0) ? temp - x_int : x_int;\012  return *((double*)&x_int);\012}\012\012inline double __x_remquofd(double __x, double __y, int *__quo) {\012  double fx = __x;\012  double fy = __y;\012  double xr = fabs(fx);\012  double yr = fabs(fy);\012  unsigned long long mask_x = *((unsigned long long*)&xr);\012  unsigned long long mask_y = *((unsigned long long*)&yr);\012  unsigned long long sign_x = *((unsigned long long*)&fx) >> 63;\012  unsigned long long sign_y = *((unsigned long long*)&fy) >> 63;\012  if (isnan(fx) || isnan(fy) || isinf(fx) || (*((unsigned long long*)&yr) == 0))\012  { *__quo = 0; return __builtin_nan(\"\"); } \012  if (isinf(fy) || (mask_x == 0)) { *__quo = 0; return fx; }\012  if (mask_x == mask_y) { *__quo = (sign_x == sign_y) ? 1 : -1; return copysign((double)0.0,fx); }\012  int ex = ilogb(fx);\012  int ey = ilogb(fy);\012  unsigned q = 0;\012  double xxp = ldexp(xr, 1);\012  if (ex-ey >= 0) { \012    int i;\012    yr = ldexp(yr, -ey);\012    xr = ldexp(xr, -ex);\012    for(i = ex-ey; i > 0; i--) {\012      q <<= 1;\012      if(xr >= yr) {\012        xr -= yr;\012        q += 1;\012      }\012      xr += xr;\012    }\012    q <<= 1;\012    if( xr > yr ) {\012      xr -= yr;\012      q += 1;\012    }\012    xxp = ldexp(xr, ey+1);\012    xr = ldexp(xr, ey);\012  }\012  double abs_fy = fabs(fy);\012  if ((abs_fy < xxp) || ((abs_fy == xxp) && (q & 0x00000001))) {\012    double abs_xr = fabs(xr);\012    bool adjust = (*((unsigned long long*)&abs_xr) == 0);\012    double yyp = ldexp(fabs(fy),1);\012    xxp -= yyp;\012    xr = adjust ? ldexp(xxp,-1) : xxp; q += 1; }\012  q = q & 0x07f;\012  if (sign_x != sign_y) q = -q;\012  if ((sign_x == 1) && (mask_x != 0)) xr = -xr;\012  *__quo = q;\012  return xr; \012}\012#endif\012#define logb(__x) __x_logbfd(__x)\012#define nextafter(__x,__y) __x_nextafterfd(__x,__y)\012#define remquo(__x,__y,__quo) __x_remquofd(__x,__y,__quo)\012\012inline double __x_remainderfd(double __x, double __y) { int __i; return remquo(__x, __y, &__i); }\012#define remainder(__x,__y) __x_remainderfd(__x,__y)\012\012inline float __x_logbf(float __x) {\012  if (isnan(__x) || isinf(__x)) return __x;\012  int exponent = *((int*)&__x);\012  exponent = (exponent >> 23) & 0x000000ff;\012  if (exponent == 0) return exponent;\012  return ((float)(exponent - 127));\012}\012#define logbf(__x) __x_logbf(__x)\012\012inline float __x_nextafterf(float __x, float __y) {\012  if (isnan(__x)) return __x;\012  if (isnan(__y)) return __y;\012  unsigned int temp = 2147483648U;\012  unsigned int x_int = *((unsigned int*)&__x);\012  unsigned int y_int = *((unsigned int*)&__y);\012  if (x_int & temp) x_int = temp - x_int;\012  if (y_int & temp) y_int = temp - y_int;\012  if (x_int==y_int) return __x;\012  x_int += (x_int < y_int) ? 1 : -1;\012  x_int = (x_int < 0) ? temp - x_int : x_int;\012  return *((float*)&x_int);\012}\012#define nextafterf(__x,__y) __x_nextafterf(__x,__y)\012\012float __PUREF __acl__fadd_with_denorms(float a, float b);\012inline float __x_remquof(float __x, float __y, int *__quo) {\012  float fx = __acl__flush_denorm(__x);\012  float fy = __acl__flush_denorm(__y);\012  float xr = fabsf(fx);\012  float yr = fabsf(fy);\012  unsigned mask_x = *((unsigned*)&xr);\012  unsigned mask_y = *((unsigned*)&yr);\012  unsigned sign_x = *((unsigned*)&fx) >> 31;\012  unsigned sign_y = *((unsigned*)&fy) >> 31;\012  if (isnan(fx) || isnan(fy) || isinf(fx) || (*((unsigned*)&yr) == 0))\012  { *__quo = 0; return __builtin_nanf(\"\"); } \012  if (isinf(fy) || (mask_x == 0)) { *__quo = 0; return fx; }\012  if (mask_x == mask_y) { *__quo = (sign_x == sign_y) ? 1 : -1; return copysignf((float)0.0f,fx); }\012  int ex = ilogbf(fx);\012  int ey = ilogbf(fy);\012  unsigned q = 0;\012  float xxp = ldexpf(xr, 1);\012  if (ex-ey >= 0) { \012    int i;\012    yr = ldexpf(yr, -ey);\012    xr = ldexpf(xr, -ex);\012    for(i = ex-ey; i > 0; i--) {\012      q <<= 1;\012      if(xr >= yr) {\012        xr -= yr;\012        q += 1;\012      }\012      xr += xr;\012    }\012    q <<= 1;\012    if( xr > yr ) {\012      xr -= yr;\012      q += 1;\012    }\012    xxp = ldexpf(xr, ey+1);\012    xr = ldexpf(xr, ey);\012  }\012  float abs_fy = fabsf(fy);\012  if ((abs_fy < xxp) || ((abs_fy == xxp) && (q & 0x00000001))) {\012    float abs_xr = fabsf(xr);\012    bool adjust = (*((unsigned*)&abs_xr) == 0);\012    float yyp = ldexpf(abs_fy,1);\012    xxp = __acl__fadd_with_denorms(adjust ? xxp : xr, adjust ? (-yyp) : (-abs_fy));\012    xr = adjust ? ldexpf(xxp,-1) : xxp; q += 1; }\012  q = q & 0x07f;\012  if (sign_x != sign_y) q = -q;\012  if ((sign_x == 1) && (mask_x != 0)) xr = -xr;\012  *__quo = q;\012  return __acl__flush_denorm(xr);\012}\012#define remquof(__x,__y,__quo) __x_remquof(__x,__y,__quo)\012\012inline float __x_remainderf(float __x, float __y) { int __i; return __acl__flush_denorm(remquof(__x, __y, &__i)); }\012#define remainderf(__x,__y) __x_remainderf(__x,__y)\012\012}\012#endif //#ifdef HLS_SYNTHESIS\012#endif //__INTELFPGA_COMPILER__\012#endif //__HLS_MATH_H__\012\012"}, {"path":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/graph_test/sobel.cpp", "name":"sobel.cpp", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/graph_test/sobel.cpp", "content":"#ifdef Xilinx\012	#include \"img_filter_base.h\"\012	#include \"img_filter_component_xilinx.h\"\012//     //TODO seprate Xilinx definitios form img_filter_core\012#elif Intel\012	#include \"HLS/hls.h\"\012	#include \"sobel_component.h\"\012#endif\012\012#include \"definitions.h\"\012#include \"bmp_tools.h\"\012\012\012typedef vx_uint8 filter_u_type;\012typedef vx_int8 filter_s_type;\012typedef vx_image<filter_u_type, VEC_NUM, vx_streamIn_e> filter_u_image;\012\012int main(){\012#ifdef Xilinx\012#pragma HLS INTERFACE axis port=input\012#pragma HLS INTERFACE axis port=output1\012#pragma HLS INTERFACE axis port=output2\012\012#pragma HLS data_pack variable=input\012#pragma HLS data_pack variable=output1\012#pragma HLS data_pack variable=output2\012#endif\012	//Input ppm image -only for CPU test\012	//std::string input_bmp_filename    = \"test.bmp\";\012	std::string input_bmp_filename    = \"rabbit.bmp\";\012	std::string input1_bmp_filename    = \"in_test.bmp\";\012	std::string output_bmp_filename   = \"out_test.bmp\";\012\012	//Avalon master Interfaces\012	vx_image<filter_u_type, VEC_NUM> tmp_in[COLS_FHD*ROWS_FHD/VEC_NUM];\012	vx_image<filter_s_type, VEC_NUM> tmp_out[COLS_FHD*ROWS_FHD/VEC_NUM];\012	vx_image<filter_s_type, VEC_NUM> tmp_out1[COLS_FHD*ROWS_FHD/VEC_NUM];\012\012	#ifdef Xilinx\012    \012	#elif Intel\012	DramTypeIn0 mm_in(tmp_in,sizeof(vx_image<filter_u_type, VEC_NUM>)*COLS_FHD*ROWS_FHD);\012	DramTypeOut0 mm_out(tmp_out,sizeof(vx_image<filter_u_type, VEC_NUM>)*COLS_FHD*ROWS_FHD);\012	DramTypeOut1 mm_out1(tmp_out1,sizeof(vx_image<filter_u_type, VEC_NUM>)*COLS_FHD*ROWS_FHD);\012	#endif\012	//\012	//  load bmp image\012	unsigned int* in_img = 0;;\012	int rows, cols;\012	read_bmp(input_bmp_filename.c_str(), &in_img, rows, cols);\012	//assert (rows == ROWS_FHD);	//Verifies if the input image is the same as hardware reference	\012	vx_image<filter_u_type,VEC_NUM> data;\012	for (int i = 0; i < (ROWS_FHD*COLS_FHD)/VEC_NUM; ++i) {\012		for (int j = 0; j < VEC_NUM; ++j) {\012			data.pixel[j]= static_cast<filter_u_type>(in_img[i*VEC_NUM+j]);\012		}\012		tmp_in[i]=data;\012	}\012\012	//calling the component\012	ImgSobelFunc<filter_u_type, filter_s_type, VEC_NUM , COLS_FHD , ROWS_FHD , FILTER_SIZE , SOBEL_BORDER>(mm_in, mm_out, mm_out1);\012\012	unsigned int* out_img = (unsigned int*) malloc(rows * cols * sizeof(unsigned int));\012	vx_image<filter_s_type,VEC_NUM> data_out;\012\012	for (int i = 0; i < (rows*cols)/VEC_NUM; ++i) {\012		//if it is an streaming\012		//			data_out = output1.read();\012		data_out=tmp_out[i];\012		for (int j = 0; j < VEC_NUM; ++j) {\012			out_img[i*VEC_NUM+j] = data_out.pixel[j];\012		}\012\012	}\012	//save the processed image in a .bmp file\012	write_bmp(output_bmp_filename.c_str(), out_img, rows, cols);\012}\012\012"}, {"path":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/graph_test/sobel.h", "name":"sobel.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/graph_test/sobel.h", "content":"#ifndef SRC_IMG_SOBEL_TEST_INTEL_H_\012#define SRC_IMG_SOBEL_TEST_INTEL_H_\012#include \"sobel_component.h\"\012#include \"img_filter_base_intel.h\" \012#include \"img_pixelop_base.h\" \012//#include \"img_filter_base.h\" \012\012#define SEPARABLE_SOBEL   (vx_bool)vx_true_e\012\012/** @brief  Avalon MM to connect with DRAM \\n */\012//latency 0 indacates a variable latency\012//waitrequest is necessary when the system uses burst_size > 1\012//aspace memory banks\012//awidth address bus bits (from BSP file: Board_spec.xml )\012typedef ihc::mm_master<vx_image<vx_uint8, VEC_NUM>, ihc::aspace<1>, ihc::awidth<32>, ihc::dwidth<512>, ihc::latency<0>, ihc::maxburst<16>, ihc::align<64>, ihc::waitrequest<true>> DramTypeIn0; \012typedef ihc::mm_master<vx_image<vx_int8, VEC_NUM>, ihc::aspace<2>, ihc::awidth<32>, ihc::dwidth<512>, ihc::latency<0>, ihc::maxburst<16>, ihc::align<64>, ihc::waitrequest<true>> DramTypeOut0; \012typedef ihc::mm_master<vx_image<vx_int8, VEC_NUM>, ihc::aspace<3>, ihc::awidth<32>, ihc::dwidth<512>, ihc::latency<0>, ihc::maxburst<16>, ihc::align<64>, ihc::waitrequest<true>> DramTypeOut1; \012\012\012//all the streamming interfaces should be global for system of task in HLS Intel.\012//trying to balance the task with buffers between task\012#define VEC_INT 8\012vx_image<vx_uint8,VEC_INT , vx_stream_e> stream_r_0; \012vx_image<vx_uint8,VEC_INT , vx_stream_e> stream_0_1; \012vx_image<vx_int8 ,VEC_INT , vx_stream_e> streamX_1_2;  \012vx_image<vx_int8 ,VEC_INT , vx_stream_e> streamY_1_2;  \012\012template <typename SrcType, typename DstType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, \012	vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE	>\012void ImgSobelFunc( DramTypeIn0 &InputImg, DramTypeOut0 &OutputImg, DramTypeOut1 &OutputImg1	)\012{\012	//Is it doing prefetching? buff->trying to improve the buffer.\012	vxDramRead <SrcType, decltype(stream_r_0), stream_r_0, DramTypeIn0, VEC_NUM, \012		WIDTH, HEIGHT,8> vxCopyDRAM_In0 (&InputImg);\012	//for canny filter 1-Gauus..2- Sobel \012	//Sobel Filter\012	ImgSobel <SrcType, DstType,VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, \012		decltype(stream_r_0), decltype(streamX_1_2), decltype(streamY_1_2),\012		stream_r_0, streamX_1_2, streamY_1_2> vxSobelNode1;\012\012	vxDramWrite <DstType, decltype(streamX_1_2), streamX_1_2, DramTypeOut0, \012		VEC_NUM, WIDTH, HEIGHT> vxCopyDRAM_Out0 (&OutputImg);\012\012	vxDramWrite <DstType, decltype(streamY_1_2), streamY_1_2, DramTypeOut1, \012		VEC_NUM, WIDTH, HEIGHT> vxCopyDRAM_Out1 (&OutputImg1);\012	\012	vxSobelNode1.vxReleaseNode();\012	vxCopyDRAM_In0.vxReleaseNode();\012	vxCopyDRAM_Out0.vxReleaseNode();\012	vxCopyDRAM_Out1.vxReleaseNode();\012}\012\012#endif /* SRC_IMG_SOBEL_BASE_H_ */\012"}, {"path":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/graph_test/sobel_component.h", "name":"sobel_component.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/graph_test/sobel_component.h", "content":"#ifndef SRC_IMG_COMPONENT_INTEL_H_\012#define SRC_IMG_COMPONENT_INTEL_H_\012#include \"sobel.h\"\012\012//component instance\012//template component \012//void ImgSobel<vx_uint8,vx_int8, VEC_NUM, COLS_FHD,ROWS_FHD, FILTER_SIZE, SOBEL_BORDER, vx_streamIn_e,vx_streamOut_e, vx_streamOut_e> \012//	(_vx_in(vx_image<vx_uint8, VEC_NUM,vx_streamIn_e>) input0, \012//	 _vx_out(vx_image<vx_int8, VEC_NUM,vx_streamOut_e>) output1,\012//	 _vx_out(vx_image<vx_int8, VEC_NUM,vx_streamOut_e>) output2); \012\012\012/*******************************************************************************/\012/*******************************************************************************/\012extern \"C\" template component \012void ImgSobelFunc<vx_uint8, vx_int8, VEC_NUM, COLS_FHD,ROWS_FHD, FILTER_SIZE, SOBEL_BORDER>(\012DramTypeIn0 &InputImg,\012DramTypeOut0 &OutputImg, \012DramTypeOut1 &OutputImg1 \012); \012/*******************************************************************************/\012/*******************************************************************************/\012\012#endif\012"}, {"path":"/opt/intelFPGA_pro/19.4/hls/include/HLS/task.h", "name":"task.h", "has_active_debug_locs":false, "absName":"/opt/intelFPGA_pro/19.4/hls/include/HLS/task.h", "content":"#ifndef _INTEL_IHC_HLS_TASK\012#define _INTEL_IHC_HLS_TASK\012#include \"HLS/function_traits.h\"\012\012#include <type_traits>\012#include <utility>\012\012// Make sure the macros to take the user calls into implementations\012// is not in effect for the source code of the implementation\012#undef launch\012#undef collect\012\012// Bring in the platform specific '_task' for composition\012#if defined(__INTELFPGA_COMPILER__)  && !defined(HLS_X86)\012#include \"HLS/internal/_task_FPGA.h\"\012#else\012#include \"HLS/internal/_task_X64.h\"\012#endif\012\012namespace ihc {\012  namespace internal {\012    // Signature for void func()\012    using VoidFuncTy = void ();\012\012    // The task is a singleton that is shared between\012    // a calculation and its result:\012    // * Launch the calculations\012    //   task<function>::launch(args...);\012    // * Get the results\012    //   [ret = ]task<function>::collect();\012    //      > blocking until launch is finished\012    //      > returns result for non-void function\012    //\012    // When the main program exits, any pending\012    // launches will still be processed in their\012    // respective thread\012    //\012    // The task is implemented as an\012    // Adaptor Design Pattern\012    // The X64 or FPGA implementation is adapted to the desired API\012    // This adaptor is straight forward:\012    // Both architecture specific implementations are supposed to\012    // be interface compatible with this adaptor\012    template<typename X, X& f, bool detach = false>\012    class task {\012    public:\012      // using F: typename X is different between compilers!\012      using F = decltype(f);\012      using T = typename ihc::function_traits<F>::return_type;\012\012      // Launch the callable\012      template<int capacity, typename ... Args>\012      static void launch(Args&& ... args) {\012        _t.template launch<capacity>(std::forward<Args>(args)...);\012      }\012\012      // Get the result\012      template<int capacity>\012      static T collect() {\012        // Restore void if needed\012        return static_cast<T>(_t.template collect<capacity>());\012      }\012\012    private:\012      // Constructor\012      task() {};\012      // Destructor\012      // Can't be explicit for FPGA target in Intel(R) HLS Compiler\012      //~_task() {}\012\012      // Composition (_task is architecture specific)\012      // Singleton\012      // Anywhere in the function hierarchy where \"f\" gets called,\012      // this specific task (with the corresponding thread and queue)\012      // needs to be used\012      static internal::_task<X, f, detach> _t;\012    }; // class task\012\012    template <typename X, X& f, bool detach>\012    internal::_task<X, f, detach> task<X, f, detach>::_t;\012\012    // Launch (through singleton)\012    template <int capacity, class X, X &f, typename... Args>\012    void launch(Args &&... args) {\012      task<X, f>::template launch<capacity>(std::forward<Args>(args)...);\012    }\012\012    // Collect (through singleton)\012    template<int capacity, typename X, X& f>\012    typename ihc::function_traits<decltype(f)>::return_type collect() {\012      // using F: typename X is different between compilers!\012      using F = decltype(f);\012      using T = typename ihc::function_traits<F>::return_type;\012      // Restore void if needed\012      return static_cast<T>(task<X, f>::template collect<capacity>());\012    }\012\012    // launch_always_run_helper utilities\012    template <VoidFuncTy &f> void launch_at_startup() {\012      while (1) {\012        f();\012      }\012    }\012\012    template <VoidFuncTy &f> class launch_always_run_helper {\012    public:\012      launch_always_run_helper() {\012        task<VoidFuncTy, launch_at_startup<f>, true>::template launch<0>();\012      }\012    };\012  } // namespace internal\012\012  /// Launches a task function at when the component starts up.\012  /// The task function to be launched must take no input arguments and have\012  /// a void return.\012  template <internal::VoidFuncTy &f> void launch_always_run() {\012    static internal::launch_always_run_helper<f> t;\012  }\012\012  // Fake functions to help with Content Assist (IntelliSense)\012\012  // /!\\ Please remember to put parentheses around a launch of\012  //     a templated function:\012  //     ihc::launch(\012  //       ( foo<Types...> ),\012  //       args... );\012  template<int capacity, typename F, typename... Args>\012  void launch(F&& f, Args&&...args);\012  template<int capacity, typename F>\012  typename ihc::function_traits<F>::return_type collect(F&& f);\012\012} // namespace ihc\012\012// Work around for C++14 (no support for <auto& f>\012#define launch(x, ...)  internal::launch <0, decltype(x), x>(__VA_ARGS__)\012#define buffered_launch(depth, x, ...)  internal::launch <depth, decltype(x), x>(__VA_ARGS__)\012\012#define collect(x)      internal::collect<0, decltype(x), x>()\012#define buffered_collect(depth, x)      internal::collect<depth, decltype(x), x>()\012\012#endif // _INTEL_IHC_HLS_TASK\012"}, {"path":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/vx_fpga.h", "name":"vx_fpga.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/vx_fpga.h", "content":"\012#ifndef _HiFlipVX_MANUFACTUREFPGA_H_\012#define _HiFlipVX_MANUFACTUREFPGA_H_\012\012/** @brief Decides what type of funtion is implemented accordig the manufacturer\012@param Xilinx      If is a Xilinx device the input streamming is based on an array of the vx_type\012@param Intel	   If is an Intel device Xilinx pointers generates arbitration that generates a lo iniation interval, the interfac should be in this case an streamming type, passed  as direction argument.\012*/\012#ifdef Xilinx\012	#define _vx_in(...) __VA_ARGS__\012	#define _vx_out(...) __VA_ARGS__\012	#define _vx_vecsize(...) [__VA_ARGS__]//Xilinx needs to define the size of the streamming buffer\012#elif Intel\012	#define _vx_in(...) __VA_ARGS__&\012	//#define _vx_in(...) ::ihc::stream_in<__VA_ARGS__>&\012	#define _vx_out(...) __VA_ARGS__&\012	//#define _vx_out(...) ::ihc::stream_out<__VA_ARGS__>&\012	#define _vx_vecsize(...) //In Intel the pointers are removed\012#endif\012\012\012\012\012#endif\012"}, {"path":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/vx_types.h", "name":"vx_types.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/hls/HiFlipVX_Intel_FPGA/include/vx_types.h", "content":"/**\012* Copyright (c) 2012-2017 The Khronos Group Inc.\012*\012* Licensed under the Apache License, Version 2.0 (the \"License\");\012* you may not use this file except in compliance with the License.\012* You may obtain a copy of the License at\012*\012*    http://www.apache.org/licenses/LICENSE-2.0\012*\012* Unless required by applicable law or agreed to in writing, software\012* distributed under the License is distributed on an \"AS IS\" BASIS,\012* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\012* See the License for the specific language governing permissions and\012* limitations under the License.\012*/\012\012#ifndef _OPENVX_TYPES_H_\012#define _OPENVX_TYPES_H_\012\012/*!\012* \\file vx_types.h\012* \\brief The type definitions required by OpenVX Library.\012*/\012\012#include <stdint.h>\012\012/*********************************************************************************************************************/\012/* OpenVX Macros */\012/*********************************************************************************************************************/\012\012/*! \\def VX_DF_IMAGE\012* \\brief Converts a set of four chars into a \\c uint32_t container of a VX_DF_IMAGE code.\012* \\note Use a <tt>\\ref vx_df_image</tt> variable to hold the value.\012* \\ingroup group_basic_features\012*/\012#define VX_DF_IMAGE(a,b,c,d)                  ((a) | (b << 8) | (c << 16) | (d << 24))\012\012/*! \\def VX_ATTRIBUTE_BASE\012* \\brief Defines the manner in which to combine the Vendor and Object IDs to get\012* the base value of the enumeration.\012* \\ingroup group_basic_features\012*/\012#define VX_ATTRIBUTE_BASE(vendor, object)   (((vendor) << 20) | (object << 8))\012\012/*! \\def VX_ENUM_BASE\012* \\brief Defines the manner in which to combine the Vendor and Object IDs to get\012* the base value of the enumeration.\012* \\details From any enumerated value (with exceptions), the vendor, and enumeration\012* type should be extractable. Those types that are exceptions are\012* <tt>\\ref vx_vendor_id_e</tt>, <tt>\\ref vx_type_e</tt>, <tt>\\ref vx_enum_e</tt>, <tt>\\ref vx_df_image_e</tt>, and \\c vx_bool.\012* \\ingroup group_basic_features\012*/\012#define VX_ENUM_BASE(vendor, id)            (((vendor) << 20) | (id << 12)) \012\012/*********************************************************************************************************************/\012/* OpenVX typedefs */\012/*********************************************************************************************************************/\012\012/*! \\brief An 8 bit ASCII character.\012* \\ingroup group_basic_features\012*/\012typedef char     vx_char;\012\012/*! \\brief An 8-bit unsigned value.\012* \\ingroup group_basic_features\012*/\012typedef uint8_t  vx_uint8;\012\012/*! \\brief A 16-bit unsigned value.\012* \\ingroup group_basic_features\012*/\012typedef uint16_t vx_uint16;\012\012/*! \\brief A 32-bit unsigned value.\012* \\ingroup group_basic_features\012*/\012typedef uint32_t vx_uint32;\012\012/*! \\brief A 64-bit unsigned value.\012* \\ingroup group_basic_features\012*/\012typedef uint64_t vx_uint64;\012\012/*! \\brief An 8-bit signed value.\012* \\ingroup group_basic_features\012*/\012typedef int8_t   vx_int8;\012\012/*! \\brief A 16-bit signed value.\012* \\ingroup group_basic_features\012*/\012typedef int16_t  vx_int16;\012\012/*! \\brief A 32-bit signed value.\012* \\ingroup group_basic_features\012*/\012typedef int32_t  vx_int32;\012\012/*! \\brief A 64-bit signed value.\012* \\ingroup group_basic_features\012*/\012typedef int64_t  vx_int64;\012\012/*! \\brief A 32-bit float value.\012* \\ingroup group_basic_features\012*/\012typedef float    vx_float32;\012\012/*! \\brief A 64-bit float value (aka double).\012* \\ingroup group_basic_features\012*/\012typedef double   vx_float64;\012\012/*! \\brief Sets the standard enumeration type size to be a fixed quantity.\012* \\details All enumerable fields must use this type as the container to\012* enforce enumeration ranges and sizeof() operations.\012* \\ingroup group_basic_features\012*/\012typedef int32_t vx_enum;\012\012\012/*! \\brief A wrapper of <tt>size_t</tt> to keep the naming convention uniform.\012* \\ingroup group_basic_features\012*/\012typedef size_t vx_size;\012\012/*! \\brief Used to hold a VX_DF_IMAGE code to describe the pixel format and color space.\012* \\ingroup group_basic_features\012*/\012typedef uint32_t vx_df_image;\012\012/*! \\brief A Boolean value.\012* This allows 0 to be FALSE, as it is in C, and any non-zero to be TRUE.\012* \\code\012* vx_bool ret = vx_true_e;\012* if (ret) printf(\"true!\\n\");\012* ret = vx_false_e;\012* if (!ret) printf(\"false!\\n\");\012* \\endcode\012* This would print both strings.\012* \\ingroup group_basic_features\012*/\012typedef enum _vx_bool_e {\012	/*! \\brief The \"false\" value. */\012	vx_false_e = 0,\012	/*! \\brief The \"true\" value. */\012	vx_true_e,\012} vx_bool;\012\012/*! \\brief The type enumeration lists all the known types in OpenVX.\012* \\ingroup group_basic_features\012*/\012enum vx_type_e {\012	VX_TYPE_INVALID = 0x000,/*!< \\brief An invalid type value. When passed an error must be returned. */\012	VX_TYPE_CHAR = 0x001,/*!< \\brief A <tt>\\ref vx_char</tt>. */\012	VX_TYPE_INT8 = 0x002,/*!< \\brief A <tt>\\ref vx_int8</tt>. */\012	VX_TYPE_UINT8 = 0x003,/*!< \\brief A <tt>\\ref vx_uint8</tt>. */\012	VX_TYPE_INT16 = 0x004,/*!< \\brief A <tt>\\ref vx_int16</tt>. */\012	VX_TYPE_UINT16 = 0x005,/*!< \\brief A <tt>\\ref vx_uint16</tt>. */\012	VX_TYPE_INT32 = 0x006,/*!< \\brief A <tt>\\ref vx_int32</tt>. */\012	VX_TYPE_UINT32 = 0x007,/*!< \\brief A <tt>\\ref vx_uint32</tt>. */\012	VX_TYPE_INT64 = 0x008,/*!< \\brief A <tt>\\ref vx_int64</tt>. */\012	VX_TYPE_UINT64 = 0x009,/*!< \\brief A <tt>\\ref vx_uint64</tt>. */\012	VX_TYPE_FLOAT32 = 0x00A,/*!< \\brief A <tt>\\ref vx_float32</tt>. */\012	VX_TYPE_FLOAT64 = 0x00B,/*!< \\brief A <tt>\\ref vx_float64</tt>. */\012	VX_TYPE_ENUM = 0x00C,/*!< \\brief A <tt>\\ref vx_enum</tt>. Equivalent in size to a <tt>\\ref vx_int32</tt>. */\012	VX_TYPE_SIZE = 0x00D,/*!< \\brief A <tt>\\ref vx_size</tt>. */\012	VX_TYPE_DF_IMAGE = 0x00E,/*!< \\brief A <tt>\\ref vx_df_image</tt>. */\012	VX_TYPE_BOOL = 0x010,/*!< \\brief A <tt>\\ref vx_bool</tt>. */\012};\012\012/*********************************************************************************************************************/\012/* OpenVX enums (TODO: Change Vendor ID) */\012/*********************************************************************************************************************/\012\012/*! \\brief The Vendor ID of the Implementation. As new vendors submit their\012* implementations, this enumeration will grow.\012* \\ingroup group_basic_features\012*/\012enum vx_vendor_id_e {\012	VX_ID_KHRONOS = 0x000, /*!< \\brief The Khronos Group */\012};\012\012/*! \\brief The set of supported enumerations in OpenVX.\012* \\details These can be extracted from enumerated values using <tt>\\ref VX_ENUM_TYPE</tt>.\012* \\ingroup group_basic_features\012*/\012enum vx_enum_e {\012	VX_ENUM_INTERPOLATION = 0x04, /*!< \\brief Interpolation Types. */\012	VX_ENUM_CONVERT_POLICY = 0x0A, /*!< \\brief Convert Policy. */\012	VX_ENUM_THRESHOLD_TYPE = 0x0B, /*!< \\brief Threshold Type List. */\012	VX_ENUM_BORDER = 0x0C, /*!< \\brief Border Mode List. */\012	VX_ENUM_ROUND_POLICY = 0x12, /*!< \\brief Rounding Policy. */\012};\012\012/*! \\brief The Conversion Policy Enumeration.\012* \\ingroup group_basic_features\012*/\012enum vx_convert_policy_e {\012	/*! \\brief Results are the least significant bits of the output operand, as if\012	* stored in two's complement binary format in the size of its bit-depth.\012	*/\012	VX_CONVERT_POLICY_WRAP = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_CONVERT_POLICY) + 0x0,\012	/*! \\brief Results are saturated to the bit depth of the output operand. */\012	VX_CONVERT_POLICY_SATURATE = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_CONVERT_POLICY) + 0x1,\012};\012\012/*! \\brief Based on the VX_DF_IMAGE definition.\012* \\note Use <tt>\\ref vx_df_image</tt> to contain these values.\012* \\ingroup group_basic_features\012*/\012enum vx_df_image_e {\012	/*! \\brief A single plane of 24-bit pixel as 3 interleaved 8-bit units of\012	* R then G then B data. This uses the BT709 full range by default.\012	*/\012	VX_DF_IMAGE_RGB = VX_DF_IMAGE('R', 'G', 'B', '2'),\012	/*! \\brief A single plane of 32-bit pixel as 4 interleaved 8-bit units of\012	* R then G then B data, then a <i>don't care</i> byte.\012	* This uses the BT709 full range by default.\012	*/\012	VX_DF_IMAGE_RGBX = VX_DF_IMAGE('R', 'G', 'B', 'A'),\012	/*! \\brief A single plane of unsigned 8-bit data.\012	* The range of data is not specified, as it may be extracted from a YUV or\012	* generated.\012	*/\012	VX_DF_IMAGE_U8 = VX_DF_IMAGE('U', '0', '0', '8'),\012	/*! \\brief A single plane of unsigned 8-bit data.\012	* The range of data is not specified, as it may be extracted from a YUV or\012	* generated.\012	*/\012	VX_DF_IMAGE_S8 = VX_DF_IMAGE('S', '0', '0', '8'),\012	/*! \\brief A single plane of signed 16-bit data.\012	* The range of data is not specified, as it may be extracted from a YUV or\012	* generated.\012	*/\012	VX_DF_IMAGE_U16 = VX_DF_IMAGE('U', '0', '1', '6'),\012	/*! \\brief A single plane of signed 16-bit data.\012	* The range of data is not specified, as it may be extracted from a YUV or\012	* generated.\012	*/\012	VX_DF_IMAGE_S16 = VX_DF_IMAGE('S', '0', '1', '6'),\012	/*! \\brief A single plane of unsigned 32-bit data.\012	* The range of data is not specified, as it may be extracted from a YUV or\012	* generated.\012	*/\012	VX_DF_IMAGE_U32 = VX_DF_IMAGE('U', '0', '3', '2'),\012	/*! \\brief A single plane of unsigned 32-bit data.\012	* The range of data is not specified, as it may be extracted from a YUV or\012	* generated.\012	*/\012	VX_DF_IMAGE_S32 = VX_DF_IMAGE('S', '0', '3', '2'),\012	/*! \\brief A single plane of unsigned 8-bit data.\012	* The range of data is 32-bit, as it is extracted from a YUV or\012	* generated.\012    */\012	VX_DF_IMAGE_NV12 = VX_DF_IMAGE('N','V','1','2'),\012};\012\012/*! \\brief The Threshold types.\012* \\ingroup group_threshold\012*/\012enum vx_threshold_type_e {\012	/*! \\brief A threshold with only 1 value. */\012	VX_THRESHOLD_TYPE_BINARY = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_THRESHOLD_TYPE) + 0x0,\012	/*! \\brief A threshold with 2 values (upper/lower). Use with Canny Edge Detection. */\012	VX_THRESHOLD_TYPE_RANGE = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_THRESHOLD_TYPE) + 0x1,\012};\012\012/*! \\brief The image reconstruction filters supported by image resampling operations.\012*\012* The edge of a pixel is interpreted as being aligned to the edge of the image.\012* The value for an output pixel is evaluated at the center of that pixel.\012*\012* This means, for example, that an even enlargement of a factor of two in nearest-neighbor\012* interpolation will replicate every source pixel into a 2x2 quad in the destination, and that\012* an even shrink by a factor of two in bilinear interpolation will create each destination pixel\012* by average a 2x2 quad of source pixels.\012*\012* Samples that cross the boundary of the source image have values determined by the border\012* mode - see <tt>\\ref vx_border_e</tt> and <tt>\\ref VX_NODE_BORDER</tt>.\012* \\see vxuScaleImage\012* \\see vxScaleImageNode\012* \\see VX_KERNEL_SCALE_IMAGE\012* \\see vxuWarpAffine\012* \\see vxWarpAffineNode\012* \\see VX_KERNEL_WARP_AFFINE\012* \\see vxuWarpPerspective\012* \\see vxWarpPerspectiveNode\012* \\see VX_KERNEL_WARP_PERSPECTIVE\012* \\ingroup group_basic_features\012*/\012enum vx_interpolation_type_e {\012	/*! \\brief Output values are defined to match the source pixel whose center is nearest to the sample position. */\012	VX_INTERPOLATION_NEAREST_NEIGHBOR = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_INTERPOLATION) + 0x0,\012	/*! \\brief Output values are defined by bilinear interpolation between the pixels whose centers are closest\012	* to the sample position, weighted linearly by the distance of the sample from the pixel centers. */\012	VX_INTERPOLATION_BILINEAR = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_INTERPOLATION) + 0x1,\012	/*! \\brief Output values are determined by averaging the source pixels whose areas fall under the\012	* area of the destination pixel, projected onto the source image. */\012	VX_INTERPOLATION_AREA = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_INTERPOLATION) + 0x2,\012};\012\012/*! \\brief The border mode list.\012* \\ingroup group_borders\012*/\012enum vx_border_e {\012	/*! \\brief No defined border mode behavior is given. */\012	VX_BORDER_UNDEFINED = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_BORDER) + 0x0,\012	/*! \\brief For nodes that support this behavior, a constant value is\012	* \\e filled-in when accessing out-of-bounds pixels.\012	*/\012	VX_BORDER_CONSTANT = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_BORDER) + 0x1,\012	/*! \\brief For nodes that support this behavior, a replication of the nearest\012	* edge pixels value is given for out-of-bounds pixels.\012	*/\012	VX_BORDER_REPLICATE = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_BORDER) + 0x2,\012};\012\012/*! \\brief The Round Policy Enumeration.\012* \\ingroup group_context\012*/\012enum vx_round_policy_e {\012	/*! \\brief When scaling, this truncates the least significant values that are lost in operations. */\012	VX_ROUND_POLICY_TO_ZERO = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_ROUND_POLICY) + 0x1,\012	/*! \\brief When scaling, this rounds to nearest even output value. */\012	VX_ROUND_POLICY_TO_NEAREST_EVEN = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_ROUND_POLICY) + 0x2,\012};\012\012/*! \\brief The 2D Coordinates structure. HINT: Updated by template parameter\012* \\ingroup group_basic_features\012*/\012template<typename T>\012struct vx_coordinates2d_t {\012	T x;    /*!< \\brief The X coordinate. */\012	T y;    /*!< \\brief The Y coordinate. */\012};\012\012#endif\012"}];