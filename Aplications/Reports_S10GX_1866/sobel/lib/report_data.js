var areaJSON='{"columns":["", "ALUTs", "FFs", "RAMs", "DSPs", "MLABs", "Details"], "debug_enabled":"true", "type":"module", "total_percent":[1.87073, 1.37088, 0.65131, 0.964082, 0], "total":[17864, 24310, 113, 0, 386], "name":"System", "max_resources":[1866240, 3732480, 11721, 5760, 93312], "children":[{"name":"ImgSobel", "compute_units":1, "type":"function", "total_percent":[1.87073, 1.37088, 0.65131, 0.964082, 0], "total_kernel_resources":[17864, 24310, 113, 0, 386], "details":[{"type":"text", "text":"Number of compute units: 1"}, {"type":"brief", "text":"1 compute unit."}], "children":[{"name":"Component call", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 192 bits wide with a buffer size of 0 elements."}, {"type":"brief", "text":"192b wide with 0 elements."}]}, {"name":"Component return", "type":"resource", "data":[0, 0, 0, 0, 0], "details":[{"type":"text", "text":"Stream implemented 1 bit wide with a buffer size of 0 elements."}, {"type":"brief", "text":"1b wide with 0 elements."}]}, {"name":"Variable: \\n - \'ptr_dst\' (img_filter_core.h:1428)", "type":"resource", "data":[0, 0, 1, 0, 0], "debug":[[{"filename":"./img_filter_core.h", "line":1428}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 and depth 114 (depth was increased by a factor of 114 due to a loop initiation interval of 114.)"}, {"type":"brief", "text":"Register,\\n1 reg, 32 width by 114 depth"}]}, {"name":"Variable: \\n - \'ptr_src\' (img_filter_core.h:1428)", "type":"resource", "data":[0, 0, 1, 0, 0], "debug":[[{"filename":"./img_filter_core.h", "line":1428}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 32 and depth 114 (depth was increased by a factor of 114 due to a loop initiation interval of 114.)"}, {"type":"brief", "text":"Register,\\n1 reg, 32 width by 114 depth"}]}, {"name":"Variable: \\n - \'window\' (img_filter_core.h:1424)", "type":"resource", "data":[56, 72, 27, 0, 0], "debug":[[{"filename":"./img_filter_core.h", "line":1424}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"3 registers of width 8 and depth 114 (depth was increased by a factor of 114 due to a loop initiation interval of 114.)"}, {"type":"text", "text":"16 registers of width 8 and depth 115 (depth was increased by a factor of 114 due to a loop initiation interval of 114.)"}, {"type":"text", "text":"8 registers of width 8 and depth 117 (depth was increased by a factor of 114 due to a loop initiation interval of 114.)"}, {"type":"brief", "text":"Register,\\n3 regs, 8 width by 114 depth,\\n16 regs, 8 width by 115 depth"}]}, {"name":"Variable: \\n - \'x\' (img_filter_core.h:1431)", "type":"resource", "data":[8, 10, 2, 0, 0], "debug":[[{"filename":"./img_filter_core.h", "line":1431}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 9 and depth 117 (depth was increased by a factor of 114 due to a loop initiation interval of 114.)"}, {"type":"text", "text":"1 register of width 16 and depth 114 (depth was increased by a factor of 114 due to a loop initiation interval of 114.)"}, {"type":"brief", "text":"Register,\\n1 reg, 9 width by 117 depth,\\n1 reg, 16 width by 114 depth"}]}, {"name":"Variable: \\n - \'y\' (img_filter_core.h:1430)", "type":"resource", "data":[16, 56, 0, 0, 0], "debug":[[{"filename":"./img_filter_core.h", "line":1430}]], "details":[{"type":"text", "text":"Type: Register"}, {"type":"text", "text":"1 register of width 12"}, {"type":"text", "text":"1 register of width 16"}, {"type":"brief", "text":"Register,\\n1 reg, 12 width,\\n1 reg, 16 width"}]}, {"name":"img_filter_core.h:1421 (linebuffer)", "type":"resource", "data":[0, 0, 8, 0, 0], "debug":[[{"filename":"./img_filter_core.h", "line":1421}]], "details":[{"type":"table", "Memory system":"Potentially inefficient configuration", "Requested size":"3840 bytes", "Implemented size":"4096 bytes", "Number of banks":"4 (banked on bits 2, 3)", "Bank width":"32 bits", "Bank depth":"256 words", "Total replication":"1", "Additional information":[{"type":"text", "text":"Requested size 3840 bytes, implemented size 4096 bytes, <b>stallable</b>, 4 reads and 4 writes. ", "details":[{"type":"text", "text":"Reduce the number of write accesses or fix banking to make this memory system stall-free. Banking may be improved by using compile-time known indexing on lowest array dimension."}]}, {"type":"text", "text":"Banked on bits 2, 3 into 4 separate banks."}]}, {"type":"brief", "text":"Potentially inefficient configuration,\\n3840B requested,\\n4096B implemented."}]}, {"name":"ImgSobel.B1.start", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[1, 391, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[1, 199, 0, 0, 0]}, {"name":"img_filter_base.h:197", "type":"resource", "data":[0, 192, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":197}]]}]}, {"name":"Feedback", "type":"resource", "data":[23, 11, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[9, 2, 0, 0, 0]}, {"name":"img_filter_base.h:197", "type":"resource", "data":[14, 9, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":197}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[18, 14, 0, 0, 2], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}]}, {"name":"img_filter_base.h:197", "type":"resource", "data":[1, 0, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":197}]], "children":[{"name":"Stream Read", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"ImgSobel.B2", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[4, 13, 0, 0, 0], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[4, 13, 0, 0, 0]}]}, {"name":"Feedback", "type":"resource", "data":[38, 11, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1424", "type":"resource", "data":[6, 0, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1424}]]}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1430", "type":"resource", "data":[24, 9, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1430}]]}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1444", "type":"resource", "data":[8, 2, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1444}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[16, 13, 0, 0, 1], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1430", "type":"resource", "data":[42.5, 0.5, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1430}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"12-bit Integer Add", "type":"resource", "count":1, "data":[12, 0, 0, 0, 0]}, {"name":"12-bit Integer Compare", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}, {"name":"16-bit Integer Add", "type":"resource", "count":1, "data":[16, 0, 0, 0, 0]}, {"name":"16-bit Integer Compare", "type":"resource", "count":1, "data":[9.5, 0.5, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1443", "type":"resource", "data":[9.5, 0.5, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1443}]], "children":[{"name":"16-bit Integer Compare", "type":"resource", "count":1, "data":[9.5, 0.5, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1459 > \\nimg_filter_core.h:490 > img_filter_core.h:256", "type":"resource", "data":[19, 1, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1459}, {"filename":"./img_filter_core.h", "line":490}, {"filename":"./img_filter_core.h", "line":256}]], "children":[{"name":"16-bit Integer Compare", "type":"resource", "count":1, "data":[19, 1, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1465", "type":"resource", "data":[5, 0, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1465}]], "children":[{"name":"16-bit Integer Compare", "type":"resource", "count":1, "data":[5, 0, 0, 0, 0]}], "replace_name":"true"}]}]}, {"name":"ImgSobel.B3", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[27, 19, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1444", "type":"resource", "data":[27, 19, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1444}]]}]}]}, {"name":"ImgSobel.B4", "type":"basicblock", "children":[{"name":"State", "type":"resource", "data":[3077, 7577, 20, 0, 106], "details":[{"type":"brief", "text":"Live values and control logic"}, {"type":"text", "text":"Resources for live values and control logic. To reduce this area:", "details":[{"type":"text", "text":"reduce size of local variables"}, {"type":"text", "text":"reduce scope of local variables, localizing them as much as possible"}, {"type":"text", "text":"reduce number of nested loops"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[3077, 7577, 20, 0, 106]}]}, {"name":"Feedback", "type":"resource", "data":[1204, 922, 54, 0, 11], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1424", "type":"resource", "data":[110, 82, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1424}]]}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1428", "type":"resource", "data":[2, 0, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1428}]]}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1430", "type":"resource", "data":[77.5, 68, 2.5, 0, 1], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1430}]]}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1431", "type":"resource", "data":[47, 58, 0, 0, 1], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1431}]]}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1443", "type":"resource", "data":[0.5, 0, 0.5, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1443}]]}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1444", "type":"resource", "data":[217, 118, 15, 0, 1], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1444}]]}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1453 > \\nimg_filter_core.h:54", "type":"resource", "data":[3, 0, 3, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1453}, {"filename":"./img_filter_core.h", "line":54}]]}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1456 > \\nimg_filter_core.h:131", "type":"resource", "data":[47, 16, 7, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1456}, {"filename":"./img_filter_core.h", "line":131}]]}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1459 > \\nimg_filter_core.h:490 > img_filter_core.h:256", "type":"resource", "data":[1, 0, 1, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1459}, {"filename":"./img_filter_core.h", "line":490}, {"filename":"./img_filter_core.h", "line":256}]]}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1465", "type":"resource", "data":[11, 4, 1, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1465}]]}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1467", "type":"resource", "data":[176, 64, 16, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1467}]]}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1469", "type":"resource", "data":[512, 512, 8, 0, 8], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1469}]]}]}, {"name":"Cluster logic", "type":"resource", "data":[1360, 2460, 0, 0, 122], "details":[{"type":"brief", "text":"Logic required to efficiently support sets of operations that do not stall"}, {"type":"text", "text":"Logic required to efficiently support sets of operations that do not stall. This area cannot be affected directly."}]}, {"name":"Computation", "type":"resource", "children":[{"name":"No Source Line", "type":"resource", "data":[2, 1, 0, 0, 0], "debug":[[{"filename":"", "line":0}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[1, 0, 0, 0, 0]}, {"name":"1-bit Or", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}]}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1428", "type":"resource", "data":[64, 0, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1428}]], "children":[{"name":"32-bit Integer Add", "type":"resource", "count":2, "data":[64, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1430", "type":"resource", "data":[0.333333, 0, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1430}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1431", "type":"resource", "data":[37, 7, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1431}]], "children":[{"name":"16-bit Integer Add", "type":"resource", "count":1, "data":[16, 0, 0, 0, 0]}, {"name":"9-bit Integer Add", "type":"resource", "count":1, "data":[9, 0, 0, 0, 0]}, {"name":"9-bit Integer Compare", "type":"resource", "count":1, "data":[3, 0, 0, 0, 0]}, {"name":"Iteration Initiation", "type":"resource", "count":1, "data":[9, 7, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1440", "type":"resource", "data":[252, 246, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1440}]], "children":[{"name":"64-bit Integer Add", "type":"resource", "count":6, "data":[252, 246, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1443", "type":"resource", "data":[6.33333, 1, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1443}]], "children":[{"name":"1-bit And", "type":"resource", "count":2, "data":[1.33333, 1, 0, 0, 0]}, {"name":"16-bit Integer Compare", "type":"resource", "count":1, "data":[5, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1444", "type":"resource", "data":[1938.68, 1611.67, 0, 0, 48], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1444}]], "children":[{"name":"1-bit Or", "type":"resource", "count":216, "data":[72, 33, 0, 0, 0]}, {"name":"8-bit Select", "type":"resource", "count":1, "data":[2.66667, 2.66667, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":8, "data":[1864, 1576, 0, 0, 48], "details":[{"type":"text", "text":"Load uses a Local-pipelined LSU"}, {"type":"brief", "text":"Local-pipelined LSU"}]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1453 > \\nimg_filter_core.h:54", "type":"resource", "data":[992.5, 879, 0, 0, 16], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1453}, {"filename":"./img_filter_core.h", "line":54}]], "children":[{"name":"1-bit Or", "type":"resource", "count":9, "data":[4.5, 3, 0, 0, 0]}, {"name":"Load", "type":"resource", "count":4, "data":[988, 876, 0, 0, 16], "details":[{"type":"text", "text":"Load uses a Local-pipelined LSU"}, {"type":"brief", "text":"Local-pipelined LSU"}, {"type":"text", "text":"Stallable read from memory declared on %L.", "links":[{"filename":"./img_filter_core.h", "line":"1421"}]}]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1456 > \\nimg_filter_core.h:131", "type":"resource", "data":[350.5, 1108, 0, 0, 16], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1456}, {"filename":"./img_filter_core.h", "line":131}]], "children":[{"name":"1-bit Or", "type":"resource", "count":15, "data":[10.5, 4, 0, 0, 0]}, {"name":"Store", "type":"resource", "count":4, "data":[340, 1104, 0, 0, 16], "details":[{"type":"text", "text":"Store uses a Local-pipelined LSU"}, {"type":"brief", "text":"Local-pipelined LSU"}, {"type":"text", "text":"Stallable write to memory declared on %L.", "links":[{"filename":"./img_filter_core.h", "line":"1421"}]}]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1459 > \\nimg_filter_core.h:490 > img_filter_core.h:256", "type":"resource", "data":[32, 0, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1459}, {"filename":"./img_filter_core.h", "line":490}, {"filename":"./img_filter_core.h", "line":256}]], "children":[{"name":"8-bit Select", "type":"resource", "count":8, "data":[32, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1459 > \\nimg_filter_core.h:490 > img_filter_core.h:271", "type":"resource", "data":[46.6667, 34.6667, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1459}, {"filename":"./img_filter_core.h", "line":490}, {"filename":"./img_filter_core.h", "line":271}]], "children":[{"name":"8-bit Select", "type":"resource", "count":8, "data":[46.6667, 34.6667, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1459 > \\nimg_filter_core.h:493 > img_filter_core.h:304", "type":"resource", "data":[21, 16, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1459}, {"filename":"./img_filter_core.h", "line":493}, {"filename":"./img_filter_core.h", "line":304}]], "children":[{"name":"16-bit Integer Compare", "type":"resource", "count":1, "data":[5, 0, 0, 0, 0]}, {"name":"8-bit Select", "type":"resource", "count":2, "data":[16, 16, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1459 > \\nimg_filter_core.h:493 > img_filter_core.h:305", "type":"resource", "data":[4, 0, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1459}, {"filename":"./img_filter_core.h", "line":493}, {"filename":"./img_filter_core.h", "line":305}]], "children":[{"name":"8-bit Select", "type":"resource", "count":1, "data":[4, 0, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1459 > \\nimg_filter_core.h:493 > img_filter_core.h:307", "type":"resource", "data":[2.66667, 2.66667, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1459}, {"filename":"./img_filter_core.h", "line":493}, {"filename":"./img_filter_core.h", "line":307}]], "children":[{"name":"8-bit Select", "type":"resource", "count":1, "data":[2.66667, 2.66667, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1459 > \\nimg_filter_core.h:493 > img_filter_core.h:313", "type":"resource", "data":[99.3333, 65, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1459}, {"filename":"./img_filter_core.h", "line":493}, {"filename":"./img_filter_core.h", "line":313}]], "children":[{"name":"1-bit And", "type":"resource", "count":1, "data":[0.333333, 0, 0, 0, 0]}, {"name":"16-bit Integer Compare", "type":"resource", "count":1, "data":[19, 1, 0, 0, 0]}, {"name":"8-bit Select", "type":"resource", "count":12, "data":[80, 64, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1459 > \\nimg_filter_core.h:493 > img_filter_core.h:316", "type":"resource", "data":[76, 64, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1459}, {"filename":"./img_filter_core.h", "line":493}, {"filename":"./img_filter_core.h", "line":316}]], "children":[{"name":"8-bit Select", "type":"resource", "count":11, "data":[76, 64, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1192 > img_filter_core.h:946", "type":"resource", "data":[145, 137, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1462}, {"filename":"./img_filter_core.h", "line":1192}, {"filename":"./img_filter_core.h", "line":946}]], "children":[{"name":"64-bit Integer Add", "type":"resource", "count":8, "data":[145, 137, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1192 > img_filter_core.h:947", "type":"resource", "data":[544, 536, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1462}, {"filename":"./img_filter_core.h", "line":1192}, {"filename":"./img_filter_core.h", "line":947}]], "children":[{"name":"64-bit Integer Subtract", "type":"resource", "count":8, "data":[544, 536, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1192 > img_filter_core.h:948", "type":"resource", "data":[544, 536, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1462}, {"filename":"./img_filter_core.h", "line":1192}, {"filename":"./img_filter_core.h", "line":948}]], "children":[{"name":"64-bit Integer Subtract", "type":"resource", "count":8, "data":[544, 536, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1192 > img_filter_core.h:951", "type":"resource", "data":[544, 536, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1462}, {"filename":"./img_filter_core.h", "line":1192}, {"filename":"./img_filter_core.h", "line":951}]], "children":[{"name":"64-bit Integer Subtract", "type":"resource", "count":8, "data":[544, 536, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1192 > img_filter_core.h:956", "type":"resource", "data":[543.5, 535.5, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1462}, {"filename":"./img_filter_core.h", "line":1192}, {"filename":"./img_filter_core.h", "line":956}]], "children":[{"name":"64-bit Integer Add", "type":"resource", "count":9, "data":[543.5, 535.5, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1192 > img_filter_core.h:962", "type":"resource", "data":[135.5, 133.5, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1462}, {"filename":"./img_filter_core.h", "line":1192}, {"filename":"./img_filter_core.h", "line":962}]], "children":[{"name":"64-bit Integer Add", "type":"resource", "count":3, "data":[135.5, 133.5, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1195 > img_filter_core.h:1005", "type":"resource", "data":[145, 137, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1462}, {"filename":"./img_filter_core.h", "line":1195}, {"filename":"./img_filter_core.h", "line":1005}]], "children":[{"name":"64-bit Integer Add", "type":"resource", "count":8, "data":[145, 137, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1195 > img_filter_core.h:1006", "type":"resource", "data":[544, 536, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1462}, {"filename":"./img_filter_core.h", "line":1195}, {"filename":"./img_filter_core.h", "line":1006}]], "children":[{"name":"64-bit Integer Subtract", "type":"resource", "count":8, "data":[544, 536, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1195 > img_filter_core.h:1007", "type":"resource", "data":[544, 536, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1462}, {"filename":"./img_filter_core.h", "line":1195}, {"filename":"./img_filter_core.h", "line":1007}]], "children":[{"name":"64-bit Integer Subtract", "type":"resource", "count":8, "data":[544, 536, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1195 > img_filter_core.h:1010", "type":"resource", "data":[544, 536, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1462}, {"filename":"./img_filter_core.h", "line":1195}, {"filename":"./img_filter_core.h", "line":1010}]], "children":[{"name":"64-bit Integer Subtract", "type":"resource", "count":8, "data":[544, 536, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1195 > img_filter_core.h:1015", "type":"resource", "data":[543, 535, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1462}, {"filename":"./img_filter_core.h", "line":1195}, {"filename":"./img_filter_core.h", "line":1015}]], "children":[{"name":"64-bit Integer Add", "type":"resource", "count":9, "data":[543, 535, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1195 > img_filter_core.h:1021", "type":"resource", "data":[135, 133, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1462}, {"filename":"./img_filter_core.h", "line":1195}, {"filename":"./img_filter_core.h", "line":1021}]], "children":[{"name":"64-bit Integer Add", "type":"resource", "count":3, "data":[135, 133, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1216", "type":"resource", "data":[250, 245, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1462}, {"filename":"./img_filter_core.h", "line":1216}]], "children":[{"name":"64-bit Integer Add", "type":"resource", "count":6, "data":[250, 245, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1465", "type":"resource", "data":[1, 1, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1465}]], "children":[{"name":"1-bit Or", "type":"resource", "count":1, "data":[1, 1, 0, 0, 0]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1467", "type":"resource", "data":[1409.51, 1810, 0, 0, 32], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1467}]], "children":[{"name":"1-bit Or", "type":"resource", "count":267, "data":[97.5001, 42, 0, 0, 0]}, {"name":"Store", "type":"resource", "count":8, "data":[1312, 1768, 0, 0, 32], "details":[{"type":"text", "text":"Store uses a Local-pipelined LSU"}, {"type":"brief", "text":"Local-pipelined LSU"}]}], "replace_name":"true"}, {"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1469", "type":"resource", "data":[1433.51, 1810, 0, 0, 32], "debug":[[{"filename":"./img_filter_base.h", "line":200}, {"filename":"./img_filter_core.h", "line":1894}, {"filename":"./img_filter_core.h", "line":1512}, {"filename":"./img_filter_core.h", "line":1469}]], "children":[{"name":"1-bit Or", "type":"resource", "count":267, "data":[97.5001, 42, 0, 0, 0]}, {"name":"Store", "type":"resource", "count":8, "data":[1336, 1768, 0, 0, 32], "details":[{"type":"text", "text":"Store uses a Local-pipelined LSU"}, {"type":"brief", "text":"Local-pipelined LSU"}]}], "replace_name":"true"}]}]}, {"name":"ImgSobel.B5", "type":"basicblock", "children":[{"name":"Feedback", "type":"resource", "data":[5, 8, 0, 0, 0], "details":[{"type":"brief", "text":"Loop-carried dependencies"}, {"type":"text", "text":"Resources for loop-carried dependencies. To reduce this area:", "details":[{"type":"text", "text":"reduce number and size of loop-carried variables"}]}], "children":[{"name":"No Source Line", "type":"resource", "data":[5, 8, 0, 0, 0]}]}, {"name":"Computation", "type":"resource", "children":[{"name":"img_filter_base.h:201", "type":"resource", "data":[3, 2, 0, 0, 0], "debug":[[{"filename":"./img_filter_base.h", "line":201}]], "children":[{"name":"Stream Write", "type":"resource", "count":1, "data":[3, 2, 0, 0, 0]}], "replace_name":"true"}]}]}]}]}';
var area_srcJSON='{"children":[{"children":[{"data":[2691,3458,54,0,136],"details":[{"text":"Feedback+Cluster logic","type":"brief"}],"name":"Data control overhead","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 192 bits wide with a buffer size of 0 elements.","type":"text"},{"text":"192b wide with 0 elements.","type":"brief"}],"name":"Component call","type":"resource"},{"data":[0,0,0,0,0],"details":[{"text":"Stream implemented 1 bit wide with a buffer size of 0 elements.","type":"text"},{"text":"1b wide with 0 elements.","type":"brief"}],"name":"Component return","type":"resource"},{"data":[0,0,1,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 and depth 114 (depth was increased by a factor of 114 due to a loop initiation interval of 114.)","type":"text"},{"text":"Register,\\n1 reg, 32 width by 114 depth","type":"brief"}],"name":"Variable: \\n - \'ptr_dst\' (img_filter_core.h:1428)","type":"resource"},{"data":[0,0,1,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 32 and depth 114 (depth was increased by a factor of 114 due to a loop initiation interval of 114.)","type":"text"},{"text":"Register,\\n1 reg, 32 width by 114 depth","type":"brief"}],"name":"Variable: \\n - \'ptr_src\' (img_filter_core.h:1428)","type":"resource"},{"data":[56,72,27,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"3 registers of width 8 and depth 114 (depth was increased by a factor of 114 due to a loop initiation interval of 114.)","type":"text"},{"text":"16 registers of width 8 and depth 115 (depth was increased by a factor of 114 due to a loop initiation interval of 114.)","type":"text"},{"text":"8 registers of width 8 and depth 117 (depth was increased by a factor of 114 due to a loop initiation interval of 114.)","type":"text"},{"text":"Register,\\n3 regs, 8 width by 114 depth,\\n16 regs, 8 width by 115 depth","type":"brief"}],"name":"Variable: \\n - \'window\' (img_filter_core.h:1424)","type":"resource"},{"data":[8,10,2,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 9 and depth 117 (depth was increased by a factor of 114 due to a loop initiation interval of 114.)","type":"text"},{"text":"1 register of width 16 and depth 114 (depth was increased by a factor of 114 due to a loop initiation interval of 114.)","type":"text"},{"text":"Register,\\n1 reg, 9 width by 117 depth,\\n1 reg, 16 width by 114 depth","type":"brief"}],"name":"Variable: \\n - \'x\' (img_filter_core.h:1431)","type":"resource"},{"data":[16,56,0,0,0],"details":[{"text":"Type: Register","type":"text"},{"text":"1 register of width 12","type":"text"},{"text":"1 register of width 16","type":"text"},{"text":"Register,\\n1 reg, 12 width,\\n1 reg, 16 width","type":"brief"}],"name":"Variable: \\n - \'y\' (img_filter_core.h:1430)","type":"resource"},{"data":[0,0,8,0,0],"details":[{"Additional information":[{"details":[{"text":"Reduce the number of write accesses or fix banking to make this memory system stall-free. Banking may be improved by using compile-time known indexing on lowest array dimension.","type":"text"}],"text":"Requested size 3840 bytes, implemented size 4096 bytes, <b>stallable</b>, 4 reads and 4 writes. ","type":"text"},{"text":"Banked on bits 2, 3 into 4 separate banks.","type":"text"}],"Bank depth":"256 words","Bank width":"32 bits","Implemented size":"4096 bytes","Memory system":"Potentially inefficient configuration","Number of banks":"4 (banked on bits 2, 3)","Requested size":"3840 bytes","Total replication":1,"type":"table"},{"text":"Potentially inefficient configuration,\\n3840B requested,\\n4096B implemented.","type":"brief"}],"name":"img_filter_core.h:1421 (linebuffer)","type":"resource"},{"children":[{"count":3,"data":[3082,7789,20,0,106],"debug":[[{"filename":"","line":0}]],"name":"State","type":"resource"},{"count":2,"data":[2,0,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"","line":0}]],"name":"1-bit Or","type":"resource"}],"data":[3085,7790,20,0,106],"name":"No Source Line","type":"resource"},{"children":[{"count":1,"data":[0,192,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":197}]],"name":"State","type":"resource"},{"count":1,"data":[1,0,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":197}]],"name":"Stream Read","type":"resource"}],"data":[1,192,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":197}]],"name":"./img_filter_base.h:197","type":"resource"},{"children":[{"children":[{"count":2,"data":[1.333333,0,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[12,0,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200}]],"name":"12-bit Integer Add","type":"resource"},{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200}]],"name":"12-bit Integer Compare","type":"resource"},{"count":1,"data":[16,0,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200}]],"name":"16-bit Integer Add","type":"resource"},{"count":1,"data":[9.5,0.5,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200}]],"name":"16-bit Integer Compare","type":"resource"}],"data":[42.833333,0.5,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1430}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1430","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[14.5,0.5,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200}]],"name":"16-bit Integer Compare","type":"resource"},{"count":2,"data":[1.33333,1,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"1-bit And","type":"resource"}],"data":[15.83333,1.5,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1443}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1443","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[19,1,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200}]],"name":"16-bit Integer Compare","type":"resource"},{"count":8,"data":[32,0,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"8-bit Select","type":"resource"}],"data":[51,1,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1459},{"filename":"./img_filter_core.h","line":490},{"filename":"./img_filter_core.h","line":256}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1459 > \\nimg_filter_core.h:490 > img_filter_core.h:256","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[5,0,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200}]],"name":"16-bit Integer Compare","type":"resource"},{"count":1,"data":[1,1,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"1-bit Or","type":"resource"}],"data":[6,1,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1465}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1465","replace_name":true,"type":"resource"},{"children":[{"count":2,"data":[64,0,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"32-bit Integer Add","type":"resource"}],"data":[64,0,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1428}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1428","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[16,0,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"16-bit Integer Add","type":"resource"},{"count":1,"data":[9,0,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"9-bit Integer Add","type":"resource"},{"count":1,"data":[3,0,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"9-bit Integer Compare","type":"resource"},{"count":1,"data":[9,7,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"Iteration Initiation","type":"resource"}],"data":[37,7,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1431}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1431","replace_name":true,"type":"resource"},{"children":[{"count":6,"data":[252,246,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"64-bit Integer Add","type":"resource"}],"data":[252,246,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1440}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1440","replace_name":true,"type":"resource"},{"children":[{"count":216,"data":[72,33,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"1-bit Or","type":"resource"},{"count":1,"data":[2.66667,2.66667,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"8-bit Select","type":"resource"},{"count":8,"data":[1864,1576,0,0,48],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"Load","type":"resource"}],"data":[1938.68,1611.67,0,0,48],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1444}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1444","replace_name":true,"type":"resource"},{"children":[{"count":9,"data":[4.5,3,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"1-bit Or","type":"resource"},{"count":4,"data":[988,876,0,0,16],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"Load","type":"resource"}],"data":[992.5,879,0,0,16],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1453},{"filename":"./img_filter_core.h","line":54}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1453 > \\nimg_filter_core.h:54","replace_name":true,"type":"resource"},{"children":[{"count":15,"data":[10.5,4,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"1-bit Or","type":"resource"},{"count":4,"data":[340,1104,0,0,16],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"Store","type":"resource"}],"data":[350.5,1108,0,0,16],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1456},{"filename":"./img_filter_core.h","line":131}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1456 > \\nimg_filter_core.h:131","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[46.6667,34.6667,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"8-bit Select","type":"resource"}],"data":[46.6667,34.6667,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1459},{"filename":"./img_filter_core.h","line":490},{"filename":"./img_filter_core.h","line":271}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1459 > \\nimg_filter_core.h:490 > img_filter_core.h:271","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[5,0,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"16-bit Integer Compare","type":"resource"},{"count":2,"data":[16,16,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"8-bit Select","type":"resource"}],"data":[21,16,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1459},{"filename":"./img_filter_core.h","line":493},{"filename":"./img_filter_core.h","line":304}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1459 > \\nimg_filter_core.h:493 > img_filter_core.h:304","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[4,0,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"8-bit Select","type":"resource"}],"data":[4,0,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1459},{"filename":"./img_filter_core.h","line":493},{"filename":"./img_filter_core.h","line":305}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1459 > \\nimg_filter_core.h:493 > img_filter_core.h:305","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[2.66667,2.66667,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"8-bit Select","type":"resource"}],"data":[2.66667,2.66667,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1459},{"filename":"./img_filter_core.h","line":493},{"filename":"./img_filter_core.h","line":307}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1459 > \\nimg_filter_core.h:493 > img_filter_core.h:307","replace_name":true,"type":"resource"},{"children":[{"count":1,"data":[0.333333,0,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"1-bit And","type":"resource"},{"count":1,"data":[19,1,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"16-bit Integer Compare","type":"resource"},{"count":12,"data":[80,64,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"8-bit Select","type":"resource"}],"data":[99.3333,65,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1459},{"filename":"./img_filter_core.h","line":493},{"filename":"./img_filter_core.h","line":313}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1459 > \\nimg_filter_core.h:493 > img_filter_core.h:313","replace_name":true,"type":"resource"},{"children":[{"count":11,"data":[76,64,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"8-bit Select","type":"resource"}],"data":[76,64,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1459},{"filename":"./img_filter_core.h","line":493},{"filename":"./img_filter_core.h","line":316}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1459 > \\nimg_filter_core.h:493 > img_filter_core.h:316","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[145,137,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"64-bit Integer Add","type":"resource"}],"data":[145,137,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1462},{"filename":"./img_filter_core.h","line":1192},{"filename":"./img_filter_core.h","line":946}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1192 > img_filter_core.h:946","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[544,536,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"64-bit Integer Subtract","type":"resource"}],"data":[544,536,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1462},{"filename":"./img_filter_core.h","line":1192},{"filename":"./img_filter_core.h","line":947}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1192 > img_filter_core.h:947","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[544,536,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"64-bit Integer Subtract","type":"resource"}],"data":[544,536,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1462},{"filename":"./img_filter_core.h","line":1192},{"filename":"./img_filter_core.h","line":948}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1192 > img_filter_core.h:948","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[544,536,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"64-bit Integer Subtract","type":"resource"}],"data":[544,536,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1462},{"filename":"./img_filter_core.h","line":1192},{"filename":"./img_filter_core.h","line":951}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1192 > img_filter_core.h:951","replace_name":true,"type":"resource"},{"children":[{"count":9,"data":[543.5,535.5,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"64-bit Integer Add","type":"resource"}],"data":[543.5,535.5,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1462},{"filename":"./img_filter_core.h","line":1192},{"filename":"./img_filter_core.h","line":956}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1192 > img_filter_core.h:956","replace_name":true,"type":"resource"},{"children":[{"count":3,"data":[135.5,133.5,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"64-bit Integer Add","type":"resource"}],"data":[135.5,133.5,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1462},{"filename":"./img_filter_core.h","line":1192},{"filename":"./img_filter_core.h","line":962}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1192 > img_filter_core.h:962","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[145,137,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"64-bit Integer Add","type":"resource"}],"data":[145,137,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1462},{"filename":"./img_filter_core.h","line":1195},{"filename":"./img_filter_core.h","line":1005}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1195 > img_filter_core.h:1005","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[544,536,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"64-bit Integer Subtract","type":"resource"}],"data":[544,536,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1462},{"filename":"./img_filter_core.h","line":1195},{"filename":"./img_filter_core.h","line":1006}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1195 > img_filter_core.h:1006","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[544,536,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"64-bit Integer Subtract","type":"resource"}],"data":[544,536,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1462},{"filename":"./img_filter_core.h","line":1195},{"filename":"./img_filter_core.h","line":1007}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1195 > img_filter_core.h:1007","replace_name":true,"type":"resource"},{"children":[{"count":8,"data":[544,536,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"64-bit Integer Subtract","type":"resource"}],"data":[544,536,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1462},{"filename":"./img_filter_core.h","line":1195},{"filename":"./img_filter_core.h","line":1010}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1195 > img_filter_core.h:1010","replace_name":true,"type":"resource"},{"children":[{"count":9,"data":[543,535,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"64-bit Integer Add","type":"resource"}],"data":[543,535,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1462},{"filename":"./img_filter_core.h","line":1195},{"filename":"./img_filter_core.h","line":1015}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1195 > img_filter_core.h:1015","replace_name":true,"type":"resource"},{"children":[{"count":3,"data":[135,133,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"64-bit Integer Add","type":"resource"}],"data":[135,133,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1462},{"filename":"./img_filter_core.h","line":1195},{"filename":"./img_filter_core.h","line":1021}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1195 > img_filter_core.h:1021","replace_name":true,"type":"resource"},{"children":[{"count":6,"data":[250,245,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"64-bit Integer Add","type":"resource"}],"data":[250,245,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1462},{"filename":"./img_filter_core.h","line":1216}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1462 > \\nimg_filter_core.h:1216","replace_name":true,"type":"resource"},{"children":[{"count":267,"data":[97.5001,42,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"1-bit Or","type":"resource"},{"count":8,"data":[1312,1768,0,0,32],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"Store","type":"resource"}],"data":[1409.51,1810,0,0,32],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1467}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1467","replace_name":true,"type":"resource"},{"children":[{"count":267,"data":[97.5001,42,0,0,0],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"1-bit Or","type":"resource"},{"count":8,"data":[1336,1768,0,0,32],"debug":[[{"filename":"img_filter_base.h","line":200}]],"name":"Store","type":"resource"}],"data":[1433.51,1810,0,0,32],"debug":[[{"filename":"./img_filter_base.h","line":200},{"filename":"./img_filter_core.h","line":1894},{"filename":"./img_filter_core.h","line":1512},{"filename":"./img_filter_core.h","line":1469}]],"name":"img_filter_base.h:200 > img_filter_core.h:1894 > \\nimg_filter_core.h:1512 > img_filter_core.h:1469","replace_name":true,"type":"resource"}],"data":[12004.033333,12730.00337,0,0,144],"debug":[[{"filename":"./img_filter_base.h","line":200}]],"name":"./img_filter_base.h:200","replace_name":"true","type":"resource"},{"children":[{"count":1,"data":[3,2,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":201}]],"name":"Stream Write","type":"resource"}],"data":[3,2,0,0,0],"debug":[[{"filename":"./img_filter_base.h","line":201}]],"name":"./img_filter_base.h:201","replace_name":"true","type":"resource"}],"compute_units":1,"data":[17864.033333,24310.00337,113,0,386],"debug":[[{"filename":"./img_filter_core.h","line":1421}]],"details":[{"text":"Number of compute units: 1","type":"text"},{"text":"1 compute unit.","type":"brief"}],"name":"ImgSobel","total_kernel_resources":[17864,24310,113,0,386],"total_percent":[1.87073,1.37088,0.65131,0.964082,0],"type":"function"}],"columns":["","ALUTs","FFs","RAMs","DSPs","MLABs","Details"],"data":[17864.033333,24310.00337,113,0,386],"debug_enabled":"true","max_resources":[1866240,3732480,11721,5760,93312],"name":"System","total":[17864,24310,113,0,386],"total_percent":[1.87073,1.37088,0.65131,0.964082,0],"type":"module"}';
var mavJSON='{"nodes":[{"type":"component", "id":2, "name":"ImgSobel", "children":[{"type":"bb", "id":3, "name":"ImgSobel.B0.runOnce", "details":[{"type":"table", "Latency":"2"}]}, {"type":"bb", "id":4, "name":"ImgSobel.B1.start", "children":[{"type":"inst", "id":9, "name":"Stream Read", "debug":[[{"filename":"./img_filter_base.h", "line":197}]], "details":[{"type":"table", "Width":"192 bits", "Depth":"0", "Stall-free":"No", "Start Cycle":"11", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":45, "name":"Loop Input", "debug":[[{"filename":"", "line":0}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"50"}]}, {"type":"inst", "id":46, "name":"End", "details":[{"type":"table", "Start Cycle":"18", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"18", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. "}]}, {"type":"bb", "id":5, "name":"ImgSobel.B2", "details":[{"type":"table", "Latency":"11", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Entry to loop. ", "Loops To":"6"}]}, {"type":"bb", "id":6, "name":"ImgSobel.B3", "details":[{"type":"table", "Latency":"0", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"bb", "id":7, "name":"ImgSobel.B4", "children":[{"type":"inst", "id":11, "name":"Load", "debug":[[{"filename":"./img_filter_core.h", "line":54}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"linebuffer", "Start Cycle":"13", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":12, "name":"Load", "debug":[[{"filename":"./img_filter_core.h", "line":54}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"linebuffer", "Start Cycle":"13", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":13, "name":"Load", "debug":[[{"filename":"./img_filter_core.h", "line":54}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"linebuffer", "Start Cycle":"13", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":14, "name":"Load", "debug":[[{"filename":"./img_filter_core.h", "line":54}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"linebuffer", "Start Cycle":"13", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":15, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":131}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Local-pipelined", "Stall-free":"No", "Stores to":"linebuffer", "Start Cycle":"53", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":16, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":131}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Local-pipelined", "Stall-free":"No", "Stores to":"linebuffer", "Start Cycle":"53", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":17, "name":"Load", "debug":[[{"filename":"./img_filter_core.h", "line":1444}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"input0", "Start Cycle":"25", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":18, "name":"Load", "debug":[[{"filename":"./img_filter_core.h", "line":1444}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"input0", "Start Cycle":"25", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":19, "name":"Load", "debug":[[{"filename":"./img_filter_core.h", "line":1444}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"input0", "Start Cycle":"25", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":20, "name":"Load", "debug":[[{"filename":"./img_filter_core.h", "line":1444}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"input0", "Start Cycle":"25", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":21, "name":"Load", "debug":[[{"filename":"./img_filter_core.h", "line":1444}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"input0", "Start Cycle":"25", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":22, "name":"Load", "debug":[[{"filename":"./img_filter_core.h", "line":1444}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"input0", "Start Cycle":"25", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":23, "name":"Load", "debug":[[{"filename":"./img_filter_core.h", "line":1444}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"input0", "Start Cycle":"25", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":24, "name":"Load", "debug":[[{"filename":"./img_filter_core.h", "line":1444}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Loads from":"input0", "Start Cycle":"25", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":25, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":131}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Local-pipelined", "Stall-free":"No", "Stores to":"linebuffer", "Start Cycle":"63", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":26, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":131}]], "details":[{"type":"table", "Width":"32 bits", "Type":"Local-pipelined", "Stall-free":"No", "Stores to":"linebuffer", "Start Cycle":"63", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":27, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":1467}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Start Cycle":"74", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":28, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":1467}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Start Cycle":"74", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":29, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":1467}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Start Cycle":"74", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":30, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":1467}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Start Cycle":"74", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":31, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":1467}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Start Cycle":"74", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":32, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":1467}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Start Cycle":"74", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":33, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":1467}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Start Cycle":"74", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":34, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":1467}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Start Cycle":"74", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":35, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":1469}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Start Cycle":"106", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":36, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":1469}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Start Cycle":"106", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":37, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":1469}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Start Cycle":"106", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":38, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":1469}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Start Cycle":"106", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":39, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":1469}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Start Cycle":"106", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":40, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":1469}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Start Cycle":"106", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":41, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":1469}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Start Cycle":"106", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":42, "name":"Store", "debug":[[{"filename":"./img_filter_core.h", "line":1469}]], "details":[{"type":"table", "Width":"8 bits", "Type":"Local-pipelined", "Stall-free":"No", "Start Cycle":"106", "Latency":"31", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":47, "name":"Loop Input", "debug":[[{"filename":"./img_filter_core.h", "line":1431}]], "details":[{"type":"table", "Start Cycle":"0", "Latency":"1", "Loops To":"48"}]}, {"type":"inst", "id":48, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"137", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"137", "II":"114", "Subloops":"No", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Loop is pipelined with II of 114. See Loops Analysis for more information."}]}, {"type":"bb", "id":8, "name":"ImgSobel.B5", "children":[{"type":"inst", "id":43, "name":"Stream Write", "debug":[[{"filename":"./img_filter_base.h", "line":201}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Stall-free":"No", "Start Cycle":"0", "Latency":"0", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html"}]}]}]}, {"type":"inst", "id":49, "name":"Begin", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}, {"type":"inst", "id":50, "name":"Loop End", "details":[{"type":"table", "Start Cycle":"0", "Latency":"1"}]}], "details":[{"type":"table", "Latency":"0", "II":"1", "Subloops":"Yes", "Pipelined":"Yes", "Fmax Bottlenecks":"No", "Loop Info":"Exit which branches back to loop. "}]}, {"type":"memtype", "id":54, "name":"Local Memory", "children":[{"type":"memsys", "id":55, "name":"linebuffer", "debug":[[{"filename":"./img_filter_core.h", "line":1421}]], "details":[{"type":"table", "details":[{"type":"brief", "text":"3840B requested\\n4096B implemented"}], "Requested size":"3840 bytes", "Implemented size":"4096 bytes", "Number of banks":"4", "Bank width":"32 bits", "Bank depth":"256 words", "Total replication":"1", "Reference":[{"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Local Variables in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#xzx1468871996419"}]}]}]}]}]}, {"type":"memtype", "id":1, "name":"System Memory", "children":[{"type":"memsys", "id":76, "name":"0", "details":[{"type":"table", "Number of banks":"1", "Arguments from ImgSobel":"input0, output1, output2"}]}]}, {"type":"stream", "id":10, "name":"do.ImgSobel", "debug":[[{"filename":"./img_filter_base.h", "line":197}]], "details":[{"type":"table", "Width":"192 bits", "Depth":"0", "Bits per symbol":"192 bits", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Valid":"Yes", "Ready Latency":"0"}]}, {"type":"stream", "id":44, "name":"return.ImgSobel", "debug":[[{"filename":"./img_filter_base.h", "line":197}]], "details":[{"type":"table", "Width":"1 bit", "Depth":"0", "Bits per symbol":"1 bit", "Uses Packets":"No", "Uses Empty":"No", "First symbol in high order bits":"No", "Uses Ready":"Yes", "Ready Latency":"0"}]}, {"type":"interface", "id":51, "name":"input0", "debug":[[{"filename":"./img_filter_base.h", "line":197}]], "details":[{"type":"table", "Stable":"No", "Data width":"64", "Address width":"64", "Address Space":"0", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"ImgSobel"}]}, {"type":"interface", "id":52, "name":"output1", "debug":[[{"filename":"./img_filter_base.h", "line":197}]], "details":[{"type":"table", "Stable":"No", "Data width":"64", "Address width":"64", "Address Space":"0", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"ImgSobel"}]}, {"type":"interface", "id":53, "name":"output2", "debug":[[{"filename":"./img_filter_base.h", "line":197}]], "details":[{"type":"table", "Stable":"No", "Data width":"64", "Address width":"64", "Address Space":"0", "Latency":"1", "ReadWrite Mode":"readwrite", "Maximum burst":"1", "Wait request":"0", "Alignment":"0", "Component":"ImgSobel"}]}], "links":[{"from":10, "to":9}, {"from":43, "to":44}, {"from":51, "to":9}, {"from":52, "to":9}, {"from":53, "to":9}, {"from":55, "to":11}, {"from":55, "to":13}, {"from":15, "to":55}, {"from":25, "to":55}, {"from":55, "to":12}, {"from":55, "to":14}, {"from":16, "to":55}, {"from":26, "to":55}, {"from":50, "to":45}, {"from":3, "to":45}, {"from":9, "to":46}, {"from":6, "to":5}, {"from":46, "to":5}, {"from":48, "to":6}, {"from":48, "to":47}, {"from":5, "to":47}, {"from":17, "to":48}, {"from":15, "to":48}, {"from":16, "to":48}, {"from":25, "to":48}, {"from":26, "to":48}, {"from":35, "to":48}, {"from":36, "to":48}, {"from":37, "to":48}, {"from":38, "to":48}, {"from":39, "to":48}, {"from":40, "to":48}, {"from":41, "to":48}, {"from":42, "to":48}, {"from":11, "to":48}, {"from":12, "to":48}, {"from":13, "to":48}, {"from":14, "to":48}, {"from":18, "to":48}, {"from":19, "to":48}, {"from":20, "to":48}, {"from":21, "to":48}, {"from":22, "to":48}, {"from":23, "to":48}, {"from":24, "to":48}, {"from":27, "to":48}, {"from":28, "to":48}, {"from":29, "to":48}, {"from":30, "to":48}, {"from":31, "to":48}, {"from":32, "to":48}, {"from":33, "to":48}, {"from":34, "to":48}, {"from":6, "to":49}, {"from":43, "to":50}, {"from":45, "to":9}, {"from":47, "to":11}, {"from":47, "to":12}, {"from":47, "to":13}, {"from":47, "to":14}, {"from":13, "to":15}, {"from":11, "to":15}, {"from":12, "to":15}, {"from":14, "to":15}, {"from":14, "to":16}, {"from":11, "to":16}, {"from":12, "to":16}, {"from":13, "to":16}, {"from":47, "to":17}, {"from":47, "to":18}, {"from":47, "to":19}, {"from":47, "to":20}, {"from":47, "to":21}, {"from":47, "to":22}, {"from":47, "to":23}, {"from":47, "to":24}, {"from":11, "to":25}, {"from":12, "to":25}, {"from":13, "to":25}, {"from":14, "to":25}, {"from":17, "to":25}, {"from":18, "to":25}, {"from":19, "to":25}, {"from":20, "to":25}, {"from":14, "to":26}, {"from":21, "to":26}, {"from":22, "to":26}, {"from":23, "to":26}, {"from":24, "to":26}, {"from":12, "to":27}, {"from":13, "to":27}, {"from":14, "to":27}, {"from":11, "to":27}, {"from":17, "to":27}, {"from":18, "to":27}, {"from":19, "to":27}, {"from":20, "to":27}, {"from":21, "to":27}, {"from":22, "to":27}, {"from":23, "to":27}, {"from":24, "to":27}, {"from":12, "to":28}, {"from":13, "to":28}, {"from":14, "to":28}, {"from":11, "to":28}, {"from":17, "to":28}, {"from":18, "to":28}, {"from":19, "to":28}, {"from":20, "to":28}, {"from":21, "to":28}, {"from":22, "to":28}, {"from":23, "to":28}, {"from":24, "to":28}, {"from":12, "to":29}, {"from":13, "to":29}, {"from":14, "to":29}, {"from":11, "to":29}, {"from":17, "to":29}, {"from":18, "to":29}, {"from":19, "to":29}, {"from":20, "to":29}, {"from":21, "to":29}, {"from":22, "to":29}, {"from":23, "to":29}, {"from":24, "to":29}, {"from":12, "to":30}, {"from":13, "to":30}, {"from":14, "to":30}, {"from":11, "to":30}, {"from":17, "to":30}, {"from":18, "to":30}, {"from":19, "to":30}, {"from":20, "to":30}, {"from":21, "to":30}, {"from":22, "to":30}, {"from":23, "to":30}, {"from":24, "to":30}, {"from":12, "to":31}, {"from":13, "to":31}, {"from":14, "to":31}, {"from":11, "to":31}, {"from":17, "to":31}, {"from":18, "to":31}, {"from":19, "to":31}, {"from":20, "to":31}, {"from":21, "to":31}, {"from":22, "to":31}, {"from":23, "to":31}, {"from":24, "to":31}, {"from":12, "to":32}, {"from":13, "to":32}, {"from":14, "to":32}, {"from":11, "to":32}, {"from":17, "to":32}, {"from":18, "to":32}, {"from":19, "to":32}, {"from":20, "to":32}, {"from":21, "to":32}, {"from":22, "to":32}, {"from":23, "to":32}, {"from":24, "to":32}, {"from":12, "to":33}, {"from":13, "to":33}, {"from":14, "to":33}, {"from":11, "to":33}, {"from":17, "to":33}, {"from":18, "to":33}, {"from":19, "to":33}, {"from":20, "to":33}, {"from":21, "to":33}, {"from":22, "to":33}, {"from":23, "to":33}, {"from":24, "to":33}, {"from":12, "to":34}, {"from":13, "to":34}, {"from":14, "to":34}, {"from":11, "to":34}, {"from":17, "to":34}, {"from":18, "to":34}, {"from":19, "to":34}, {"from":20, "to":34}, {"from":21, "to":34}, {"from":22, "to":34}, {"from":23, "to":34}, {"from":24, "to":34}, {"from":12, "to":35}, {"from":13, "to":35}, {"from":14, "to":35}, {"from":11, "to":35}, {"from":17, "to":35}, {"from":27, "to":35}, {"from":31, "to":35}, {"from":32, "to":35}, {"from":33, "to":35}, {"from":34, "to":35}, {"from":29, "to":35}, {"from":30, "to":35}, {"from":28, "to":35}, {"from":12, "to":36}, {"from":13, "to":36}, {"from":14, "to":36}, {"from":11, "to":36}, {"from":17, "to":36}, {"from":27, "to":36}, {"from":31, "to":36}, {"from":32, "to":36}, {"from":33, "to":36}, {"from":34, "to":36}, {"from":29, "to":36}, {"from":30, "to":36}, {"from":28, "to":36}, {"from":12, "to":37}, {"from":13, "to":37}, {"from":14, "to":37}, {"from":11, "to":37}, {"from":17, "to":37}, {"from":27, "to":37}, {"from":31, "to":37}, {"from":32, "to":37}, {"from":33, "to":37}, {"from":34, "to":37}, {"from":29, "to":37}, {"from":30, "to":37}, {"from":28, "to":37}, {"from":12, "to":38}, {"from":13, "to":38}, {"from":14, "to":38}, {"from":11, "to":38}, {"from":17, "to":38}, {"from":27, "to":38}, {"from":31, "to":38}, {"from":32, "to":38}, {"from":33, "to":38}, {"from":34, "to":38}, {"from":29, "to":38}, {"from":30, "to":38}, {"from":28, "to":38}, {"from":12, "to":39}, {"from":13, "to":39}, {"from":14, "to":39}, {"from":11, "to":39}, {"from":17, "to":39}, {"from":27, "to":39}, {"from":31, "to":39}, {"from":32, "to":39}, {"from":33, "to":39}, {"from":34, "to":39}, {"from":29, "to":39}, {"from":30, "to":39}, {"from":28, "to":39}, {"from":12, "to":40}, {"from":13, "to":40}, {"from":14, "to":40}, {"from":11, "to":40}, {"from":17, "to":40}, {"from":27, "to":40}, {"from":31, "to":40}, {"from":32, "to":40}, {"from":33, "to":40}, {"from":34, "to":40}, {"from":29, "to":40}, {"from":30, "to":40}, {"from":28, "to":40}, {"from":12, "to":41}, {"from":13, "to":41}, {"from":14, "to":41}, {"from":11, "to":41}, {"from":17, "to":41}, {"from":27, "to":41}, {"from":31, "to":41}, {"from":32, "to":41}, {"from":33, "to":41}, {"from":34, "to":41}, {"from":29, "to":41}, {"from":30, "to":41}, {"from":28, "to":41}, {"from":12, "to":42}, {"from":13, "to":42}, {"from":14, "to":42}, {"from":11, "to":42}, {"from":17, "to":42}, {"from":27, "to":42}, {"from":31, "to":42}, {"from":32, "to":42}, {"from":33, "to":42}, {"from":34, "to":42}, {"from":29, "to":42}, {"from":30, "to":42}, {"from":28, "to":42}, {"from":49, "to":43}, {"from":76, "to":19}, {"from":76, "to":22}, {"from":36, "to":76}, {"from":33, "to":76}, {"from":39, "to":76}, {"from":27, "to":76}, {"from":28, "to":76}, {"from":41, "to":76}, {"from":76, "to":23}, {"from":38, "to":76}, {"from":76, "to":17}, {"from":76, "to":20}, {"from":30, "to":76}, {"from":29, "to":76}, {"from":76, "to":24}, {"from":35, "to":76}, {"from":32, "to":76}, {"from":40, "to":76}, {"from":76, "to":18}, {"from":31, "to":76}, {"from":76, "to":21}, {"from":34, "to":76}, {"from":37, "to":76}, {"from":42, "to":76}]}';
var loopsJSON='{"columns":["", "Pipelined", "II", "Speculated iterations", "Details"], "children":[{"name":"Component: ImgSobel", "data":["", "", ""], "debug":[[{"filename":"./img_filter_base.h", "line":197}]], "details":[{"type":"brief", "text":"Task function"}, {"type":"text", "text":"Task function"}, {"type":"text", "text":"Fmax bottlenck block: None"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Component", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462820640727"}]}], "children":[{"name":"ImgSobel.B1.start", "data":["Yes", ">=1", "4"], "debug":[[{"filename":"Component invocation", "line":0}]], "details":[{"type":"brief", "text":" "}, {"type":"text", "text":"Hyper-Optimized loop structure: enabled."}, {"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: 1 is the default for component invocation loop"}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[{"name":"ImgSobel.B2", "data":["Yes", ">=1", "4"], "debug":[[{"filename":"./img_filter_core.h", "line":1430}]], "details":[{"type":"brief", "text":"Serial exe: Memory dependency"}, {"type":"text", "text":"User-constrained II."}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"54"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"54"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"54"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"54"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Iteration executed serially across ImgSobel.B4. Only a single loop iteration will execute inside this region due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Hyper-Optimized loop structure: enabled."}, {"type":"text", "text":"Stallable instruction: n/a"}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[{"name":"ImgSobel.B4", "data":["Yes", "~114", "0"], "debug":[[{"filename":"./img_filter_core.h", "line":1431}]], "details":[{"type":"brief", "text":"Memory dependency"}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"54"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"54"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"54"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"54"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"54"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"54"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to memory dependency:", "details":[{"type":"text", "text":"From: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"To: Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Compiler failed to schedule this loop with smaller II due to data dependency on variable(s):", "details":[{"type":"text", "text":"window (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1424"}]}]}, {"type":"text", "text":"Most critical loop feedback path during scheduling:", "details":[{"type":"text", "text":"32.00 clock cycles Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"31.00 clock cycles Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"31.00 clock cycles Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"1.00 clock cycle 64-bit Integer Add Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1440"}]}, {"type":"text", "text":"1.00 clock cycle 8-bit Select Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"304"}]}, {"type":"text", "text":"1.00 clock cycle 64-bit Integer Add Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"946"}]}, {"type":"text", "text":"1.00 clock cycle 64-bit Integer Add Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"946"}]}, {"type":"text", "text":"1.00 clock cycle 8-bit Select Operation (%L, %L, %L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}, {"filename":"./img_filter_core.h", "line":"271"}, {"filename":"./img_filter_core.h", "line":"307"}]}, {"type":"text", "text":"1.00 clock cycle 64-bit Integer Subtract Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"947"}]}, {"type":"text", "text":"1.00 clock cycle 64-bit Integer Add Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"956"}]}, {"type":"text", "text":"1.00 clock cycle 64-bit Integer Subtract Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"948"}]}, {"type":"text", "text":"0.81 clock cycles 1-bit Or Operation (%L, %L, %L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}, {"filename":"./img_filter_core.h", "line":"1467"}, {"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"0.81 clock cycles 1-bit Or Operation (%L, %L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}, {"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"0.81 clock cycles 1-bit Or Operation (%L, %L, %L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}, {"filename":"./img_filter_core.h", "line":"1467"}, {"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"0.81 clock cycles 1-bit Or Operation (%L, %L, %L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}, {"filename":"./img_filter_core.h", "line":"1467"}, {"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"0.81 clock cycles 1-bit Or Operation (%L, %L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}, {"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"0.81 clock cycles 1-bit Or Operation (%L, %L, %L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}, {"filename":"./img_filter_core.h", "line":"1467"}, {"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"0.81 clock cycles 1-bit Or Operation (%L, %L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}, {"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Hyper-Optimized loop structure: disabled."}, {"type":"text", "text":"II is an approximation due to the following stallable instructions:", "details":[{"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"54"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"54"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"54"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"54"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"Load Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1444"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"131"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1467"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}, {"type":"text", "text":"Store Operation (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1469"}]}]}, {"type":"text", "text":"Maximum concurrent iterations: Capacity of loop", "details":[{"type":"text", "text":"Use the %L viewer to estimate capacity", "links":[{"view":"Fmax II Report"}]}]}, {"type":"text", "text":"See %L for more information", "links":[{"guide":"Reference Manual : Loops in Components", "link":"https://www.intel.com/content/www/us/en/programmable/documentation/ewa1462824960255.html#ewa1462826976357"}]}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":53}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":59}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":61}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":70}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":72}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":77}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":109}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":111}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":118}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":121}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":130}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":253}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":255}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":262}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":268}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":270}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":293}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":297}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":303}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":312}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":1165}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":1167}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":580}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":582}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":616}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":618}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":765}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":932}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":991}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":1175}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[{"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":1177}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}]}]}, {"name":"Fully unrolled loop", "data":["n/a", "n/a", "n/a"], "debug":[[{"filename":"./img_filter_core.h", "line":1448}]], "details":[{"type":"brief", "text":"Unrolled by #pragma unroll"}, {"type":"text", "text":"Unrolled by #pragma unroll"}], "children":[]}]}]}]}]}]}';
var summaryJSON='{"performanceSummary":{"name":"Function Summary", "columns":["Function Name", "Hyper-Optimized Handshaking"], "children":[{"name":"ImgSobel", "data":["Off"], "details":[{"type":"text", "text":"Hyper-optimized handshaking disabled due to loop orchestration compiler optimization being disabled in loop ImgSobel.B4."}], "debug":[[{"filename":"./img_filter_base.h", "line":197}]]}]}, "functionNameMapping":{"name":"Synthesized Function Name Mapping", "columns":["User-defined Function Name", "Mapped Function Name"], "children":[{"name":"void ImgSobel<unsigned char, signed char, (unsigned char)8, (unsigned short)1920, (unsigned short)1080, (unsigned char)3, (vx_border_e)49153>(vx_image<unsigned char, (unsigned char)8>*, vx_image<signed char, (unsigned char)8>*, vx_image<signed char, (unsigned char)8>*)", "data":["ImgSobel"], "debug":[[{"filename":"./img_filter_base.h", "line":197}]]}]}, "estimatedResources":{"name":"Estimated Resource Usage", "columns":["Function Name", "ALUTs ", "FFs  ", "RAMs ", "DSPs ", "MLABs"], "children":[{"name":"ImgSobel", "data":[17864, 24310, 113, 0, 386], "debug":[[{"filename":"./img_filter_base.h", "line":197}]]}, {"name":"Total", "classes":["summary-highlight", "nohover"], "data":[17864, 24310, 113, 0, 386], "data_percent":[0.957219, 0.65131, 0.964082, 0]}, {"name":"Available", "classes":["summary-highlight", "nohover"], "data":[1866240, 3732480, 11721, 5760, 0]}]}, "compileWarnings":{"name":"Compile Warnings", "children":[]}}';
var fmax_iiJSON='{"basicblocks":{"ImgSobel.B0.runOnce":{"name":"ImgSobel.B0.runOnce", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":2, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":0, "loop_location":{}}, "ImgSobel.B1.start":{"name":"ImgSobel.B1.start", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":18, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"Yes", "is_single_block_loop":"No", "loop_layer":1, "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"Unknown location", "line":"0"}]}]}}, "ImgSobel.B2":{"name":"ImgSobel.B2", "target_fmax":"Not specified", "target_ii":"1", "achieved_fmax":"480.0", "achieved_ii":1, "latency":11, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"Yes", "is_single_block_loop":"No", "loop_layer":2, "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1430"}]}]}}, "ImgSobel.B3":{"name":"ImgSobel.B3", "target_fmax":"Not specified", "target_ii":"1", "achieved_fmax":"480.0", "achieved_ii":1, "latency":0, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":2, "loop_location":{}}, "ImgSobel.B4":{"name":"ImgSobel.B4", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":114, "latency":137, "max_interleaving":114, "is_fmax_bottleneck":"No", "is_loop_header":"Yes", "is_single_block_loop":"Yes", "loop_layer":3, "loop_location":{"details":[{"type":"text", "text":"Loop:  (%L)", "links":[{"filename":"./img_filter_core.h", "line":"1431"}]}]}}, "ImgSobel.B5":{"name":"ImgSobel.B5", "target_fmax":"Not specified", "target_ii":"Not specified", "achieved_fmax":"480.0", "achieved_ii":1, "latency":0, "max_interleaving":1, "is_fmax_bottleneck":"No", "is_loop_header":"No", "is_single_block_loop":"No", "loop_layer":1, "loop_location":{}}}, "functions":{"ImgSobel":{"debug":[{"filename":"./img_filter_base.h", "line":197}], "loop_hierachy":{"ImgSobel__no_loop":["ImgSobel.B0.runOnce"], "ImgSobel.B1.start":["ImgSobel.B1.start", "ImgSobel.B2", "ImgSobel.B5"], "ImgSobel.B2":["ImgSobel.B2", "ImgSobel.B4", "ImgSobel.B3"], "ImgSobel.B4":["ImgSobel.B4"]}}}}';
var infoJSON='{"name":"Info","rows":[{"classes":["info-table"],"data":["./HFVX_fpga"],"name":"Project Name"},{"data":["Stratix10, 1SG280LU3F50I2VG"],"name":"Target Family, Device"},{"data":["19.1.0 Build 240"],"name":"i++ Version"},{"data":["19.1.0 Build 240 Pro"],"name":"Quartus Version"},{"data":["i++ main.cpp -D Intel -march=Stratix10 --simulator none -v -o HFVX_fpga"],"name":"Command"},{"data":["Fri Nov 29 16:32:01 2019"],"name":"Reports Generated At"}]}';
var warningsJSON='{"rows":[]}';
var quartusJSON='{"quartusFitClockSummary":{"children":[{"details":[{"text":"This section contains a summary of the area and fmax data generated by compiling the components through Quartus. \\nTo generate the data, run a Quartus compile on the project created for this design. To run the Quartus compile:\\n  1) Change to the quartus directory (./HFVX_fpga.prj/quartus)\\n  2) quartus_sh --flow compile quartus_compile\\n","type":"text"}],"name":"Run Quartus compile to populate this section. See details for more information."}],"name":"Quartus Fit Summary"}}';
var fileJSON=[{"path":"/opt/intelFPGA_pro/19.1/hls/include/HLS/internal/_task_FPGA.h", "name":"_task_FPGA.h", "has_active_debug_locs":false, "absName":"/opt/intelFPGA_pro/19.1/hls/include/HLS/internal/_task_FPGA.h", "content":"#ifndef _INTEL_IHC_HLS_INTERNAL__TASK_FPGA\012#define _INTEL_IHC_HLS_INTERNAL__TASK_FPGA\012#include \"HLS/function_traits.h\"\012\012namespace ihc {\012  namespace internal {\012    // The task is a singleton that is shared between\012    // a calculation and its result:\012    // * Identify the functionality\012    //   task<function>::instance()\012    // * Launch the calculations\012    //   task<function>::instance().launch(args...);\012    // * Get the results\012    //   [ret = ]task<function>::instance().collect();\012    //      > blocking until launch is finished\012    //      > returns result for non-void function\012    //\012    // When the main program exits, any pending\012    // launches will still be processed in their\012    // respective thread\012    template<typename X, X& f>\012    class _task {\012    public:\012      // using F: typename X is different between compilers!\012      using F = decltype(f);\012      using T = typename ihc::function_traits<F>::return_type;\012\012      // Constructor\012      _task() {}\012\012      // Disable copy-assignment operator\012      _task& operator=(const _task& rhs) = delete;\012\012      // Disable copy constructor\012      _task(const _task& other) = delete;\012\012      // Destructor \012      // Can't be explicit for FPGA target in Intel(R) HLS Compiler\012      //~_task() {}\012\012      template<typename ... Args>\012      void launch(Args&&... args) {\012        __builtin_intel_hls_enqueue(f, std::forward<Args>(args)...);\012      } // launch\012\012      T collect() {\012        return static_cast<T>(__builtin_intel_hls_get(f));\012      }\012\012    }; // class _task\012\012  } //namespace internal\012} // namespace ihc\012\012#endif // _INTEL_IHC_HLS_INTERNAL__TASK_FPGA\012"}, {"path":"/opt/intelFPGA_pro/19.1/hls/include/HLS/function_traits.h", "name":"function_traits.h", "has_active_debug_locs":false, "absName":"/opt/intelFPGA_pro/19.1/hls/include/HLS/function_traits.h", "content":"#ifndef _INTEL_IHC_HLS_FUNCTION_TRAITS\012#define _INTEL_IHC_HLS_FUNCTION_TRAITS\012\012namespace ihc {\012  // Some metaprogramming to extract the return type\012  // from a function type\012  template<typename F>\012  struct function_traits {\012    using return_type = F;\012  };\012\012  template<typename R, typename... Args>\012  struct function_traits<R(*)(Args...)>\012  {\012    using return_type = R;\012  };\012\012  template<typename R, typename... Args>\012  struct function_traits<R(&)(Args...)>\012  {\012    using return_type = R;\012  };\012}\012\012#endif // _INTEL_IHC_HLS_FUNCTION_TRAITS\012"}, {"path":"/opt/intelFPGA_pro/19.1/hls/include/HLS/hls.h", "name":"hls.h", "has_active_debug_locs":false, "absName":"/opt/intelFPGA_pro/19.1/hls/include/HLS/hls.h", "content":"#ifndef __HLS_H__\012#define __HLS_H__\012\012#ifdef __INTELFPGA_COMPILER__\012   // Compiling for FPGA or x86 using FPGA compiler\012#  undef component\012#  define component __attribute__((ihc_component)) __attribute__((noinline))\012#else\012#  ifndef component\012#    define component\012#  endif\012#  ifndef HLS_X86\012#    define HLS_X86\012#  endif\012#endif\012#include <type_traits>\012#include \"HLS/hls_internal.h\"\012#include \"HLS/task.h\"\012\012#ifdef _MSC_VER\012#pragma warning(push)\012#pragma warning(disable:4265) // has virtual functions, but destructor is not virtual\012#pragma warning(disable:4505) // unreferenced local function has been removed\012#endif\012\012#ifdef __INTELFPGA_COMPILER__\012// Memory attributes\012#define hls_register                                  __attribute__((__register__))\012#define hls_memory                                    __attribute__((__memory__))\012#define hls_memory_impl(__x)                          __attribute__((__memory__(__x)))\012#define hls_numbanks(__x)                             __attribute__((__numbanks__(__x)))\012#define hls_bankwidth(__x)                            __attribute__((__bankwidth__(__x)))\012#define hls_singlepump                                __attribute__((__singlepump__))\012#define hls_doublepump                                __attribute__((__doublepump__))\012#define hls_numports_readonly_writeonly(__rd, __wr)   __attribute__((__numports_readonly_writeonly__(__rd, __wr)))\012#define hls_bankbits(__x, ...)                        __attribute__((__bank_bits__(__x, ##__VA_ARGS__)))\012#define hls_merge(__x, __y)                           __attribute__((merge(__x, __y)))\012#define hls_init_on_reset                             __attribute__((__static_array_reset__(1)))\012#define hls_init_on_powerup                           __attribute__((__static_array_reset__(0)))\012#define hls_numreadports(__x)                         __attribute__((__numreadports__(__x)))\012#define hls_numwriteports(__x)                        __attribute__((__numwriteports__(__x)))\012\012// Memory attribute macros\012#define hls_simple_dual_port_memory hls_memory hls_singlepump hls_numports_readonly_writeonly(1,1)\012\012// Interface synthesis attributes\012#define hls_avalon_streaming_component         __attribute__((component_interface(\"avalon_streaming\")))\012#define hls_avalon_slave_component             __attribute__((component_interface(\"avalon_mm_slave\"))) __attribute__((stall_free_return))\012#define hls_always_run_component               __attribute__((component_interface(\"always_run\"))) __attribute__((stall_free_return))\012#define hls_conduit_argument                   __attribute__((argument_interface(\"wire\")))\012#define hls_avalon_slave_register_argument     __attribute__((argument_interface(\"avalon_mm_slave\")))\012#define hls_avalon_slave_memory_argument(__x)  __attribute__((local_mem_size(__x))) __attribute__((slave_memory_argument))\012#define hls_stable_argument                    __attribute__((stable_argument))\012#define hls_stall_free_return                  __attribute__((stall_free_return))\012\012// Component attributes\012#define hls_max_concurrency(__x)               __attribute__((max_concurrency(__x)))\012#define hls_scheduler_target_fmax_mhz(__x)     __attribute__((scheduler_target_fmax_mhz(__x)))\012#define hls_component_ii(__x)                  __attribute__((hls_ii(__x)))\012\012// Cluster attributes\012#define hls_use_stall_enable_clusters          __attribute__((stall_enable))\012\012#else\012#define hls_register\012#define hls_memory\012#define hls_numbanks(__x)\012#define hls_bankwidth(__x)\012#define hls_singlepump\012#define hls_doublepump\012#define hls_numports_readonly_writeonly(__rd, __wr)\012#define hls_bankbits(__x, ...)\012#define hls_merge(__x, __y)\012#define hls_init_on_reset\012#define hls_init_on_powerup\012\012#define hls_numreadports(__x)\012#define hls_numwriteports(__x)\012\012#define hls_simple_dual_port_memory\012\012#define hls_avalon_streaming_component\012#define hls_avalon_slave_component\012#define hls_always_run_component\012#define hls_conduit_argument\012#define hls_avalon_slave_register_argument\012#define hls_avalon_slave_memory_argument(__x)\012#define hls_stable_argument\012#define hls_stall_free_return\012\012#define hls_max_concurrency(__x)\012#define hls_scheduler_target_fmax_mhz(__x)\012\012#define hls_use_stall_enable_clusters\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Interfaces Declarations\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012\012  ////////////////////////////////\012 /// memory master interface  ///\012////////////////////////////////\012\012  template<int _N> struct dwidth {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 64;\012  };\012\012  template<int _N> struct awidth {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 64;\012  };\012\012  template<int _N> struct latency {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 1;\012  };\012\012  template<int _N> struct readwrite_mode {\012    // Should be enum readwrite_t but we don't know how to make GetValue generic\012    static constexpr enum readwrite_t value = (readwrite_t) _N;\012    static constexpr enum readwrite_t defaultValue = readwrite;\012  };\012\012  template<int _N> struct maxburst {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 1;\012  };\012\012  template<int _N> struct align {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = -1;\012  };\012\012  template<int _N> struct aspace {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 1;\012  };\012\012  template<int _N> struct waitrequest {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = false;\012  };\012\012  template <template <int> class _Type, class _T>\012  struct MatchType : std::is_same<_Type<_T::value>,_T> {};\012\012  template <template <int> class _Type, class ... _T>\012  struct GetValue {\012    // any value is ok here, so '0' is fine for an arbitrary instantiation\012    enum { value = _Type<0>::defaultValue };\012    // only when _T is empty\012  };\012\012  template <template <int> class _Type, class _T1, class ... _T>\012  struct GetValue<_Type, _T1, _T...> {\012    enum { value = std::conditional<MatchType<_Type, _T1>::value, _T1, GetValue<_Type, _T...>>::type::value };\012  };\012\012template <typename _DT, class ... _Params>\012class mm_master final\012#ifdef HLS_X86\012  : public internal::memory_base\012#endif\012{\012public:\012\012#ifdef HLS_X86\012  template <typename _T>\012  explicit mm_master(_T *data, std::size_t size = 0, bool use_socket = false)\012      : internal::memory_base(_aspace, _awidth, _dwidth, _latency,\012                              _readwrite_mode, true, _maxburst, _align,\012                              _waitrequest, data, size, sizeof(_DT),\012                              use_socket) {\012    mSize = size;\012    mUse_socket = use_socket;\012    if (size > 0 && size % sizeof(_DT) != 0) {\012      __ihc_hls_runtime_error_x86(\012          \"The buffer size must be a multiple of the type size\");\012    }\012  }\012#else\012  template<typename _T> explicit mm_master(_T *data, std::size_t size=0, bool use_socket=false);\012#endif\012\012  // The copy constructor and assignment operator are needed in the testbench\012  // but illegal in a component\012  mm_master(const mm_master &other); \012\012  mm_master& operator=(const mm_master& other);\012\012  // Clean up any derrived mm_masters when this object is destroyed.\012  ~mm_master();\012\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the mm_master object and are only\012  // supported in the testbench:\012  //   mm_master()\012  //   getInterfaceAtIndex()\012  //////////////////////////////////////////////////////////////////////////////\012  // The following operators apply to the base pointer and should only be used\012  // in the component:\012  //   operator[]()\012  //   operator*()\012  //   operator->()\012  //   operator _T()\012  //   operator+()\012  //   operator&()\012  //   operator|()\012  //   operator^()\012  //////////////////////////////////////////////////////////////////////////////\012\012  _DT &operator[](int index);\012  _DT &operator*();\012  _DT *operator->();\012  template<typename _T> operator _T();\012  _DT *operator+(int index);\012  template<typename _T> _DT *operator&(_T value);\012  template<typename _T> _DT *operator|(_T value);\012  template<typename _T> _DT *operator^(_T value);\012  // This function is only supported in the testbench:\012  mm_master<_DT, _Params...>& getInterfaceAtIndex(int index);\012\012#ifdef HLS_X86\012private:\012  std::vector<internal::memory_base* > new_masters;\012#else //Fpga\012\012\012#endif\012private:\012  static constexpr int _dwidth   = GetValue<ihc::dwidth, _Params...>::value;\012  static constexpr int _awidth   = GetValue<ihc::awidth, _Params...>::value;\012  static constexpr int _aspace   = GetValue<ihc::aspace, _Params...>::value;\012  static constexpr int _latency  = GetValue<ihc::latency, _Params...>::value;\012  static constexpr int _maxburst = GetValue<ihc::maxburst, _Params...>::value;\012  static constexpr int _align    = (GetValue<ihc::align, _Params...>::value == -1) ? alignof(_DT) : GetValue<ihc::align, _Params...>::value;\012  static constexpr int _readwrite_mode = GetValue<ihc::readwrite_mode, _Params...>::value;\012  static constexpr bool _waitrequest = GetValue<ihc::waitrequest, _Params...>::value;\012\012\012  _DT* mPtr;\012  int mSize;\012  bool mUse_socket;\012};\012  /////////////////////////////\012 /// streaming interfaces  ///\012//////////////////////////////\012\012  template<int _N> struct buffer {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 0;\012  };\012  \012  template<int _N> struct readyLatency {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 0;\012  };\012\012  template<int _N> struct bitsPerSymbol {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = 0;\012  };\012\012  template<int _N> struct usesPackets {\012    static constexpr bool value = _N;\012    static constexpr bool defaultValue = false;\012  };\012\012  template<int _N> struct usesValid {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = true;\012  };\012\012  template<int _N> struct usesReady {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = true;\012  };\012\012  template<int _N> struct usesEmpty {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = false;\012  };\012\012  template<int _N> struct firstSymbolInHighOrderBits {\012    static constexpr int value = _N;\012    static constexpr int defaultValue = false;\012  };\012\012template <typename _T, class ... _Params>\012class stream_in final : public internal::stream<_T, _Params...> {\012public:\012  stream_in();\012  stream_in(const stream_in&) = delete;\012  stream_in(const stream_in&&) = delete;\012  stream_in& operator=(const stream_in&) = delete;\012  stream_in& operator=(const stream_in&&) = delete;\012  _T read(bool wait=false);\012  void write(const _T& arg);\012  _T tryRead(bool &success);\012  bool tryWrite(const _T& arg);\012\012  // for packet based stream\012  _T read(bool& sop, bool& eop, bool wait=false);\012  _T read(bool& sop, bool& eop, int& empty, bool wait=false);\012  void write(const _T& arg, bool sop, bool eop);\012  void write(const _T& arg, bool sop, bool eop, int empty);\012  _T tryRead(bool &success, bool& sop, bool& eop);\012  _T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  bool tryWrite(const _T& arg, bool sop, bool eop);\012  bool tryWrite(const _T& arg, bool sop, bool eop, int empty);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setValidCycles(unsigned average_valid, unsigned valid_delta=0);\012\012 private:\012    static constexpr int _buffer   = GetValue<ihc::buffer, _Params...>::value;\012    static constexpr int _readyLatency   = GetValue<ihc::readyLatency, _Params...>::value;\012    static constexpr int _bitsPerSymbol  = GetValue<ihc::bitsPerSymbol, _Params...>::value;\012    static constexpr bool _firstSymbolInHighOrderBits =  GetValue<ihc::firstSymbolInHighOrderBits, _Params...>::value;\012    static constexpr bool _usesPackets  = GetValue<ihc::usesPackets, _Params...>::value;\012    static constexpr bool _usesEmpty = GetValue<ihc::usesEmpty, _Params...>::value;\012    static constexpr bool _usesValid = GetValue<ihc::usesValid, _Params...>::value;\012    static constexpr bool _usesReady = GetValue<ihc::usesReady, _Params...>::value;\012};\012\012template <typename _T, class ... _Params>\012class stream_out final : public internal::stream<_T, _Params...> {\012\012public:\012  stream_out();\012  stream_out(const stream_out&) = delete;\012  stream_out(const stream_out&&) = delete;\012  stream_out& operator=(const stream_out&) = delete;\012  stream_out& operator=(const stream_out&&) = delete;\012  _T read(bool wait=false);\012  void write(const _T& arg);\012  _T tryRead(bool &success);\012  bool tryWrite(const _T& arg);\012\012  // for packet based stream\012  _T read(bool& sop, bool& eop, bool wait=false);\012  _T read(bool& sop, bool& eop, int& empty, bool wait=false);\012  void write(const _T& arg, bool sop, bool eop);\012  void write(const _T& arg, bool sop, bool eop, int empty);\012  _T tryRead(bool &success, bool& sop, bool& eop);\012  _T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  bool tryWrite(const _T& arg, bool sop, bool eop);\012  bool tryWrite(const _T& arg, bool sop, bool eop, int empty);\012  void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  void setReadyCycles(unsigned average_ready, unsigned ready_delta=0);\012\012 private:\012    static constexpr int _buffer   = GetValue<ihc::buffer, _Params...>::value;\012    static constexpr int _readyLatency   = GetValue<ihc::readyLatency, _Params...>::value;\012    static constexpr int _bitsPerSymbol  = GetValue<ihc::bitsPerSymbol, _Params...>::value;\012    static constexpr bool _firstSymbolInHighOrderBits = GetValue<ihc::firstSymbolInHighOrderBits, _Params...>::value;\012    static constexpr bool _usesPackets  = GetValue<ihc::usesPackets, _Params...>::value;\012    static constexpr bool _usesEmpty = GetValue<ihc::usesEmpty, _Params...>::value;\012    static constexpr bool _usesValid = GetValue<ihc::usesValid, _Params...>::value;\012    static constexpr bool _usesReady = GetValue<ihc::usesReady, _Params...>::value;\012};\012\012\012// Bi-directional inter-task stream\012template<typename _T, class ... _Params>\012class stream final : public internal::stream<_T, _Params...> {\012public:\012  stream();\012  stream(const stream&) = delete;\012  stream(const stream&&) = delete;\012  stream& operator=(const stream&) = delete;\012  stream& operator=(const stream&&) = delete;\012  _T read(bool wait=true);\012  void write(const _T& arg);\012  _T tryRead(bool &success);\012  bool tryWrite(const _T& arg);\012\012  // for packet based stream\012  _T read(bool& sop, bool& eop, bool wait=true);\012  _T read(bool& sop, bool& eop, int& empty, bool wait=true);\012  void write(const _T& arg, bool sop, bool eop);\012  void write(const _T& arg, bool sop, bool eop, int empty);\012  _T tryRead(bool &success, bool& sop, bool& eop);\012  _T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  bool tryWrite(const _T& arg, bool sop, bool eop);\012  bool tryWrite(const _T& arg, bool sop, bool eop, int empty);\012\012private:\012  static constexpr int _buffer   = GetValue<ihc::buffer, _Params...>::value;\012  static constexpr int _readyLatency   = GetValue<ihc::readyLatency, _Params...>::value;\012  static constexpr int _bitsPerSymbol  = GetValue<ihc::bitsPerSymbol, _Params...>::value;\012  static constexpr bool _firstSymbolInHighOrderBits = GetValue<ihc::firstSymbolInHighOrderBits, _Params...>::value;\012  static constexpr bool _usesPackets  = GetValue<ihc::usesPackets, _Params...>::value;\012  static constexpr bool _usesEmpty = GetValue<ihc::usesEmpty, _Params...>::value;\012  static constexpr bool _usesValid = GetValue<ihc::usesValid, _Params...>::value;\012  static constexpr bool _usesReady = GetValue<ihc::usesReady, _Params...>::value;\012  static_assert(_usesValid, \"Bi-directional stream interfaces must use Valid signal\");\012  static_assert(_usesReady, \"Bi-directional stream interfaces must use Ready signal\");\012\012};\012\012}//namespace ihc\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Cosimulation Support API\012////////////////////////////////////////////////////////////////////////////////\012\012#define ihc_hls_enqueue(retptr, func, ...) \\\012  { \\\012    if (__ihc_hls_async_call_capable()){ \\\012      __ihc_enqueue_handle=(retptr); \\\012      (void) (*(func))(__VA_ARGS__); \\\012      __ihc_enqueue_handle=0; \\\012    } else { \\\012      *(retptr) = (*(func))(__VA_ARGS__); \\\012    } \\\012  }\012\012#define ihc_hls_enqueue_noret(func, ...) \\\012  { \\\012  __ihc_enqueue_handle=& __ihc_enqueue_handle; \\\012  (*(func))(__VA_ARGS__); \\\012  __ihc_enqueue_handle=0; \\\012  }\012\012#define ihc_hls_component_run_all(component_address) \\\012  __ihc_hls_component_run_all((void*) (component_address))\012\012#define ihc_hls_set_component_wait_cycle(component_address, num_wait_cycles) \\\012  __ihc_hls_set_component_wait_cycle((void*) (component_address), num_wait_cycles)\012\012// When running a simulation, this function will issue a reset to all components\012// in the testbench\012// Returns: 0 if reset did not occur (ie. if the component target is x86)\012//          1 if reset occured (ie. if the component target is an FPGA)\012extern \"C\" int ihc_hls_sim_reset(void);\012\012////////////////////////////////////////////////////////////////////////////////\012// HLS Component Built-Ins\012////////////////////////////////////////////////////////////////////////////////\012\012//Builtin memory fence function call\012#ifdef HLS_X86\012inline void ihc_fence() {}\012\012#else\012extern \"C\" void mem_fence(int);\012inline void ihc_fence() {\012  // fence on all types of fences from OpenCL\012  mem_fence(-1);\012}\012#endif\012\012////////////////////////////////////////////////////////////////////////////////\012// Implementions, no declarations below\012////////////////////////////////////////////////////////////////////////////////\012\012namespace ihc {\012#ifdef HLS_X86\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012\012  // The copy constructor and assignment operator are needed in the testbench\012  // necessary to ensurebut illegal in a component\012template <typename _DT, class... _Params>\012mm_master<_DT, _Params...>::mm_master(const mm_master &other)\012    : internal::memory_base(_aspace, _awidth, _dwidth, _latency,\012                            static_cast<readwrite_t>(_readwrite_mode), true,\012                            _maxburst, _align, _waitrequest, other.get_base(),\012                            other.get_size(), sizeof(_DT),\012                            other.uses_socket()) {\012  mPtr = other.mPtr;\012  mSize = other.mSize;\012  mUse_socket = other.mUse_socket;\012  mem = other.mem;\012}\012\012template <typename _DT, class ... _Params>\012  mm_master<_DT, _Params...>& mm_master<_DT, _Params...>::operator=(const mm_master& other) {\012    mPtr = other.mPtr;\012    mSize = other.mSize;\012    mUse_socket = other.m_Use_socket;\012    mem = other.mem;\012  }\012\012  // Clean up any derrived mm_masters when this object is destroyed.\012template <typename _DT, class ... _Params>\012  mm_master<_DT, _Params...>::~mm_master() {\012    for(std::vector<internal::memory_base* >::iterator it = new_masters.begin(),\012        ie = new_masters.end(); it != ie; it++) {\012      delete *it;\012    }\012    new_masters.clear();\012  }\012\012template <typename _DT, class ... _Params>\012_DT &mm_master<_DT, _Params... >::operator[](int index) {\012  assert(size==0 || index*data_size<size);\012  return ((_DT*)mem)[index];\012}\012\012template <typename _DT, class ... _Params>\012_DT &mm_master<_DT, _Params...>::operator*() {\012  return ((_DT*)mem)[0];\012}\012\012template <typename _DT, class ... _Params>\012_DT *mm_master<_DT, _Params...>::operator->() {\012  return (_DT*)mem;\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> mm_master<_DT, _Params...>::operator _T() {\012  return (_T)((unsigned long long)mem);\012}\012\012template <typename _DT, class ... _Params>\012_DT *mm_master<_DT, _Params...>::operator+(int index) {\012  assert(size==0 || index*data_size<size);\012  return &((_DT*)mem)[index];\012}\012\012// Bitwise operators\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator&(_T value) {\012  return (_DT*)((unsigned long long)mem & (unsigned long long)value);\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator|(_T value) {\012  return (_DT*)((unsigned long long)mem | (unsigned long long)value);\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator^(_T value) {\012  return (_DT*)((unsigned long long)mem ^ (unsigned long long)value);\012}\012\012// Function for creating new mm_master at an offset\012template <typename _DT, class ... _Params>\012mm_master<_DT, _Params...>& mm_master<_DT,_Params...>::getInterfaceAtIndex(int index) {\012  assert(mSize==0 || index*data_size<mSize);\012  // This new object is cleaned up when this' destructor is called.\012  mm_master<_DT, _Params...> *temp = new mm_master(&(((_DT*)mem)[index]), mSize - index * sizeof(_DT), mUse_socket);\012  new_masters.push_back(temp);\012  return *temp;\012}\012\012  ///////////////////\012 /// stream_in   ///\012///////////////////\012\012template<typename _T, class ... _Params>\012stream_in<_T,_Params...>::stream_in() {}\012\012template<typename _T, class ... _Params>\012  _T stream_in<_T, _Params...>::tryRead(bool &success) {\012  return internal::stream<_T,_Params...>::tryRead(success);\012}\012\012template<typename _T, class ... _Params>\012  _T stream_in<_T,_Params...>::read(bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg) {\012    internal::stream<_T,_Params...>::write(arg);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::read(bool& sop, bool& eop, bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, empty, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop, empty);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    internal::stream<_T,_Params...>::write(arg, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012    internal::stream<_T,_Params...>::write(arg, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<_T,_Params...>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::setValidCycles(unsigned average_valid, unsigned valid_delta) {\012  if (average_valid == 0) {\012    __ihc_hls_runtime_error_x86(\"The valid average in setValidCycles must be at least 1\");\012  }\012  if (valid_delta > average_valid) {\012    __ihc_hls_runtime_error_x86(\"The valid delta in setValidCycles cannot be larger than the average valid value\");\012  }\012  internal::stream<_T,_Params...>::setReadyorValidCycles(average_valid, valid_delta);\012}\012\012  ///////////////////\012 /// stream_out  ///\012///////////////////\012\012template<typename _T, class ... _Params>\012  stream_out<_T,_Params...>::stream_out() {\012}\012\012template<typename _T, class ... _Params>\012  _T stream_out<_T,_Params...>::tryRead(bool &success) {\012  return internal::stream<_T,_Params...>::tryRead(success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg) {\012    internal::stream<_T,_Params...>::write(arg);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool& sop, bool& eop, bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait /*=false*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, empty, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    internal::stream<_T,_Params...>::write(arg, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012  internal::stream<_T,_Params...>::write(arg, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop, empty);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012  if (stall_delta > average_stall) {\012    __ihc_hls_runtime_error_x86(\"The stall delta in setStallCycles cannot be larger than the average stall value\");\012  }\012  internal::stream<_T,_Params...>::setStallCycles(average_stall, stall_delta);\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::setReadyCycles(unsigned average_ready, unsigned ready_delta) {\012  if (average_ready == 0) {\012    __ihc_hls_runtime_error_x86(\"The ready average in setReadCycles must be at least 1\");\012  }\012  if (ready_delta > average_ready) {\012    __ihc_hls_runtime_error_x86(\"The ready delta in setReadyCycles cannot be larger than the average ready value\");\012  }\012  internal::stream<_T,_Params...>::setReadyorValidCycles(average_ready, ready_delta);\012}\012\012  ///////////////////\012  ///// stream  /////\012  ///////////////////\012\012template<typename _T, class ... _Params>\012  stream<_T,_Params...>::stream() {\012}\012\012template<typename _T, class ... _Params>\012  _T stream<_T,_Params...>::tryRead(bool &success) {\012  return internal::stream<_T,_Params...>::tryRead(success);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool wait /*=true*/) {\012    _T elem = internal::stream<_T,_Params...>::read(wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg) {\012    internal::stream<_T,_Params...>::write(arg);\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  return internal::stream<_T,_Params...>::tryRead(success, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool& sop, bool& eop, bool wait /*=true*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait /*=true*/) {\012    _T elem = internal::stream<_T,_Params...>::read(sop, eop, empty, wait);\012    return elem;\012}\012\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    internal::stream<_T,_Params...>::write(arg, sop, eop);\012}\012\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012  internal::stream<_T,_Params...>::write(arg, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop);\012  }\012  return success;\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  bool success = true; /* stl::queue has no full */\012  if (success) {\012    write(arg, sop, eop, empty);\012  }\012  return success;\012}\012\012\012#else //fpga path. Ignore the class just return a consistant pointer/reference\012\012  //////////////////\012 /// mm_master  ///\012//////////////////\012template <typename _DT, class ... _Params>\012_DT &mm_master<_DT, _Params...>::operator[](int index) {\012  return *__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, index);\012}\012\012template <typename _DT, class ... _Params>\012_DT &mm_master<_DT,_Params...>::operator*(){\012  return *__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0);\012}\012\012template <typename _DT, class ... _Params>\012_DT *mm_master<_DT,_Params...>::operator->(){\012  return __builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0);\012}\012\012template <typename _DT, class ... _Params>\012_DT *mm_master<_DT, _Params...>::operator+(int index) {\012  return __builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0) + index;\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> mm_master<_DT, _Params...>::operator _T() {\012  return (_T)((unsigned long long)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0));\012}\012\012// Bitwise operators\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator&(_T value) {\012  return (_DT*)(((unsigned long long)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0)) & (unsigned long long)value);\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator|(_T value) {\012  return (_DT*)(((unsigned long long)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0)) | (unsigned long long)value);\012}\012\012template <typename _DT, class ... _Params>\012template<typename _T> _DT *mm_master<_DT, _Params...>::operator^(_T value) {\012  return (_DT*)(((unsigned long long)__builtin_intel_hls_mm_master_load(mPtr, mSize, mUse_socket, _dwidth, _awidth, _aspace, _latency, _maxburst, _align, _readwrite_mode, _waitrequest, (int)0)) ^ (unsigned long long)value);\012}\012\012  ///////////////////\012 /// stream_in   ///\012///////////////////\012\012template<typename _T, class ... _Params>\012  _T stream_in<_T, _Params...>::tryRead(bool &success) {\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\");     \012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &emp, &success);\012}\012template<typename _T, class ... _Params>\012  _T stream_in<_T,_Params...>::read(bool wait) {\012  (void)wait;\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\");     \012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return  *__builtin_intel_hls_instream_read((_T*)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &emp);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg) {\012 __builtin_intel_hls_instream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, false, false, 0 );\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg) {\012  return  __builtin_intel_hls_instream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer,  _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &emp, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based reads require a stream with the parameterization: usesEmpty<true>\");\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &empty, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::read(bool& sop, bool& eop, bool wait) {\012  (void)wait;\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");  \012  int emp = 0;\012  return  *__builtin_intel_hls_instream_read((_T*)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &emp);\012}\012template<typename _T, class ... _Params>\012_T stream_in<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait) {\012  (void) wait;\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based reads require a stream with the parameterization: usesEmpty<true>\");\012  return  *__builtin_intel_hls_instream_read((_T*)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, &sop, &eop, &empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  return  __builtin_intel_hls_instream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid,  sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream_in<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  return  __builtin_intel_hls_instream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid, sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012 __builtin_intel_hls_instream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid,  sop, eop, 0 );\012}\012\012template<typename _T, class ... _Params>\012void stream_in<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012 __builtin_intel_hls_instream_write(&arg, (__int64)this,  _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesValid,  sop, eop, empty );\012}\012\012  ///////////////////\012 /// stream_out  ///\012///////////////////\012\012template<typename _T, class ... _Params>\012  _T stream_out<_T,_Params...>::tryRead(bool &success) {\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_outstream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp, &success);\012}\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool wait) {\012  (void)wait;\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_outstream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp );\012}\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg) {\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\"); \012 __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg) {\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\");  \012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  int emp = 0;\012  return *__builtin_intel_hls_outstream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  return *__builtin_intel_hls_outstream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  &sop, &eop, &empty, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool& sop, bool& eop, bool wait) {\012  (void)wait;\012  int emp;\012  return *__builtin_intel_hls_outstream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp);\012}\012\012template<typename _T, class ... _Params>\012_T stream_out<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait) {\012  (void)wait;\012  return *__builtin_intel_hls_outstream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &empty );\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012void stream_out<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based writes require a stream with the parameterization: usesEmpty<true>\");\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream_out<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based writes require a stream with the parameterization: usesEmpty<true>\");\012\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  sop, eop, empty);\012}\012\012  ///////////////////\012  ///// stream  /////\012  ///////////////////\012\012template<typename _T, class ... _Params>\012  _T stream<_T,_Params...>::tryRead(bool &success) {\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp, &success);\012}\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool wait) {\012  (void)wait;\012  bool sop = false;\012  bool eop = false;\012  int emp = 0;\012  return *__builtin_intel_hls_instream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp );\012}\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg) {\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\"); \012 __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg) {\012  static_assert(_usesPackets || !_usesEmpty, \"Empty based reads require a stream with the parametrizations: usesPackets<true>, usesEmpty<true>\");  \012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, false, false, 0);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  int emp = 0;\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  return *__builtin_intel_hls_instream_tryRead((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  &sop, &eop, &empty, &success);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool& sop, bool& eop, bool wait) {\012  (void)wait;\012  int emp;\012  return *__builtin_intel_hls_instream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &emp);\012}\012\012template<typename _T, class ... _Params>\012_T stream<_T,_Params...>::read(bool& sop, bool& eop, int& empty, bool wait) {\012  (void)wait;\012  return *__builtin_intel_hls_instream_read((_T *)0, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, &sop, &eop, &empty );\012}\012\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg, bool sop, bool eop) {\012    static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012void stream<_T,_Params...>::write(const _T& arg, bool sop, bool eop, int empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based writes require a stream with the parameterization: usesEmpty<true>\");\012  __builtin_intel_hls_outstream_write(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  sop, eop, empty);\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady, sop, eop, 0);\012}\012\012template<typename _T, class ... _Params>\012bool stream<_T,_Params...>::tryWrite(const _T& arg, bool sop, bool eop, int empty) {\012  static_assert(_usesPackets, \"Using start_of_packet and end_of_packet requires a stream with the parameterization: usesPackets<true>\");\012  static_assert(_usesEmpty, \"Empty based writes require a stream with the parameterization: usesEmpty<true>\");\012\012  return __builtin_intel_hls_outstream_tryWrite(&arg, (__int64)this, _buffer, _readyLatency, _bitsPerSymbol, _firstSymbolInHighOrderBits, _usesPackets, _usesEmpty, _usesReady,  sop, eop, empty);\012}\012\012#endif\012} // namespace ihc\012\012#ifdef _MSC_VER\012#pragma warning(pop)\012#endif\012\012#endif\012\012"}, {"path":"/opt/intelFPGA_pro/19.1/hls/include/HLS/hls_internal.h", "name":"hls_internal.h", "has_active_debug_locs":false, "absName":"/opt/intelFPGA_pro/19.1/hls/include/HLS/hls_internal.h", "content":"#ifndef __HLS_INTERNAL_H__\012#define __HLS_INTERNAL_H__\012\012#ifdef HLS_X86\012#include <queue>\012#include <string.h> //memcpy\012#include <assert.h>\012#include <stdio.h>\012#include <stdlib.h>\012#include <mutex>\012#include <condition_variable>\012#endif\012\012#ifdef _MSC_VER\012#pragma warning(push)\012#pragma warning(disable:4265) // has virtual functions, but destructor is not virtual\012#pragma warning(disable:4505) // unreferenced local function has been removed\012#endif\012\012#if defined(_MSC_VER)\012  #define WINDOWSWEAK __declspec(selectany)\012  #define LINUXWEAK\012#else\012  #define WINDOWSWEAK\012  #define LINUXWEAK __attribute__((weak))\012#endif\012\012WINDOWSWEAK void *__ihc_enqueue_handle LINUXWEAK;\012\012extern \"C\" unsigned long long ihc_hls_get_sim_time(void);\012extern \"C\" int __ihc_hls_get_clock_period_ps(void);\012extern \"C\" int __ihc_hls_component_start_sim_task(const char *component_name);\012extern \"C\" int __ihc_hls_component_wait_sim_task(const char *component_name, unsigned int wait_cycles);\012extern \"C\" void __ihc_hls_stream_sink_wait_sim_task(void* obj_ptr);\012extern \"C\" void __ihc_hls_component_run_all(const void* component_address);\012extern \"C\" void __ihc_hls_set_component_wait_cycle(const void * component_address, unsigned int num_wait_cycles);\012\012// Cosim internal support calls\012extern \"C\" int __ihc_hls_async_call_capable(void);\012// Print error message and bail\012extern \"C\" void __ihc_hls_runtime_error(const char *msg);\012\012#ifdef HLS_X86\012inline void __ihc_hls_runtime_error_x86(const char *msg){\012  printf(\"Error: %s\\n\",msg);\012  exit(1);\012}\012#endif\012\012enum readwrite_t {readwrite = 0, readonly = 1, writeonly = 2};\012\012// ignore __fpga_reg in emulation flow\012#ifdef HLS_X86\012  #define __fpga_reg(x) (x)\012#elif defined(__clang__)\012#if __has_builtin(__builtin_fpga_reg)\012  #ifndef __fpga_reg\012    #define __fpga_reg __builtin_fpga_reg\012  #endif\012#endif\012#endif\012\012namespace ihc {\012\012namespace internal {\012\012// Interface parameter base types used to define interfaces\012class param {};\012class notinit:public param {};\012\012class memory_base {\012private:\012#ifdef HLS_X86\012  // Attributes\012  int aspace; \012  int awidth;\012  int dwidth;\012  int latency;\012  readwrite_t readwrite_mode;\012  bool byteenabled;\012  int maxburst;\012  int align;\012  bool waitrequest;\012  size_t sim_base;\012\012protected:\012  // Extra cosim book keeping\012  size_t data_size; //size of the underlying type used by the interface\012  void *mem;\012  size_t size;\012  bool use_socket; // if true, all reads and writes will go through the IPC socket instead of shared memory\012\012  //description of test data buffer accessed through this interface\012  void set_mem(void *x) {mem=x;};\012  void set_size(size_t x) {size=x;};\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  \012#endif\012public:\012#ifdef HLS_X86\012  memory_base() {}\012  memory_base(int aspace, int awidth, int dwidth, int latency,\012              int readwrite_mode, bool byteenabled, int maxburst, int align,\012              bool waitrequest, void *mem, size_t size, size_t data_size,\012              bool use_socket)\012      : aspace(aspace), awidth(awidth), dwidth(dwidth), latency(latency),\012        readwrite_mode(static_cast<readwrite_t>(readwrite_mode)),\012        byteenabled(byteenabled), maxburst(maxburst), align(align),\012        waitrequest(waitrequest), data_size(data_size), mem(mem), size(size),\012        use_socket(use_socket) {}\012  memory_base(int aspace, int awidth, int dwidth, int latency,\012              readwrite_t readwrite_mode, bool byteenabled, int maxburst,\012              int align, bool waitrequest);\012  // set_parameters, set_base, and get_sim_base are defined in the hls_cosim library\012  void set_parameters(int aspace, int awidth, int dwidth, int latency,\012                      readwrite_t readwrite_mode, bool byteenabled,\012                      int maxburst, int align, bool waitrequest);\012  void set_base(void *ptr, size_t datasize, size_t size, bool use_socket);\012  int get_interface_aspace() const {return aspace;}\012  void * get_base() const {return mem;}\012  size_t get_size() const {return size;}\012  int get_awidth() const {return awidth;}\012  int get_dwidth() const {return dwidth;}\012  int get_latency() const {return latency;}\012  readwrite_t get_readwrite_mode() const {return readwrite_mode;}\012  bool get_byteenabled() const {return byteenabled;}\012  int get_maxburst() const {return maxburst;}\012  int get_align() const {return align;}\012  bool get_waitrequest() const {return waitrequest;}\012  \012  size_t get_data_size() const {return data_size;}\012\012  void set_sim_base(size_t addr) {sim_base = addr;}\012  size_t get_sim_base();\012  \012  void set_use_socket(bool socket) {use_socket = socket;}\012  bool uses_socket() const {return use_socket;}\012#endif\012};\012\012#ifdef HLS_X86\012class stream_abstract_base {\012  bool stable; // does the data on this interface change between function calls?\012  bool implicit; // is this interface synchronous with the component's function call interface?\012  bool global; // is this an implicit interface that carries a global variable's address?\012  size_t data_size; //size of the underlying type used by the interface\012protected:\012  unsigned m_average_stall;\012  unsigned m_stall_delta;\012  unsigned m_average_RoV;\012  unsigned m_RoV_delta;\012  unsigned m_remaining_period;\012  unsigned m_period_threshold;\012public:\012stream_abstract_base():stable(false), implicit(false), global(false), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1) { assert(1==0);}\012stream_abstract_base(size_t data_size):stable(false), implicit(false), global(false), data_size(data_size), m_average_stall(0), m_stall_delta(0), m_average_RoV(1), m_RoV_delta(0), m_remaining_period(1), m_period_threshold(1){}\012  bool is_stable() {return stable;}\012  void set_stable() {stable = true;}\012  bool is_implicit() {return implicit;}\012  bool is_global() {return global;}\012  void set_implicit() {implicit = true;}\012  void set_global() {global = true;}\012  size_t get_data_size() {return data_size;}\012  void set_data_size(size_t datasize) {data_size = datasize;}\012  unsigned get_average_stall() {return m_average_stall;}\012  unsigned get_stall_delta() {return m_stall_delta;}\012  unsigned get_average_RoV() {return m_average_RoV;}\012  unsigned get_RoV_delta() {return m_RoV_delta;}\012  virtual bool _internal_cosim_empty() = 0;\012  virtual void read_by_ptr(void *data) = 0;\012  virtual void read_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void read_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) = 0;\012  virtual void write_by_ptr(void *data) = 0;\012  virtual void write_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void write_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) = 0;\012  virtual void front_by_ptr(void *data) = 0;\012  virtual void front_by_ptr_pkt(void *data, bool* sop, bool* eop) = 0;\012  virtual void front_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) = 0;\012  virtual size_t get_size() = 0;\012};\012#endif\012\012template<typename T, class ... Params>\012class stream \012#ifdef HLS_X86\012  :  public stream_abstract_base \012#endif\012{\012\012#ifdef HLS_X86\012  std::queue<T> q_;\012  std::queue<std::pair<bool,bool> > qp_;\012  std::queue<int> qpe_;\012  std::mutex m_;\012  std::condition_variable cv_;\012#endif\012public:  \012  stream();\012  // do not allow copy and assignment of streams\012  stream(const stream&) = delete;\012  stream& operator=(const stream&) = delete; \012\012  bool _internal_cosim_empty(); \012#ifdef HLS_X86\012  virtual T read(bool wait=false);               \012  virtual void write(const T& arg);      \012  virtual T tryRead(bool &success);   \012  virtual bool tryWrite(const T& arg);       \012\012  // for packet based stream \012  virtual T read(bool& sop, bool& eop, bool wait=false);\012  virtual T read(bool& sop, bool& eop, int& empty, bool wait=false);\012  virtual void write(const T& arg, bool sop, bool eop);\012  virtual void write(const T& arg, bool sop, bool eop, int empty);\012  virtual T tryRead(bool &success, bool& sop, bool& eop);\012  virtual T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  virtual bool tryWrite(const T& arg, bool sop, bool eop);     \012  virtual bool tryWrite(const T& arg, bool sop, bool eop, int empty);     \012  virtual void setStallCycles(unsigned average_stall, unsigned stall_delta=0);\012  virtual void setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta=0);\012#else\012  T read();               \012  void write(const T& arg);      \012  T tryRead(bool &success); \012  bool tryWrite(const T& arg);       \012\012  // for packet based stream \012  T read(bool& sop, bool& eop);\012  T read(bool& sop, bool& eop, int& empty);\012  void write(const T& arg, bool sop, bool eop);\012  void write(const T& arg, bool sop, bool eop, int empty);\012  T tryRead(bool &success, bool& sop, bool& eop);\012  T tryRead(bool &success, bool& sop, bool& eop, int& empty);\012  bool tryWrite(const T& arg, bool sop, bool eop);     \012  bool tryWrite(const T& arg, bool sop, bool eop, int empty);     \012#endif\012   T _internal_cosim_front();\012   T _internal_cosim_front(bool& sop, bool& eop);\012   T _internal_cosim_front(bool& sop, bool& eop, int& empty);\012  \012#ifdef HLS_X86\012  void read_by_ptr(void *data);\012  void read_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  void read_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty);\012  void write_by_ptr(void *data);\012  void write_by_ptr_pkt(void *data, bool* sop, bool*eop);\012  void write_by_ptr_pkt_e(void *data, bool* sop, bool*eop, void* empty);\012  void front_by_ptr(void *data);\012  void front_by_ptr_pkt(void *data, bool* sop, bool* eop);\012  void front_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty);\012  size_t get_size() {return q_.size();}\012\012  // control stall/valid behaviour\012  bool stall();\012  void setStallPeriod();\012  //Middle Square Weyl Sequence RNG\012   unsigned msws();\012#endif\012};\012\012template <typename T, class ... Params>\012  stream<T,Params...>::stream()\012#ifdef HLS_X86\012 :stream_abstract_base(sizeof(T))\012#endif\012{\012}\012\012  ////////////////\012 /// stream   ///\012////////////////\012\012#ifdef HLS_X86\012template<typename T, class ... Params>\012bool stream<T,Params...>::_internal_cosim_empty() {\012  bool empty=q_.empty();  \012  return empty;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::tryRead(bool &success) {\012  std::unique_lock<std::mutex> _{ m_ };\012  success = !_internal_cosim_empty();\012  if (success) {\012    T arg = q_.front();\012    q_.pop();\012 \012    // unused sideband signals\012    qp_.pop();\012    qpe_.pop();\012    return arg;\012  } else {\012    return T();\012  }\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::tryRead(bool &success, bool& sop, bool& eop) {\012  std::unique_lock<std::mutex> _{ m_ };\012  success = !_internal_cosim_empty();\012  if (success) {\012    T arg = q_.front();\012    q_.pop();\012    std::pair<bool,bool> p = qp_.front();\012    sop = p.first;\012    eop = p.second;\012\012    qp_.pop();\012    qpe_.pop();\012    return arg;\012  } else {\012    return T();\012  }\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::tryRead(bool &success, bool& sop, bool& eop, int& empty) {\012  std::unique_lock<std::mutex> _{ m_ };\012  success = !_internal_cosim_empty();\012  if (success) {\012    T arg = q_.front();\012    q_.pop();\012    std::pair<bool,bool> p = qp_.front();\012    empty = qpe_.front();\012    sop = p.first;\012    eop = p.second;\012\012    qp_.pop();\012    qpe_.pop();\012    return arg;\012  } else {\012    return T();\012  }\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::read(bool wait) {\012  std::unique_lock<std::mutex> lock{ m_ };\012  bool empty = _internal_cosim_empty();\012#ifdef HLS_X86\012  // in the case of emulation, we either error out or wait until wait is available\012  if(empty && !wait) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012  // wait until the queue is no longer empty\012  cv_.wait(lock, [this]{return  !this->_internal_cosim_empty();});\012  T arg = q_.front();\012  q_.pop();\012\012  // unused sideband signals\012  qp_.pop();\012  qpe_.pop();\012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::read(bool& sop, bool& eop, bool wait) {\012  T arg;\012\012  std::unique_lock<std::mutex> lock{ m_ };\012  bool empty = _internal_cosim_empty();\012#ifdef HLS_X86\012  // in the case of emulation, we either error out or wait until wait is available\012  if(empty && !wait) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012  // wait until the queue is no longer empty\012  cv_.wait(lock, [this]{return  !this->_internal_cosim_empty();});\012  arg = q_.front();\012  q_.pop();\012  std::pair<bool,bool> p = qp_.front();\012  sop = p.first;\012  eop = p.second;\012\012  qp_.pop();\012  // unused sideband signal\012  qpe_.pop();\012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::read(bool& sop, bool& eop, int& empty, bool wait) {\012  std::unique_lock<std::mutex> lock{ m_ };\012  bool empty_ = _internal_cosim_empty();\012#ifdef HLS_X86\012  // in the case of emulation, we either error out or wait until wait is available\012  if(empty_ && !wait) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012  // wait until the queue is no longer empty\012  cv_.wait(lock, [this]{return  !this->_internal_cosim_empty();});\012  T arg = q_.front();\012  q_.pop();\012\012  std::pair<bool,bool> p = qp_.front();\012  empty = qpe_.front();\012  sop = p.first;\012  eop = p.second;\012\012  qp_.pop();\012  qpe_.pop();\012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::_internal_cosim_front() {\012  T arg;      \012    \012  std::unique_lock<std::mutex> _{ m_ };\012  bool empty = _internal_cosim_empty();\012#ifdef HLS_X86\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012\012  arg = q_.front();\012  \012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::_internal_cosim_front(bool& sop, bool& eop) {\012  T arg;      \012    \012  std::unique_lock<std::mutex> _{ m_ };\012  bool empty = _internal_cosim_empty();\012#ifdef HLS_X86\012  if(empty) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012\012  arg = q_.front();\012  std::pair<bool,bool> p = qp_.front();\012\012  sop = p.first;\012  eop = p.second;\012  \012  return arg;\012}\012\012template<typename T, class ... Params>\012T stream<T,Params...>::_internal_cosim_front(bool& sop, bool& eop, int& empty) {\012  T arg;      \012\012  std::unique_lock<std::mutex> _{ m_ };\012  bool empty_ = _internal_cosim_empty();\012#ifdef HLS_X86\012  if(empty_) __ihc_hls_runtime_error_x86(\"Cannot do a blocking read from an empty stream on an x86 target\");\012#endif\012\012  arg = q_.front();\012  std::pair<bool,bool> p = qp_.front();\012  empty = qpe_.front();\012  sop = p.first;\012  eop = p.second;\012\012  return arg;\012}\012\012template<typename T, class ... Params>\012bool stream<T,Params...>::tryWrite(const T& arg) {\012   bool success = true; /* stl::queue has no full */\012   if (success) {\012      write(arg);\012   }\012   return success;\012}\012\012template<typename T, class ... Params>\012bool stream<T,Params...>::tryWrite(const T& arg, bool sop, bool eop) {\012    bool success = true; /* stl::queue has no full */\012    if (success) {\012        write(arg, sop, eop);\012    }\012    return success;\012}\012\012template<typename T, class ... Params>\012bool stream<T,Params...>::tryWrite(const T& arg, bool sop, bool eop, int empty) {\012    bool success = true; /* stl::queue has no full */\012    if (success) {\012        write(arg, sop, eop, empty);\012    }\012    return success;\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write(const T& arg) {\012    {\012        std::unique_lock<std::mutex> _{ m_ };\012        q_.push(arg);\012\012        // sideband signals\012        qp_.push(std::pair<bool,bool>(false,false));\012        qpe_.push(0);\012    }\012    cv_.notify_one();\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write(const T& arg, bool sop, bool eop) {\012    {\012        std::unique_lock<std::mutex> _{ m_ };\012        q_.push(arg);\012\012        // sideband signals\012        qp_.push(std::pair<bool,bool>(sop, eop));\012        qpe_.push(0);\012    }\012    cv_.notify_one();\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write(const T& arg, bool sop, bool eop, int empty) {\012    {\012        std::unique_lock<std::mutex> _{ m_ };\012        q_.push(arg);\012\012        // sideband signals\012        qp_.push(std::pair<bool,bool>(sop, eop));\012        qpe_.push(empty);\012    }\012    cv_.notify_one();\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::read_by_ptr(void *data) {\012    T elem = read();\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::read_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = read(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::read_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) {\012    int temp_empty;\012    T elem = read(*sop, *eop, temp_empty);\012    memcpy(data, &elem, sizeof(T));\012    memcpy(empty, &temp_empty, sizeof(int));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::front_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) {\012    int temp_empty;\012    T elem = _internal_cosim_front(*sop, *eop, temp_empty);\012    memcpy(data, &elem, sizeof(T));\012    memcpy(empty, &temp_empty, sizeof(int));\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::front_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem = _internal_cosim_front(*sop, *eop);\012    memcpy(data, &elem, sizeof(T));    \012}\012\012\012template<typename T, class ... Params>\012void stream<T,Params...>::front_by_ptr(void *data) {\012    T elem = _internal_cosim_front();\012    memcpy(data, &elem, sizeof(T));    \012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write_by_ptr_pkt(void *data, bool* sop, bool* eop) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem, *sop, *eop);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write_by_ptr_pkt_e(void *data, bool* sop, bool* eop, void* empty) {\012    T elem;\012    int temp_empty;\012    memcpy(&elem, data, sizeof(T));\012    memcpy(&temp_empty, empty, sizeof(int));\012    write(elem, *sop, *eop, temp_empty);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::write_by_ptr(void *data) {\012    T elem;\012    memcpy(&elem, data, sizeof(T));\012    write(elem);\012}\012\012template<typename T, class ... Params>\012void stream<T,Params...>::setStallPeriod() {\012    if (m_stall_delta == 0) {\012        m_remaining_period = m_average_stall;\012    } else {\012        m_remaining_period = (m_average_stall - m_stall_delta) + msws()%(m_stall_delta*2+1);\012    }\012    if (m_RoV_delta == 0) {\012        m_period_threshold = m_average_RoV;\012    } else {\012        m_period_threshold = (m_average_RoV - m_RoV_delta) + msws()%(m_RoV_delta*2+1);\012    }\012    m_remaining_period +=  m_period_threshold;\012}\012\012template<typename T, class ... Params>\012  void stream<T, Params...>::setStallCycles(unsigned average_stall, unsigned stall_delta) {\012    m_average_stall = average_stall;\012    m_stall_delta = stall_delta;\012    setStallPeriod();\012}\012\012template<typename T, class ... Params>\012  void stream<T, Params...>::setReadyorValidCycles(unsigned average_RoV, unsigned RoV_delta) {\012    m_average_RoV = average_RoV;\012    m_RoV_delta = RoV_delta;\012    setStallPeriod();\012}\012\012template<typename T, class ... Params>\012bool stream<T, Params...>::stall() {\012  if (m_remaining_period == 0) {\012    setStallPeriod();\012  }\012  m_remaining_period--;\012  if (m_remaining_period < m_period_threshold) { \012    return false;\012  } else {\012    return true;\012  }\012}\012\012template<typename T, class ... Params>\012unsigned stream<T, Params...>::msws() {\012  static unsigned long long x = 0, w = 0;\012  const unsigned long long s = 0xb5ad4eceda1ce2a9ULL;\012  \012  x *= x; \012  x += (w += s); \012  return (unsigned) (x = (x>>32) | (x<<32));\012}\012\012#endif\012} //namespace internal\012} //namespace ihc\012\012#ifdef _MSC_VER\012#pragma warning(pop)\012#endif\012\012#endif\012\012"}, {"path":"img_filter_base.h", "name":"img_filter_base.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/HLS/HiFlipVX_Intel_FPGA/img_filter_base.h", "content":"/**\012* Licence: GNU GPLv3 \\n\012* You may copy, distribute and modify the software as long as you track\012* changes/dates in source files. Any modifications to or software\012* including (via compiler) GPL-licensed code must also be made available\012* under the GPL along with build & install instructions.\012*\012* @file    img_filter_base.h\012* @author  Lester Kalms <lester.kalms@tu-dresden.de>\012* @version 1.3\012* @brief Description:\\n\012*  These are all accelerated image filter functions (Call from here)\012*/\012\012#ifndef SRC_IMG_FILTER_BASE_H_\012#define SRC_IMG_FILTER_BASE_H_\012#include \"HLS/hls.h\"\012#include \"img_filter_core.h\"\012#include \"main.h\"\012/*********************************************************************************************************************/\012/* Filter Function Declaration */\012/*********************************************************************************************************************/\012\012/** @brief  Computes a Box filter over a window of the input image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param SEPARABLE   Is true, if separable filter should be used\012@param input       Input image\012@param output      Output image\012*/\012template<typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, vx_bool SEPARABLE>\012void ImgBox(vx_image<DataType, VEC_NUM> input[(HEIGHT*WIDTH) / VEC_NUM], vx_image<DataType, VEC_NUM> output[(HEIGHT*WIDTH) / VEC_NUM]) {\012////#pragma HLS INLINE\012	HwBox<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, SEPARABLE>(input, output);\012}\012template<typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, vx_bool SEPARABLE>\012void ImgBox(DataType input[(HEIGHT*WIDTH) / VEC_NUM], DataType output[(HEIGHT*WIDTH) / VEC_NUM]) {\012////#pragma HLS INLINE	\012	HwBox<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, SEPARABLE>((vx_image<DataType, VEC_NUM> *)input, (vx_image<DataType, VEC_NUM> *)output);\012}\012\012/** @brief  Convolves the input with the client supplied convolution matrix. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned, signed)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       Input image\012@param output      Output image\012@param conv        The custom convolution kernel\012*/\012template<typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE>\012void ImgConvolve(vx_image<DataType, VEC_NUM> input[(HEIGHT*WIDTH) / VEC_NUM], vx_image<DataType, VEC_NUM> output[(HEIGHT*WIDTH) / VEC_NUM], const DataType conv[KERN_SIZE][KERN_SIZE]) {\012////#pragma HLS INLINE		\012	HwConvolve<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input, output, conv);\012}\012template<typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE>\012void ImgConvolve(DataType input[(HEIGHT*WIDTH) / VEC_NUM], DataType output[(HEIGHT*WIDTH) / VEC_NUM], const DataType conv[KERN_SIZE][KERN_SIZE]) {\012////#pragma HLS INLINE		\012	HwConvolve<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>((vx_image<DataType, VEC_NUM> *)input, (vx_image<DataType, VEC_NUM> *)output, conv);\012}\012\012/** @brief  Implements Dilation, which grows the white space in a Boolean image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       Input image\012@param output      Output image\012*/\012template<typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE>\012void ImgDilate(vx_image<DataType, VEC_NUM> input[(HEIGHT*WIDTH) / VEC_NUM], vx_image<DataType, VEC_NUM> output[(HEIGHT*WIDTH) / VEC_NUM]) {\012////#pragma HLS INLINE		\012	HwDilate<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input, output);\012}\012template<typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE>\012void ImgDilate(DataType input[(HEIGHT*WIDTH) / VEC_NUM], DataType output[(HEIGHT*WIDTH) / VEC_NUM]) {\012////#pragma HLS INLINE		\012	HwDilate<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>((vx_image<DataType, VEC_NUM> *)input, (vx_image<DataType, VEC_NUM> *)output);\012}\012\012/** @brief  Implements Erosion, which shrinks the white space in a Boolean image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       Input image\012@param output      Output image\012*/\012template<typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE>\012void ImgErode(vx_image<DataType, VEC_NUM> input[(HEIGHT*WIDTH) / VEC_NUM], vx_image<DataType, VEC_NUM> output[(HEIGHT*WIDTH) / VEC_NUM]) {\012////#pragma HLS INLINE		\012	HwErode<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input, output);\012}\012template<typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE>\012void ImgErode(DataType input[(HEIGHT*WIDTH) / VEC_NUM], DataType output[(HEIGHT*WIDTH) / VEC_NUM]) {\012////#pragma HLS INLINE		\012	HwErode<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>((vx_image<DataType, VEC_NUM> *)input, (vx_image<DataType, VEC_NUM> *)output);\012}\012\012/** @brief  Computes a Gaussian filter over a window of the input image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param SEPARABLE   Is true, if separable filter should be used\012@param input       Input image\012@param output      Output image\012*/\012template<typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, vx_bool SEPARABLE>\012void ImgGaussian(vx_image<DataType, VEC_NUM> input[(HEIGHT*WIDTH) / VEC_NUM], vx_image<DataType, VEC_NUM> output[(HEIGHT*WIDTH) / VEC_NUM]) {\012////#pragma HLS INLINE		\012	HwGaussian<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, SEPARABLE>(input, output);\012}\012template<typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, vx_bool SEPARABLE>\012void ImgGaussian(DataType input[(HEIGHT*WIDTH) / VEC_NUM], DataType output[(HEIGHT*WIDTH) / VEC_NUM]) {\012////#pragma HLS INLINE		\012	HwGaussian<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE, SEPARABLE>((vx_image<DataType, VEC_NUM> *)input, (vx_image<DataType, VEC_NUM> *)output);\012}\012\012/** @brief  Computes a median pixel value over a window of the input image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       Input image\012@param output      Output image\012*/\012template<typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE>\012void ImgMedian(vx_image<DataType, VEC_NUM> input[(HEIGHT*WIDTH) / VEC_NUM], vx_image<DataType, VEC_NUM> output[(HEIGHT*WIDTH) / VEC_NUM]) {\012////#pragma HLS INLINE		\012	HwMedian<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input, output);\012}\012template<typename DataType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE>\012void ImgMedian(DataType input[(HEIGHT*WIDTH) / VEC_NUM], DataType output[(HEIGHT*WIDTH) / VEC_NUM]) {\012////#pragma HLS INLINE		\012	HwMedian<DataType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>((vx_image<DataType, VEC_NUM> *)input, (vx_image<DataType, VEC_NUM> *)output);\012}\012\012/** @brief  Implements the Scharr Image Filter Kernel. The output images dimensions should be the same as the dimensions of the input image. \012@param SrcType     Data type of the input image (unsigned)(8-bit, 16-bit, 32-bit)\012@param DstType     Data type of the output image (signed)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       The input image\012@param output1     The output image (x derivative)\012@param output2     The output image (y derivative)\012*/\012template <typename SrcType, typename DstType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_border_e BORDER_TYPE>\012void ImgScharr3x3(vx_image<SrcType, VEC_NUM> input[(HEIGHT*WIDTH) / VEC_NUM], vx_image<DstType, VEC_NUM> output1[(HEIGHT*WIDTH) / VEC_NUM], vx_image<DstType, VEC_NUM> output2[(HEIGHT*WIDTH) / VEC_NUM]) {\012////#pragma HLS INLINE		\012	HwScharr3x3<SrcType, DstType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, BORDER_TYPE>(input, output1, output2);\012}\012template <typename SrcType, typename DstType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_border_e BORDER_TYPE>\012void ImgScharr3x3(SrcType input[(HEIGHT*WIDTH) / VEC_NUM], DstType output1[(HEIGHT*WIDTH) / VEC_NUM], DstType output2[(HEIGHT*WIDTH) / VEC_NUM]) {\012////#pragma HLS INLINE		\012	HwScharr3x3<SrcType, DstType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, BORDER_TYPE>((vx_image<SrcType, VEC_NUM> *)input, (vx_image<DstType, VEC_NUM> *)output1, (vx_image<DstType, VEC_NUM> *)output2);\012}\012\012/** @brief  Implements the Sobel Image Filter Kernel. The output images dimensions should be the same as the dimensions of the input image. \012@param SrcType     Data type of the input image (unsigned)(8-bit, 16-bit, 32-bit)\012@param DstType     Data type of the output image (signed)(8-bit, 16-bit, 32-bit)\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       The input image\012@param output1     The output image (x derivative)\012@param output2     The output image (y derivative)\012*/\012//function template that can be declared in different forms to generate a component.\012//\012//template <typename SrcType, typename DstType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE>void ImgSobel(vx_image<SrcType, VEC_NUM> input, vx_image<DstType, VEC_NUM> output1, vx_image<DstType, VEC_NUM> output2)\012//{\012////#pragma HLS INLINE		\012//	HwSobel<SrcType, DstType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input, output1, output2);\012//}\012//\012\012template <typename SrcType, typename DstType, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE>\012void ImgSobel(vx_image<SrcType, VEC_NUM> input0[(HEIGHT*WIDTH) / VEC_NUM], vx_image<DstType, VEC_NUM> output1[(HEIGHT*WIDTH) / VEC_NUM], vx_image<DstType, VEC_NUM> output2[(HEIGHT*WIDTH) / VEC_NUM])\012{\012\012	HwSobel<SrcType, DstType, VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM), VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>((vx_image<SrcType, VEC_NUM> *)input0, (vx_image<DstType, VEC_NUM> *)output1, (vx_image<DstType, VEC_NUM> *)output2);\012}\012\012//component instance to be synthesize\012template component void ImgSobel<vx_uint8,vx_int8, VEC_NUM_K, COLS_FHD_K,ROWS_FHD_K, FILTER_SIZE_K, SOBEL_BORDER_K> (vx_image<vx_uint8, VEC_NUM_K> input0[(ROWS_FHD_K*COLS_FHD_K) / VEC_NUM_K], vx_image<vx_int8, VEC_NUM_K> output1[(ROWS_FHD_K*COLS_FHD_K) / VEC_NUM_K], vx_image<vx_int8, VEC_NUM_K> output2[(ROWS_FHD_K*COLS_FHD_K) / VEC_NUM_K]); \012\012\012#endif /* SRC_IMG_FILTER_BASE_H_ */\012"}, {"path":"img_filter_core.h", "name":"img_filter_core.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/HLS/HiFlipVX_Intel_FPGA/img_filter_core.h", "content":"/**\012* Licence: GNU GPLv3 \\n\012* You may copy, distribute and modify the software as long as you track\012* changes/dates in source files. Any modifications to or software\012* including (via compiler) GPL-licensed code must also be made available\012* under the GPL along with build & install instructions.\012*\012* @file    img_filter_core.h\012* @author  Lester Kalms <lester.kalms@tu-dresden.de>\012* @version 1.3\012* @brief Description:\\n\012*  These are the core functions used for the hardware accelerated image processing functions (Do not call functions from here)\012*/\012\012#ifndef SRC_IMG_FILTER_CORE_H_\012#define SRC_IMG_FILTER_CORE_H_\012\012#include \"img_helper.h\"\012//#include \"main.h\"\012using namespace std;\012\012/*********************************************************************************************************************/\012/* Linebuffer Functions */\012/*********************************************************************************************************************/\012\012/** @brief Reads data from line buffers\012@param VecType     1 vector is 1 linebuffer element\012@param KERN_SIZE   The size of the filter kernel\012@param VEC_COLS    The amount of columns in the vectorized image\012@param input       New image data to be stored into the linebuffer\012@param linebuffer  Linebuffers to store (KERN_SIZE-1) image rows\012@param output      Data at x coordinates in the linebuffers\012@param x           The x coordinate in the vectorized image\012*/\012template <typename InType, typename BufferType, const vx_uint16 BUFFER_NUM, const vx_uint8 VEC_NUM, const vx_uint16 KERN_SIZE, const vx_uint16 VEC_COLS>\012void ReadFromLineBuffer(InType input[VEC_NUM], BufferType linebuffer[BUFFER_NUM][VEC_COLS], InType output[KERN_SIZE][VEC_NUM], const vx_uint16 x) {\012////#pragma HLS INLINE\012\012	// For data type conversion to decrease BRAM usage: FACTOR*BUFFER_NUM = (KERN_SIZE-1)*VEC_NUM\012	const vx_uint16 FACTOR = sizeof(BufferType) / sizeof(InType);\012\012	// Buffer for data type conversion\012	BufferType buffer1[BUFFER_NUM];\012//#pragma HLS array_partition variable=buffer1 complete dim=0\012	InType buffer2[BUFFER_NUM*FACTOR];\012//#pragma HLS array_partition variable=buffer2 complete dim=0\012\012	// Check linebuffer border\012	if (x < VEC_COLS) {\012\012		// Read data from linebuffer\012#pragma unroll\012		for (vx_uint16 i = 0; i < BUFFER_NUM; i++) {\012			buffer1[i] = linebuffer[i][x];\012		}\012\012		// Unpack data\012#pragma unroll\012		for (vx_uint16 i = 0; i < BUFFER_NUM; i++) {\012#pragma unroll\012			for (vx_uint16 j = 0; j < FACTOR; j++) {\012				vx_uint16 shift = j * static_cast<vx_uint16>(sizeof(InType)) * static_cast<vx_uint16>(8);\012				buffer2[i*FACTOR + j] = static_cast<InType>(buffer1[i] >> shift);\012			}\012		}\012\012		// Pack data for output\012#pragma loop_coalesce\012		#pragma unroll\012		for (vx_uint16 i = 0; i < KERN_SIZE-1; i++) {\012			#pragma unroll\012			for (vx_uint16 j = 0; j < VEC_NUM; j++) {\012				output[i][j] = buffer2[i*VEC_NUM + j];\012			}\012		}\012		#pragma unroll\012		for (vx_uint16 j = 0; j < VEC_NUM; j++) {\012			output[KERN_SIZE - 1][j] = input[j];\012		}\012	}\012}\012\012/** @brief Writes data to line buffers\012@param VecType     1 vector is 1 linebuffer element\012@param KERN_SIZE   The size of the filter kernel\012@param VEC_COLS    The amount of columns in the vectorized image\012@param input       Stores data at the x coordinates of the linebuffers\012@param linebuffer  Linebuffers to store (KERN_SIZE-1) image rows\012@param x           The x coordinate in the vectorized image\012*/\012template <typename InType, typename BufferType, const vx_uint16 BUFFER_NUM, const vx_uint8 VEC_NUM, const vx_uint16 KERN_SIZE, const vx_uint16 VEC_COLS>\012void WriteToLineBuffer(InType input[KERN_SIZE][VEC_NUM], BufferType linebuffer[BUFFER_NUM][VEC_COLS], const vx_uint16 x) {\012////#pragma HLS INLINE\012\012	// For data type conversion to decrease BRAM usage: FACTOR*BUFFER_NUM = (KERN_SIZE-1)*VEC_NUM\012	const vx_uint16 FACTOR = sizeof(BufferType) / sizeof(InType);\012\012	// Buffer for data type conversion\012	InType buffer1[(KERN_SIZE - 1)*VEC_NUM];\012//#pragma HLS array_partition variable=buffer1 complete dim=0\012	BufferType buffer2[BUFFER_NUM];\012//#pragma HLS array_partition variable=buffer2 complete dim=0\012\012	// Check linebuffer border\012	if (x < VEC_COLS) {\012\012		// Unpack data from input\012#pragma unroll\012		for (vx_uint16 i = 0; i < KERN_SIZE - 1; i++) {\012#pragma unroll\012			for (vx_uint16 j = 0; j < VEC_NUM; j++) {\012				buffer1[i*VEC_NUM + j] = input[i + 1][j];\012			}\012		}\012\012		// Pack data for linebuffer\012#pragma unroll\012		for (vx_uint16 i = 0; i < BUFFER_NUM; i++) {\012			BufferType data = 0;\012#pragma unroll\012			for (vx_uint16 j = 0; j < FACTOR; j++) {\012				vx_uint16 shift = j * static_cast<vx_uint16>(sizeof(InType)) * static_cast<vx_uint16>(8);\012				data |= (static_cast<BufferType>(buffer1[i*FACTOR + j])) << shift;\012			}\012			buffer2[i] = data;\012		}\012\012		// Write to linebuffer\012#pragma unroll\012		for (vx_uint16 i = 0; i < BUFFER_NUM; i++) {\012			linebuffer[i][x] = buffer2[i];\012		}		\012	}\012}\012\012/*********************************************************************************************************************/\012/* Sliding Window Functions for Different Border Types */\012/*********************************************************************************************************************/\012\012/** @brief Replicates the y borders if needed for the sliding window\012@param VecType     1 vector is 1 linebuffer element\012@param IMG_ROWS    Amount of rows in the image\012@param KERN_RAD    Radius of the filter kernel\012@param KERN_SIZE   Total amount of rows in the sliding window\012@param input       Output of the linebuffers\012@param output      Input with replicated borders if needed\012@param y           y coordinate of the image\012*/\012template <typename InType, const vx_uint8 VEC_NUM, const vx_uint32 IMG_ROWS, const vx_uint16 KERN_RAD, const vx_uint16 KERN_SIZE>\012void SlidingWindowReplicatedY(const InType input[KERN_SIZE][VEC_NUM], InType output[KERN_SIZE][VEC_NUM], const vx_uint16 y) {\012////#pragma HLS INLINE\012\012	// Get upper pixels and check y border\012	if (KERN_RAD > 0) {\012#pragma unroll\012		for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012			output[KERN_RAD - 1][v] = (y > KERN_RAD) ? (input[KERN_RAD - 1][v]) : (input[KERN_RAD][v]);\012		}\012		//output[KERN_RAD - 1] = (y > KERN_RAD) ? (input[KERN_RAD - 1]) : (input[KERN_RAD]);\012#pragma unroll\012		for (vx_int32 i = KERN_RAD - 2; i >= 0; i--) {\012#pragma unroll\012			for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012				output[i][v] = (y > static_cast<vx_uint16>(KERN_SIZE - 2 - i)) ? (input[i][v]) : (output[i + 1][v]);\012			}\012		}\012	}\012\012	// Pass through observed pixel in the image\012#pragma unroll\012	for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012		output[KERN_RAD][v] = input[KERN_RAD][v];\012	}\012\012	// Get lower pixels and check y border\012	if (KERN_RAD > 0) {\012#pragma unroll\012		for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012			output[KERN_RAD + 1][v] = (y < IMG_ROWS + KERN_RAD - 1) ? (input[KERN_RAD + 1][v]) : (input[KERN_RAD][v]);\012		}\012#pragma unroll\012		for (vx_uint16 i = KERN_RAD + 2; i < KERN_SIZE; i++) {\012#pragma unroll\012			for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012				output[i][v] = (y < static_cast<vx_uint16>(IMG_ROWS + KERN_SIZE - 1 - i)) ? (input[i][v]) : (output[i - 1][v]);\012			}\012		}\012	}\012}\012\012/** @brief Moves sliding window and a replicated border in x direction\012@param ScalarType  The data type of the image elements\012@param KERN_SIZE   Total amount of rows in the sliding window\012@param VEC_COLS    The amount of columns in the vectorized image\012@param VEC_SIZE    The number of elements in a vector\012@param WIN_BORD_A  Internal vertical border for the sliding window\012@param WIN_BORD_B  Internal vertical border for the sliding window\012@param WIN_COLS    The number of columns in a row\012@param input       An array of input data for each row\012@param window      The sliding window\012@param x           x coordinate of the vectorized image\012*/\012template <typename ScalarType, const vx_uint16 KERN_SIZE, const vx_uint16 VEC_COLS, const vx_uint16 VEC_SIZE, const vx_uint16 WIN_BORD_A, const vx_uint16 WIN_BORD_B, const vx_uint16 WIN_COLS>\012void SlidingWindowReplicatedX(ScalarType input[KERN_SIZE][VEC_SIZE], ScalarType window[KERN_SIZE][WIN_COLS], const vx_uint16 x) {\012////#pragma HLS INLINE\012\012	// Move sliding window and check x border\012#pragma unroll\012	for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012\012		// Move sliding window\012#pragma unroll\012		for (vx_uint16 j = 0; j < WIN_BORD_A; j++) {\012			window[i][j] = window[i][j + VEC_SIZE];\012		}\012\012		// Move pixel in sliding window and get/check left x border\012#pragma unroll\012		for (vx_uint16 j = WIN_BORD_A; j < WIN_BORD_B; j++) {\012			if (x == 0)\012				window[i][j] = input[i][0];\012			else\012				window[i][j] = window[i][j + VEC_SIZE];\012		}\012\012		// Get new pixel array and check right x border\012#pragma unroll\012		for (vx_uint16 j = WIN_BORD_B; j < WIN_COLS; j++) {\012			if (x >= VEC_COLS) {\012				window[i][j] = window[i][WIN_BORD_B-1];\012			} else {\012				window[i][j] = input[i][j - WIN_BORD_B];\012			}\012		}\012	}\012}\012\012/** @brief Sets a constant border of 0 for the sliding window\012@param VecType     1 vector is 1 linebuffer element\012@param IMG_ROWS    Amount of rows in the image\012@param KERN_RAD    Radius of the filter kernel\012@param KERN_SIZE   Total amount of rows in the sliding window\012@param input       Output of the linebuffers\012@param output      Input with replicated borders if needed\012@param y           y coordinate of the image\012*/\012template <typename InType, const vx_uint8 VEC_NUM, const vx_uint32 IMG_ROWS, const vx_uint16 KERN_RAD, const vx_uint16 KERN_SIZE>\012void SlidingWindowConstantY(const InType input[KERN_SIZE][VEC_NUM], InType output[KERN_SIZE][VEC_NUM], const vx_uint16 y) {\012////#pragma HLS INLINE\012\012	// Get upper pixels and check y border\012#pragma unroll\012	for (vx_uint16 i = 0; i < KERN_RAD; i++) {\012#pragma unroll\012		for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012			output[i][v] = (y > KERN_SIZE - 2 - i) ? (input[i][v]) : (0);\012		}\012	}\012\012	// Pass through observed pixel in the image\012#pragma unroll\012	for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012		output[KERN_RAD][v] = input[KERN_RAD][v];\012	}\012\012	// Get lower pixels and check y border\012#pragma unroll\012	for (vx_uint16 i = KERN_RAD + 1; i < KERN_SIZE; i++) {\012#pragma unroll\012		for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012			output[i][v] = (y < IMG_ROWS + KERN_SIZE - 1 - i) ? (input[i][v]) : (0);\012		}\012	}\012}\012\012/** @brief Moves sliding window and a constant border in x direction\012@param ScalarType  The data type of the image elements\012@param KERN_SIZE   Total amount of rows in the sliding window\012@param VEC_COLS    The amount of columns in the vectorized image\012@param VEC_SIZE    The number of elements in a vector\012@param WIN_BORD_A  Internal vertical border for the sliding window\012@param WIN_BORD_B  Internal vertical border for the sliding window\012@param WIN_COLS    The number of columns in a row\012@param input       An array of input data for each row\012@param window      The sliding window\012@param x           x coordinate of the vectorized image\012*/\012template <typename ScalarType, const vx_uint16 KERN_SIZE, const vx_uint16 VEC_COLS, const vx_uint16 VEC_SIZE, const vx_uint16 WIN_BORD_A, const vx_uint16 WIN_BORD_B, const vx_uint16 WIN_COLS>\012void SlidingWindowConstantX(ScalarType input[KERN_SIZE][VEC_SIZE], ScalarType window[KERN_SIZE][WIN_COLS], const vx_uint16 x) {\012////#pragma HLS INLINE\012\012#pragma unroll\012	for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012\012		// Move sliding window\012#pragma unroll\012		for (vx_uint16 j = 0; j < WIN_BORD_A; j++) {\012			window[i][j] = window[i][j + VEC_SIZE];\012		}\012\012		// Move pixel in sliding window and get/check left x border\012#pragma unroll\012		for (vx_uint16 j = WIN_BORD_A; j < WIN_BORD_B; j++) {\012			if (x == 0)\012				window[i][j] = 0;\012			else\012				window[i][j] = window[i][j + VEC_SIZE];\012		}\012\012		// Get new pixel vector and check right x border\012#pragma unroll\012		for (vx_uint16 j = WIN_BORD_B; j < WIN_COLS; j++) {\012			if (x >= VEC_COLS)\012				window[i][j] = 0;\012			else\012				window[i][j] = input[i][j - WIN_BORD_B];\012		}\012	}\012}\012\012/** @brief Moves sliding window without considering borders\012@param ScalarType  The data type of the image elements\012@param KERN_SIZE   Total amount of rows in the sliding window\012@param VEC_SIZE    The number of elements in a vector\012@param WIN_BORD_B  Internal vertical border for the sliding window\012@param WIN_COLS    The number of columns in a row\012@param input       An array of input data for each row\012@param window      The sliding window\012*/\012template <typename ScalarType, const vx_uint16 KERN_SIZE, const vx_uint16 VEC_SIZE, const vx_uint16 WIN_BORD_B, const vx_uint16 WIN_COLS>\012void SlidingWindowUnchanged(const ScalarType input[KERN_SIZE][VEC_SIZE], ScalarType window[KERN_SIZE][WIN_COLS]) {\012////#pragma HLS INLINE\012\012#pragma unroll\012	for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012\012		// Move sliding window\012#pragma unroll\012		for (vx_uint16 j = 0; j < WIN_BORD_B; j++) {\012			window[i][j] = window[i][j + VEC_SIZE];\012		}\012\012		// Get new pixel vector\012#pragma unroll\012		for (vx_uint16 j = WIN_BORD_B; j < WIN_COLS; j++) {\012			window[i][j] = input[i][j - WIN_BORD_B];\012		}\012	}\012}\012\012/*********************************************************************************************************************/\012/* Main sliding Window Functions */\012/*********************************************************************************************************************/\012\012/** @brief Sliding window horizontal main function / considers different border types\012@param VecType     1 vector is processed in each clock cycle\012@param ScalarType  1 vector contains N scalar elements\012@param KERN_RAD    Radius of the filter kernel\012@param VEC_COLS    The amount of columns in the vectorized image\012@param VEC_SIZE    The number of elements in a vector\012@param WIN_COLS    The number of columns in a row\012@param BORDER_TYPE The border type that is considered in the sliding window\012@param input       The input buffer\012@param window      The output sliding window\012@param x           The x current coordinate\012*/\012template <typename ScalarType, const vx_uint16 KERN_RAD, const vx_uint16 VEC_COLS, const vx_uint16 VEC_SIZE, const vx_uint16 WIN_COLS, const vx_border_e BORDER_TYPE>\012void SlidingWindowHorizontal(const ScalarType input[VEC_SIZE], ScalarType window[1][WIN_COLS], const vx_uint16 x) {\012////#pragma HLS INLINE\012\012	// Constants\012	const vx_uint16 WIN_BORD_A = WIN_COLS - VEC_SIZE - KERN_RAD;\012	const vx_uint16 WIN_BORD_B = WIN_COLS - VEC_SIZE;\012\012	// Input data rows in scalar representation (after considering y border)\012	ScalarType input_vector[1][VEC_SIZE];\012//#pragma HLS array_partition variable=input_vector complete  dim=0\012\012#pragma unroll\012	for (vx_uint16 i = 0; i < VEC_SIZE; i++) {\012		input_vector[0][i] = input[i];\012	}\012\012	// REPLICATED: replicates the border values when exceeding borders\012	if (BORDER_TYPE == VX_BORDER_REPLICATE) {\012\012		// Sets sliding window and replicated x borders\012		SlidingWindowReplicatedX<ScalarType, 1, VEC_COLS, VEC_SIZE, WIN_BORD_A, WIN_BORD_B, WIN_COLS>(input_vector, window, x);\012\012	// CONSTANT: creates a constant border of zeros around the image\012	} else if (BORDER_TYPE == VX_BORDER_CONSTANT) {\012\012		// Sets sliding window and constant x borders\012		SlidingWindowConstantX<ScalarType, 1, VEC_COLS, VEC_SIZE, WIN_BORD_A, WIN_BORD_B, WIN_COLS>(input_vector, window, x);\012\012	// UNCHANGED: filters exceeding the borders are invalid\012	} else if (BORDER_TYPE == VX_BORDER_UNDEFINED) {\012\012		// Sets sliding window and does not create borders\012		SlidingWindowUnchanged<ScalarType, 1, VEC_SIZE, WIN_BORD_B, WIN_COLS>(input_vector, window);\012	}\012}\012\012/** @brief Sliding window main function / considers different border types\012@param VecType     1 vector is processed in each clock cycle\012@param ScalarType  1 vector contains N scalar elements\012@param IMG_ROWS    Amount of rows in the image\012@param KERN_RAD    Radius of the filter kernel\012@param VEC_SIZE    The number of elements in a vector\012@param KERN_SIZE   Total amount of rows in the sliding window\012@param BORDER_TYPE The border type that is considered in the sliding window\012@param input       The input buffer\012@param window      The output sliding window\012@param y           The y current coordinate\012*/\012template <typename ScalarType, const vx_uint32 IMG_ROWS, const vx_uint16 KERN_RAD, const vx_uint16 VEC_SIZE, const vx_uint16 KERN_SIZE, const vx_border_e BORDER_TYPE>\012void SlidingWindowVertical(const ScalarType input[KERN_SIZE][VEC_SIZE], ScalarType window[KERN_SIZE][VEC_SIZE], const vx_uint16 y) {\012////#pragma HLS INLINE\012\012	// Input data rows in vector representation (after considering y border)\012	ScalarType buffer_vector[KERN_SIZE][VEC_SIZE];\012//#pragma HLS array_partition variable=buffer_vector complete dim=0\012\012	// REPLICATED: replicates the border values when exceeding borders\012	if (BORDER_TYPE == VX_BORDER_REPLICATE) {\012\012		// Replicated y borders\012		SlidingWindowReplicatedY<ScalarType, VEC_SIZE, IMG_ROWS, KERN_RAD, KERN_SIZE>(input, buffer_vector, y);\012\012	// CONSTANT: creates a constant border of zeros around the image\012	} else if (BORDER_TYPE == VX_BORDER_CONSTANT) {\012\012		// Constant y borders\012		SlidingWindowConstantY<ScalarType, VEC_SIZE, IMG_ROWS, KERN_RAD, KERN_SIZE>(input, buffer_vector, y);\012	}\012\012	// Convert from vector to scalar type\012#pragma unroll\012	for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012#pragma unroll			\012		for (vx_uint16 j = 0; j < VEC_SIZE; j++) {\012			if(BORDER_TYPE == VX_BORDER_REPLICATE || BORDER_TYPE == VX_BORDER_CONSTANT)\012				window[i][j] = buffer_vector[i][j];\012			else if(BORDER_TYPE == VX_BORDER_UNDEFINED)\012				window[i][j] = input[i][j];\012		}\012	}\012}\012\012/** @brief Sliding window main function / considers different border types\012@param VecType     1 vector is processed in each clock cycle\012@param ScalarType  1 vector contains N scalar elements\012@param IMG_ROWS    Amount of rows in the image\012@param KERN_RAD    Radius of the filter kernel\012@param VEC_COLS    The amount of columns in the vectorized image\012@param VEC_SIZE    The number of elements in a vector\012@param WIN_COLS    The number of columns in a row\012@param KERN_SIZE   Total amount of rows in the sliding window\012@param BORDER_TYPE The border type that is considered in the sliding window\012@param input       The input buffer\012@param window      The output sliding window\012@param x           The x current coordinate\012@param y           The y current coordinate\012*/\012template <typename InType, const vx_uint8 VEC_NUM, const vx_uint32 IMG_ROWS, const vx_uint16 KERN_RAD, const vx_uint16 VEC_COLS, const vx_uint16 WIN_COLS, const vx_uint16 KERN_SIZE, const vx_border_e BORDER_TYPE>\012void SlidingWindow(const InType input[KERN_SIZE][VEC_NUM], InType window[KERN_SIZE][WIN_COLS], const vx_uint16 x, const vx_uint16 y) {\012////#pragma HLS INLINE\012\012	// Constants\012	const vx_uint16 WIN_BORD_A = WIN_COLS - VEC_NUM - KERN_RAD;\012	const vx_uint16 WIN_BORD_B = WIN_COLS - VEC_NUM;\012\012	// Input data rows in vector representation (after considering y border)\012	InType buffer_vector[KERN_SIZE][VEC_NUM];\012//#pragma HLS array_partition variable=buffer_vector complete dim=0\012\012	// REPLICATED: replicates the border values when exceeding borders\012	if (BORDER_TYPE == VX_BORDER_REPLICATE) {\012\012		// Replicated y borders\012		SlidingWindowReplicatedY<InType, VEC_NUM, IMG_ROWS, KERN_RAD, KERN_SIZE>(input, buffer_vector, y);\012\012		// Sets sliding window and replicated x borders\012		SlidingWindowReplicatedX<InType, KERN_SIZE, VEC_COLS, VEC_NUM, WIN_BORD_A, WIN_BORD_B, WIN_COLS>(buffer_vector, window, x);\012\012	// CONSTANT: creates a constant border of zeros around the image\012	} else if (BORDER_TYPE == VX_BORDER_CONSTANT) {\012\012		// Constant y borders\012		SlidingWindowConstantY<InType, VEC_NUM, IMG_ROWS, KERN_RAD, KERN_SIZE>(input, buffer_vector, y);\012\012		// Sets sliding window and constant x borders\012		SlidingWindowConstantX<InType, KERN_SIZE, VEC_COLS, VEC_NUM, WIN_BORD_A, WIN_BORD_B, WIN_COLS>(buffer_vector, window, x);\012\012	// UNCHANGED: filters exceeding the borders are invalid\012	} else if (BORDER_TYPE == VX_BORDER_UNDEFINED) {\012\012		// Sets sliding window and does not create borders\012		SlidingWindowUnchanged<InType, KERN_SIZE, VEC_NUM, WIN_BORD_B, WIN_COLS>(input, window);\012	}\012}\012\012/*********************************************************************************************************************/\012/* Filter Sub-Functions */\012/*********************************************************************************************************************/\012\012/** @brief Compares and swaps 2 elements\012@param InType  Data type of the image pixels\012@param A       1. element to be compared\012@param B       2. element to be compared\012@param H       smaller element\012@param L       bigger element\012*/\012template <typename InType>\012void CompareAndSwap(InType A, InType B, InType &L, InType &H) {\012////#pragma HLS INLINE\012\012	// Compare and Swap\012	if (A > B) {\012		L = B;\012		H = A;\012	} else {\012		L = A;\012		H = B;\012	}\012}\012\012/*********************************************************************************************************************/\012/* Filter Functions */\012/*********************************************************************************************************************/\012\012/** @brief Computes a 1d box filter\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KERN_SIZE     The size of the kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the box filter\012*/\012template <typename ScalarType, const vx_uint16 KERN_SIZE>\012ScalarType ComputeBox1d(ScalarType window[KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012////#pragma HLS INLINE\012\012	// Variable\012	vx_uint64 result = 0;\012\012	// Sum all input data\012#pragma unroll\012	for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012		result += static_cast<vx_uint64>(window[i]);\012	}\012\012	// Normalize\012	const vx_uint64 rounding = static_cast<vx_uint64>(1) << (kernel_shift - 1);\012	const vx_uint64 norm = (result * kernel_mult + rounding) >> kernel_shift;\012\012	// Return result\012	return static_cast<ScalarType>(norm);\012}\012\012/** @brief Computes a 2d box filter\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KERN_SIZE     The size of the kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the box filter\012*/\012template <typename InType, typename OutType, const vx_uint16 KERN_SIZE>\012OutType ComputeBox2d(InType window[KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012////#pragma HLS INLINE\012\012	// Variable\012	vx_uint64 result = 0;\012\012	// Sum all input data\012#pragma unroll\012	for (vx_uint16 y = 0; y < KERN_SIZE; y++) {\012#pragma unroll\012		for (vx_uint16 x = 0; x < KERN_SIZE; x++) {\012			result += static_cast<vx_uint64>(window[y][x]);\012		}\012	}\012\012	// Normalize\012	const vx_uint64 rounding = static_cast<vx_uint64>(1) << (kernel_shift - 1);\012	const vx_uint64 norm = (result * kernel_mult + rounding) >> kernel_shift;\012\012	// Return result\012	return static_cast<OutType>(norm);\012}\012\012/** @brief Computes a 2d convolution filter\012@param InType        The input scalar data type\012@param CompType      Data type for internal computation (uint64 or int64)\012@param OutType       The output scalar data type\012@param KernType      The kernel scalar data type\012@param KERN_SIZE     The size of the kernel\012@param inKernel      The costum kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the convolution filter\012*/\012template <typename InType, typename CompType, typename OutType, typename KernType, const vx_uint16 KERN_SIZE>\012OutType ComputeConvolve2d(KernType kernel[KERN_SIZE][KERN_SIZE], InType window[KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012////#pragma HLS INLINE\012	\012	// Variables\012	CompType result = 0;\012\012	// Compute the costum filter\012#pragma unroll\012	for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012#pragma unroll\012		for (vx_uint16 j = 0; j < KERN_SIZE; j++) {\012			CompType kernelData = static_cast<CompType>(kernel[i][j]);\012			CompType windowData = static_cast<CompType>(window[i][j]);\012			result += (kernelData * windowData);\012		}\012	}\012\012	// Normalize\012	const vx_uint64 rounding = static_cast<vx_uint64>(1) << (kernel_shift - 1);\012	const vx_uint64 norm = (result * kernel_mult + rounding) >> kernel_shift;\012\012	// Return result\012	return static_cast<OutType>(norm);\012}\012\012/** @brief Computes a 1d dilate filter\012@param ScalarType    The Scalar Data type\012@param KERN_SIZE     The size of the kernel\012@param window        The sliding window of this scalar computation\012@return              The result of the dilate filter\012*/\012template <typename ScalarType, const vx_uint16 KERN_SIZE>\012ScalarType ComputeDilate1d(ScalarType window[KERN_SIZE]) {\012////#pragma HLS INLINE\012\012	// Compute dilate\012	ScalarType result = window[0];\012#pragma unroll\012	for (vx_uint16 i = 1; i < KERN_SIZE; i++) {\012		result = max(result, window[i]);\012	}\012\012	// Return result\012	return result;\012}\012\012/** @brief Computes a 1d erode filter\012@param ScalarType    The Scalar Data type\012@param KERN_SIZE     The size of the kernel\012@param window        The sliding window of this scalar computation\012@return              The result of the erode filter\012*/\012template <typename ScalarType, const vx_uint16 KERN_SIZE>\012ScalarType ComputeErode1d(ScalarType window[KERN_SIZE]) {\012////#pragma HLS INLINE\012\012	// Compute erode\012	ScalarType result = window[0];\012#pragma unroll\012	for (vx_uint16 i = 1; i < KERN_SIZE; i++) {\012		result = min(result, window[i]);\012	}\012\012	// Return result\012	return result;\012}\012\012/** @brief Computes a gaussian 1d filter (optimized to the kernel symmetry)\012@param ScalarType    The input/output data type\012@param KernType      The kernel scalar data type\012@param KERN_SIZE     The size of the kernel\012@param kernel        The gaussian kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the gaussian convolution\012*/\012template <typename ScalarType, typename KernelType, const vx_uint16 KERN_SIZE>\012ScalarType ComputeGaussian1d(KernelType kernel[KERN_SIZE], ScalarType window[KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012////#pragma HLS INLINE\012\012	// Constants\012	const vx_uint16 KERN_RAD = KERN_SIZE >> 1;\012\012	// Get middle pixel result\012	vx_uint64 result = static_cast<vx_uint64>(kernel[KERN_RAD]) * static_cast<vx_uint64>(window[KERN_RAD]);\012\012	// Add all other pixel to result\012#pragma unroll\012	for (vx_uint16 i = 0; i < KERN_RAD; i++) {\012		vx_uint64 A = static_cast<vx_uint64>(kernel[i]);\012		vx_uint64 B0 = static_cast<vx_uint64>(window[i]);\012		vx_uint64 B1 = static_cast<vx_uint64>(window[KERN_SIZE - i - 1]);\012		result += A * (B0 + B1);\012	}\012\012	// Normalize\012	const vx_uint64 rounding = static_cast<vx_uint64>(1) << (kernel_shift - 1);\012	const vx_uint64 norm = (result * kernel_mult + rounding) >> kernel_shift;\012\012	// Return result\012	return static_cast<ScalarType>(norm);\012}\012\012/** @brief Computes a gaussian 2d filter (optimized to the kernel symmetry)\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KernType      The kernel scalar data type\012@param KERN_SIZE     The size of the kernel\012@param kernel        The gaussian kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the gaussian convolution\012*/\012template <typename InType, typename OutType, typename KernType, const vx_uint16 KERN_SIZE>\012OutType ComputeGaussian2d(KernType kernel[KERN_SIZE][KERN_SIZE], InType window[KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012////#pragma HLS INLINE\012\012	// Constants\012	const vx_uint16 KERN_RAD = KERN_SIZE / 2;\012	const vx_uint16 KERN_RNG = KERN_SIZE - 1;\012\012	// Store result of the gaussian filter (scalar)\012	vx_uint64 result = 0;\012\012	// if: (y == KERN_RAD) && (x == KERN_RAD)\012	{\012		vx_uint64 sum = static_cast<vx_uint64>(window[KERN_RAD][KERN_RAD]);\012		result = (static_cast<vx_uint64>(kernel[KERN_RAD][KERN_RAD]) * sum);\012	}\012\012	// if: (y == KERN_RAD) && (x < KERN_RAD)\012#pragma unroll\012	for (vx_uint16 x = 0; x < KERN_RAD; x++) {\012		const vx_uint16 RADIUS = KERN_RAD - x;\012		vx_uint64 sum = 0;\012		sum += static_cast<vx_uint64>(window[KERN_RAD][x]);\012		sum += static_cast<vx_uint64>(window[KERN_RAD][KERN_RNG - x]);\012		sum += static_cast<vx_uint64>(window[KERN_RAD + RADIUS][x + RADIUS]);\012		sum += static_cast<vx_uint64>(window[KERN_RAD - RADIUS][x + RADIUS]);\012		result += (static_cast<vx_uint64>(kernel[KERN_RAD][x]) * sum);\012	}\012\012	// if: (y == x) && (x < KERN_RAD)\012#pragma unroll\012	for (vx_uint16 y = 0; y < KERN_RAD; y++) {\012		vx_uint64 sum = 0;\012		sum += static_cast<vx_uint64>(window[y][y]);\012		sum += static_cast<vx_uint64>(window[y][KERN_RNG - y]);\012		sum += static_cast<vx_uint64>(window[KERN_RNG - y][y]);\012		sum += static_cast<vx_uint64>(window[KERN_RNG - y][KERN_RNG - y]);\012		result += (static_cast<vx_uint64>(kernel[y][y]) * sum);\012	}\012\012	// if: (y > 0) && (y < KERN_RAD) && (y > x)\012#pragma unroll\012	for (vx_uint16 x = 0; x <= KERN_RAD; x++) {\012#pragma unroll\012		for (vx_uint16 y = x + 1; y < KERN_RAD; y++) {\012			vx_int64 sum = 0;\012			sum += static_cast<vx_uint64>(window[y][x]);\012			sum += static_cast<vx_uint64>(window[x][y]);\012			sum += static_cast<vx_uint64>(window[KERN_RNG - y][x]);\012			sum += static_cast<vx_uint64>(window[x][KERN_RNG - y]);\012			sum += static_cast<vx_uint64>(window[KERN_RNG - x][y]);\012			sum += static_cast<vx_uint64>(window[y][KERN_RNG - x]);\012			sum += static_cast<vx_uint64>(window[KERN_RNG - x][KERN_RNG - y]);\012			sum += static_cast<vx_uint64>(window[KERN_RNG - y][KERN_RNG - x]);\012			result += (static_cast<vx_uint64>(kernel[y][x]) * sum);\012		}\012	}\012	\012	// Normalize\012	const vx_uint64 rounding = static_cast<vx_uint64>(1) << (kernel_shift - 1);\012	const vx_uint64 norm = (result * kernel_mult + rounding) >> kernel_shift;\012\012	// Return result\012	return static_cast<OutType>(norm);\012}\012\012/** @brief Computes a median filter\012@details Algorithm taken from the the following paper: \012A fault-tolerant implementation of the median filter \012from L. A. Aranda and P. Reviriego and J. A. Maestro\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KERN_SIZE     The size of the kernel\012@param window        The sliding window of this scalar computation\012@return              The result of the median filter\012*/\012template <typename InType, typename OutType, const vx_uint16 KERN_SIZE>\012OutType ComputeMedian3x3(InType window[KERN_SIZE][KERN_SIZE]) {\012////#pragma HLS INLINE\012\012	// Variables\012	InType B0, B1, B3, B4, B6, B7;\012	InType C1, C2, C4, C5, C7, C8;\012	InType D0, D1, D3, D4, D6, D7;\012	InType E0, E1, E3, E4, E7, E8;\012	InType F1, F2, F4, F5, F6, F7;\012	InType G3, G4, H3, H4, I4, I5, J3, J4;\012\012	// Input pixel\012	InType A0 = window[0][0], A1 = window[0][1], A2 = window[0][2];\012	InType A3 = window[1][0], A4 = window[1][1], A5 = window[1][2];\012	InType A6 = window[2][0], A7 = window[2][1], A8 = window[2][2];\012\012	// Get median with 19 compare and swap units\012	CompareAndSwap(A0, A1, B0, B1);\012	CompareAndSwap(A3, A4, B3, B4);\012	CompareAndSwap(A6, A7, B6, B7);\012	CompareAndSwap(B1, A2, C1, C2);\012	CompareAndSwap(B4, A5, C4, C5);\012	CompareAndSwap(B7, A8, C7, C8);\012	CompareAndSwap(B0, C1, D0, D1);\012	CompareAndSwap(B3, C4, D3, D4);\012	CompareAndSwap(B6, C7, D6, D7);\012	CompareAndSwap(D0, D3, E0, E1);\012	CompareAndSwap(D1, D4, E3, E4);\012	CompareAndSwap(C5, C8, E7, E8);\012	CompareAndSwap(E1, D6, F1, F2);\012	CompareAndSwap(E4, D7, F4, F5);\012	CompareAndSwap(C2, E7, F6, F7);\012	CompareAndSwap(E3, F4, G3, G4);\012	CompareAndSwap(F2, G4, H3, H4);\012	CompareAndSwap(H4, F6, I4, I5);\012	CompareAndSwap(H3, I4, J3, J4);\012\012	// Take median value\012	return static_cast<OutType>(J4);\012}\012\012/** @brief Computes a median filter\012@details Algorithm taken from the the following book:\012Knuth in The Art of Computer Programming, vol 3 (algorithm 5.2.2M)\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KERN_SIZE     The size of the kernel\012@param window        The sliding window of this scalar computation\012@return              The result of the median filter\012*/\012template <typename InType, typename OutType, const vx_uint16 KERN_SIZE>\012OutType ComputeMedian(InType window[KERN_SIZE][KERN_SIZE]) {\012////#pragma HLS INLINE\012\012	// Constants and variables\012	const vx_uint16 BUFFER_SIZE = KERN_SIZE * KERN_SIZE;\012	const vx_uint16 BUFFER_RAD = BUFFER_SIZE >> 1;\012	vx_uint16 START = 1;\012	vx_uint16 row_ptr = 0;\012	vx_uint16 SCALE = BUFFER_SIZE - 1;\012	vx_uint16 MSB = 0;\012\012	// Register stages for pipelining of the sorting\012	InType buffer[BUFFER_SIZE + 1][BUFFER_SIZE];\012//#pragma HLS array_partition variable=buffer complete dim=0\012\012	// Pre-computation\012#pragma unroll\012	for (vx_uint16 i = 0; i < sizeof(vx_uint16) * 8; i++) {\012		if ((SCALE & static_cast<vx_uint16>(1 << i)) != 0)\012			MSB = i;\012	}\012#pragma unroll\012	for (vx_uint16 i = 0; i < MSB; i++) {\012		START *= 2;\012	}\012\012	// 2d to 1d input window conversion\012#pragma unroll\012	for (vx_uint16 i = 0, ptr = 0; i < KERN_SIZE; i++) {\012#pragma unroll\012		for (vx_uint16 j = 0; j < KERN_SIZE; j++) {\012			buffer[0][ptr] = window[i][j];\012			ptr++;\012		}\012	}\012\012	// Sort array using odd-even mergesort\012#pragma unroll\012	for (vx_uint16 p = START; p > 0; p >>= 1) {\012#pragma unroll\012		for (vx_uint16 q = START, r = 0, d = p; d > 0; d = q - p, q >>= 1, r = p) {\012#pragma unroll\012			for (vx_uint16 i = 0; i < BUFFER_SIZE; i++) {\012				buffer[row_ptr + 1][i] = buffer[row_ptr][i];\012			}\012#pragma unroll\012			for (vx_uint16 i = 0; i < BUFFER_SIZE - d; i++) {\012				if ((i & p) == r)\012					CompareAndSwap<InType>(buffer[row_ptr][i], buffer[row_ptr][i + d], buffer[row_ptr + 1][i], buffer[row_ptr + 1][i + d]);\012			}\012			row_ptr++;\012		}\012	}\012\012	// Take median value\012	return static_cast<OutType>(buffer[row_ptr][BUFFER_RAD]);\012}\012\012/** @brief Computes the x derivative (optimized for kernel symmetry)\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KernType      The kernel scalar data type\012@param KERN_SIZE     The size of the kernel\012@param kernel        The sobel/scharr kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the x derivative computation\012*/\012template <typename InType, typename OutType, typename KernType, const vx_uint16 KERN_SIZE>\012OutType ComputeDerivativeX(KernType kernel[KERN_SIZE][KERN_SIZE], InType window[KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012////#pragma HLS INLINE\012\012	// Constants\012	const vx_uint16 KERN_RAD = KERN_SIZE >> 1;\012	const vx_uint16 KERN_RANGE = KERN_SIZE - 1;\012\012	// Compute the filter result\012	vx_int64 result = 0;\012\012#pragma unroll\012	for (vx_uint16 y = 0; y < KERN_RAD + 1; y++) {\012#pragma unroll\012		for (vx_uint16 x = 0; x < KERN_RAD; x++) {\012\012			// Constants\012			const vx_uint16 yn = y + KERN_RANGE - y * 2;\012			const vx_uint16 xn = x + KERN_RANGE - x * 2;			\012\012			// Compute mul\012			vx_int64 mul = abs(static_cast<vx_int64>(kernel[y][x]));\012\012			// compute sum\012			vx_int64 sum;\012			if (y < KERN_RAD) {\012				sum = static_cast<vx_int64>(window[y][xn]) +\012					static_cast<vx_int64>(window[yn][xn]) -\012					static_cast<vx_int64>(window[y][x]) - \012					static_cast<vx_int64>(window[yn][x]);\012			} else {\012				sum = static_cast<vx_int64>(window[y][xn]) -\012					static_cast<vx_int64>(window[y][x]);\012			}\012\012			// Add to result\012			result += sum*mul;\012		}\012	}\012\012	// Normalize\012	const vx_uint64 rounding = static_cast<vx_uint64>(1) << (kernel_shift - 1);\012	const vx_uint64 norm = (result * kernel_mult + rounding) >> kernel_shift;\012\012	// Return result\012	return static_cast<OutType>(norm);\012}\012\012/** @brief Computes the y derivative (optimized for kernel symmetry)\012@param InType        The input scalar data type\012@param OutType       The output scalar data type\012@param KernType      The kernel scalar data type\012@param KERN_SIZE     The size of the kernel\012@param kernel        The sobel/scharr kernel\012@param window        The sliding window of this scalar computation\012@param kernel_mult   Multiplier for normalization\012@param kernel_shift  Shifter For normalization\012@return              The result of the y derivative computation\012*/\012template <typename InType, typename OutType, typename KernType, const vx_uint16 KERN_SIZE>\012OutType ComputeDerivativeY(KernType kernel[KERN_SIZE][KERN_SIZE], InType window[KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift) {\012////#pragma HLS INLINE\012\012	// Constants\012	const vx_uint16 KERN_RAD = KERN_SIZE >> 1;\012	const vx_uint16 KERN_RANGE = KERN_SIZE - 1;\012\012	// Compute the filter result\012	vx_int64 result = 0;\012\012#pragma unroll\012	for (vx_uint16 x = 0; x < KERN_RAD + 1; x++) {\012#pragma unroll\012		for (vx_uint16 y = 0; y < KERN_RAD; y++) {\012\012			// Constants\012			const vx_uint16 yn = y + KERN_RANGE - y * 2;\012			const vx_uint16 xn = x + KERN_RANGE - x * 2;\012\012			// Compute mul\012			vx_int64 mul = abs(static_cast<vx_int64>(kernel[y][x]));\012\012			// compute sum\012			vx_int64 sum;\012			if (x < KERN_RAD) {\012				sum = static_cast<vx_int64>(window[yn][x]) +\012					static_cast<vx_int64>(window[yn][xn]) -\012					static_cast<vx_int64>(window[y][x]) -\012					static_cast<vx_int64>(window[y][xn]);\012			} else {\012				sum = static_cast<vx_int64>(window[yn][x]) -\012					static_cast<vx_int64>(window[y][x]);\012			}\012\012			// Add to result\012			result += sum*mul;\012		}\012	}\012\012	// Normalize\012	const vx_uint64 rounding = static_cast<vx_uint64>(1) << (kernel_shift - 1);\012	const vx_uint64 norm = (result * kernel_mult + rounding) >> kernel_shift;\012\012	// Return result\012	return static_cast<OutType>(norm);\012}\012\012/*********************************************************************************************************************/\012/* Filter Main Function */\012/*********************************************************************************************************************/\012\012/** @brief Selects and computes a 1d horizontal filter\012@param ScalarType   Data type of the input/output image\012@param KernelType   Data type of the kernel\012@param KERN_SIZE    Filter kernel size\012@param WIN_COLS     Columns of the sliding window\012@param VEC_NUM      Vector size\012@param window       The sliding window\012@param kernel       The convolution kernels\012@param kernel_mult  Resulting pixels are 1. multiplied by this amount\012@param kernel_shift Resulting pixels are 2. shifted to the right by this amount\012@param kernel_type  The type of convolution\012@param output       The results (vector) (per clock cycle)\012*/\012template <typename ScalarType, typename KernelType, vx_uint16 KERN_SIZE, vx_uint16 WIN_COLS, vx_uint16 VEC_NUM>\012void ComputeFilterHorizontal(ScalarType window[WIN_COLS], KernelType kernel[KERN_SIZE], \012	const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type, ScalarType output[VEC_NUM]) {\012////#pragma HLS INLINE\012\012#pragma unroll\012	for (vx_uint16 vecId = 0; vecId < VEC_NUM; vecId++) {\012\012		// Window for single vector element\012		ScalarType kernel_window[KERN_SIZE];\012//#pragma HLS array_partition variable=kernel_window complete dim=0\012\012		// Get window for single vector element\012#pragma unroll\012		for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012			kernel_window[i] = window[i + vecId];\012		}\012\012		// Compute filter for single vector element\012		ScalarType result = 0;\012		switch (kernel_type) {\012		case HIFLIPVX::GAUSSIAN_FILTER:\012			result = ComputeGaussian1d<ScalarType, KernelType, KERN_SIZE>(kernel, kernel_window, kernel_mult, kernel_shift);\012			break;\012		case HIFLIPVX::BOX_FILTER:\012			result = ComputeBox1d<ScalarType, KERN_SIZE>(kernel_window, kernel_mult, kernel_shift);\012			break;\012		case HIFLIPVX::ERODE_IMAGE:\012			result = ComputeErode1d<ScalarType, KERN_SIZE>(kernel_window);\012			break;\012		case HIFLIPVX::DILATE_IMAGE:\012			result = ComputeDilate1d<ScalarType, KERN_SIZE>(kernel_window);\012			break;\012		default:\012			break;\012		}\012		output[vecId] = result;\012	}\012}\012\012/** @brief Selects and computes a 1d vertical filter\012@param ScalarType   Data type of the input/output image\012@param KernelType   Data type of the kernel\012@param KERN_SIZE    Filter kernel size\012@param VEC_NUM      Vector size\012@param window       The sliding window\012@param kernel       The convolution kernels\012@param kernel_mult  Resulting pixels are 1. multiplied by this amount\012@param kernel_shift Resulting pixels are 2. shifted to the right by this amount\012@param kernel_type  The type of convolution\012@param output       The results (vector) (per clock cycle)\012*/\012template <typename ScalarType, typename KernelType, vx_uint16 KERN_SIZE, vx_uint16 VEC_NUM>\012void ComputeFilterVertical(ScalarType window[KERN_SIZE][VEC_NUM], KernelType kernel[KERN_SIZE], \012	const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type, vx_image<ScalarType, VEC_NUM> &output) {\012////#pragma HLS INLINE\012\012	// Output array of the different filter (scalar)\012	vx_image<ScalarType, VEC_NUM> output_array;\012\012#pragma unroll\012	for (vx_uint16 vecId = 0; vecId < VEC_NUM; vecId++) {\012\012		// Window for single vector element\012		ScalarType kernel_window[KERN_SIZE];\012//#pragma HLS array_partition variable=kernel_window complete dim=0\012\012		// Get window for single vector element\012#pragma unroll\012		for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012			kernel_window[i] = window[i][vecId];\012		}\012\012		// Compute filter for single vector element\012		ScalarType result = 0;\012		switch (kernel_type) {\012		case HIFLIPVX::GAUSSIAN_FILTER:\012			result = ComputeGaussian1d<ScalarType, KernelType, KERN_SIZE>(kernel, kernel_window, kernel_mult, kernel_shift);\012			break;\012		case HIFLIPVX::BOX_FILTER:\012			result = ComputeBox1d<ScalarType, KERN_SIZE>(kernel_window, kernel_mult, kernel_shift);\012			break;\012		case HIFLIPVX::ERODE_IMAGE:\012			result = ComputeErode1d<ScalarType, KERN_SIZE>(kernel_window);\012			break;\012		case HIFLIPVX::DILATE_IMAGE:\012			result = ComputeDilate1d<ScalarType, KERN_SIZE>(kernel_window);\012			break;\012		default:\012			break;\012		}\012		output_array.pixel[vecId] = result;\012	}\012\012	output = output_array;\012}\012\012/** @brief Selects and computes a filter\012@param InType       Data type of the input image\012@param OutType      Data type of the output image\012@param KernType     Data type of the kernel\012@param VEC_NUM     Vector size\012@param KERN_NUM     Amount of filter kernel\012@param KERN_SIZE    Filter kernel size\012@param WIN_COLS     Columns of the sliding window\012@param window       The sliding window\012@param kernel       The convolution kernels\012@param kernel_mult  Resulting pixels are 1. multiplied by this amount\012@param kernel_shift Resulting pixels are 2. shifted to the right by this amount\012@param kernel_type  The type of convolution\012@param output       The results (vector) (per clock cycle)\012*/\012template <typename InType, typename OutType, typename KernType, vx_uint16 VEC_NUM, vx_uint16 KERN_NUM, vx_uint16 KERN_SIZE, vx_uint16 WIN_COLS>\012void ComputeFilter(InType window[KERN_SIZE][WIN_COLS], KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE], \012	const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM], vx_image<OutType, VEC_NUM> output[KERN_NUM]) {\012////#pragma HLS INLINE\012\012	vx_image<OutType, VEC_NUM> output_vector[KERN_NUM];\012\012	// Compute KERN_NUM different filter with VEC_NUM elements per clock cycle\012#pragma unroll\012	for (vx_uint16 kernId = 0; kernId < KERN_NUM; kernId++) {\012#pragma unroll\012		for (vx_uint16 vecId = 0; vecId < VEC_NUM; vecId++) {\012\012			// Window for single vector element\012			InType kernel_window[KERN_SIZE][KERN_SIZE];\012//#pragma HLS array_partition variable=kernel_window complete dim=0\012\012			// Get window for single vector element\012#pragma unroll\012			for (vx_uint16 i = 0; i < KERN_SIZE; i++) {\012#pragma unroll\012				for (vx_uint16 j = 0; j < KERN_SIZE; j++) {\012					kernel_window[i][j] = window[i][j + vecId];\012				}\012			}\012\012			// Check, if input or output is signed\012			bool isSigned = (numeric_limits<InType>::is_signed) || (numeric_limits<OutType>::is_signed);\012\012			// Compute filter for single vector element\012			OutType result = 0;\012			switch (kernel_type[kernId]) {\012			case HIFLIPVX::GAUSSIAN_FILTER:\012				result = ComputeGaussian2d<InType, OutType, KernType, KERN_SIZE>(kernel[kernId], kernel_window, kernel_mult, kernel_shift);\012				break;\012			case HIFLIPVX::DERIVATIVE_X:\012				result = ComputeDerivativeX<InType, OutType, KernType, KERN_SIZE>(kernel[kernId], kernel_window, kernel_mult, kernel_shift);\012				break;\012			case HIFLIPVX::DERIVATIVE_Y:\012				result = ComputeDerivativeY<InType, OutType, KernType, KERN_SIZE>(kernel[kernId], kernel_window, kernel_mult, kernel_shift);\012				break;\012			case HIFLIPVX::CUSTOM_CONVOLUTION:\012				if (isSigned)\012					result = ComputeConvolve2d<InType, vx_int64, OutType, KernType, KERN_SIZE>(kernel[kernId], kernel_window, kernel_mult, kernel_shift);\012				else\012					result = ComputeConvolve2d<InType, vx_uint64, OutType, KernType, KERN_SIZE>(kernel[kernId], kernel_window, kernel_mult, kernel_shift);\012				break;\012			case HIFLIPVX::BOX_FILTER:\012				result = ComputeBox2d<InType, OutType, KERN_SIZE>(kernel_window, kernel_mult, kernel_shift);\012				break;\012			case HIFLIPVX::MEDIAN_FILTER:\012				if (KERN_SIZE == 3)\012					result = ComputeMedian3x3<InType, OutType, KERN_SIZE>(kernel_window);\012				else\012					result = ComputeMedian<InType, OutType, KERN_SIZE>(kernel_window);\012				break;\012			default:\012				break;\012			}\012\012			output_vector[kernId].pixel[vecId] = result;\012		}\012	}\012	if (KERN_NUM > 0)\012		output[0] = output_vector[0];\012	if (KERN_NUM > 1)\012		output[1] = output_vector[1];\012}\012\012/** @brief  Checks the input parameters of the convolution filter\012@param InType       Data type of the input image (8-bit, 16-bit, 32-bit)\012@param OutType      Data type of the output image (8-bit, 16-bit, 32-bit)\012@param VEC_NUM      Amount of pixels computed in parallel (1, 2, 4, 8)\012@param KERN_NUM     Amount of pixels computed in parallel (1, 2)\012@param IMG_COLS     Image width\012@param KERN_SIZE    Kernel size (3, 5, 7, 9, 11)\012*/\012template<typename InType, typename OutType, vx_uint16 VEC_NUM, vx_uint16 KERN_NUM, vx_uint16 IMG_COLS, vx_uint16 KERN_SIZE>\012void CheckFilterParameters() {\012\012	// Check function parameters/types\012	const vx_uint16 src_size = sizeof(InType);\012	const vx_uint16 dst_size = sizeof(OutType);\012	const bool allowed_kernel_size = (KERN_SIZE == 3) || (KERN_SIZE == 5) || (KERN_SIZE == 7) || (KERN_SIZE == 9) || (KERN_SIZE == 11);\012	const bool allowed_vector_size = (VEC_NUM == 1) || (VEC_NUM == 2) || (VEC_NUM == 4) || (VEC_NUM == 8);\012	const bool allowed_data_type = (src_size == 1) || (src_size == 2) || (src_size == 4);\012	const bool allowed_kernel_type = (src_size == 1) || (src_size == 2);\012	const bool allowed_kernel_num = (KERN_NUM == 1) || (KERN_NUM == 2);\012	STATIC_ASSERT(allowed_kernel_size, kernel_size_must_be_3_5_7_9_11);\012	STATIC_ASSERT((IMG_COLS % VEC_NUM == 0), image_colums_are_not_multiple_of_vector_size);\012	STATIC_ASSERT((src_size == dst_size), size_of_in_and_out_type_must_be_equal);\012	STATIC_ASSERT(allowed_vector_size, vector_size_must_be_1_2_4_8);\012	STATIC_ASSERT(allowed_data_type, data_type_must_be_8_16_32_bit);\012	STATIC_ASSERT(allowed_kernel_type, kernel_data_type_must_be_8_16_bit);\012	STATIC_ASSERT(allowed_kernel_num, kernel_num_can_only_be_1__or_2);\012}\012\012/*********************************************************************************************************************/\012/* Main Functions */\012/*********************************************************************************************************************/\012\012/** @brief  Computes multiple 1d convolution filter of kernel_type type\012@param ScalarType   Data type of the input/output image (8-bit, 16-bit, 32-bit)\012@param KernelType   Data type of the kernel (8-bit, 16-bit, 32-bit)\012@param BufferType   (sizeof(InType) * VEC_NUM * (KERN_SIZE - 1)) == (sizeof(BufferType) * BUFFER_NUM)\012@param BUFFER_NUM   (sizeof(InType) * VEC_NUM * (KERN_SIZE - 1)) == (sizeof(BufferType) * BUFFER_NUM)\012@param VEC_PIX      The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM      Amount of pixels computed in parallel (1, 2, 4, 8)\012@param KERN_NUM     Amount of pixels computed in parallel (1, 2)\012@param IMG_COLS     Image width\012@param IMG_ROWS     Image height\012@param KERN_SIZE    Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE  Type of border (Constant, Replicated or Undefined)\012@param input        Input image\012@param output       Output image\012@param kernel       The convolution kernel\012@param kernel_mult  Resulting pixels are 1. multiplied by this amount\012@param kernel_shift Resulting pixels are 2. shifted to the right by this amount\012@param kernel_type  The type of convolution\012*/\012template <typename ScalarType, typename KernelType, typename BufferType, vx_uint16 BUFFER_NUM, vx_uint32 VEC_PIX, vx_uint16 VEC_NUM, vx_uint16 IMG_COLS, vx_uint16 IMG_ROWS, vx_uint16 KERN_SIZE, vx_border_e BORDER_TYPE>\012void ComputeFilter1dFunc(vx_image<ScalarType, VEC_NUM> input[VEC_PIX], vx_image<ScalarType, VEC_NUM> output[VEC_PIX], KernelType kernel[KERN_SIZE], \012	const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type) {\012////#pragma HLS INLINE\012\012	// Constants\012	const vx_uint16 VEC_COLS = IMG_COLS / VEC_NUM;\012	const vx_uint16 KERN_RAD = KERN_SIZE >> 1;\012	const vx_uint16 WIN_COLS = 2 * KERN_RAD + VEC_NUM + (VEC_NUM - (KERN_RAD % VEC_NUM)) % VEC_NUM;\012	const vx_uint16 OHD_COLS = (WIN_COLS - KERN_RAD) / VEC_NUM - 1;\012	const vx_uint16 LINE_BUFFER_WIDTH = VEC_NUM*(KERN_SIZE - 1);\012\012	// Linebuffer\012	BufferType linebuffer[BUFFER_NUM][VEC_COLS];\012\012	// Sliding window for complete vector\012	ScalarType window_hor[1][WIN_COLS];\012//#pragma HLS array_partition variable=window_hor complete dim=0\012\012	ScalarType window_ver[KERN_SIZE][VEC_NUM];\012//#pragma HLS array_partition variable=window_ver complete dim=0\012\012	// Compute the filter (pipelined)\012	vx_uint32 ptr_src = 0, ptr_dst = 0;\012#pragma ii 1\012	for (vx_uint16 y = 0; y < IMG_ROWS + KERN_RAD; y++) {\012		for (vx_uint16 x = 0; x < VEC_COLS + OHD_COLS; x++) {\012			// Variables (Registers)\012			ScalarType input_buffer[VEC_NUM];\012//#pragma HLS array_partition variable=input_buffer complete dim=0\012			ScalarType buffer[KERN_SIZE][VEC_NUM];\012//#pragma HLS array_partition variable=buffer complete dim=0\012			ScalarType internal_buffer[VEC_NUM];\012//#pragma HLS array_partition variable=internal_buffer complete dim=0\012			vx_image<ScalarType, VEC_NUM> input_data;\012			vx_image<ScalarType, VEC_NUM> output_data;\012\012			// Read input data from global memory\012			if ((y < IMG_ROWS) && (x < VEC_COLS)) {\012				input_data = input[ptr_src];\012				ptr_src++;\012			}\012#pragma unroll\012			for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012				input_buffer[v] = input_data.pixel[v];\012			}\012\012			// Compute Horizontal Filter including sliding window\012			SlidingWindowHorizontal<ScalarType, KERN_RAD, VEC_COLS, VEC_NUM, WIN_COLS, BORDER_TYPE>(input_buffer, window_hor, x);\012			ComputeFilterHorizontal<ScalarType, KernelType, KERN_SIZE, WIN_COLS, VEC_NUM>(window_hor[0], kernel, kernel_mult, kernel_shift, kernel_type, internal_buffer);\012\012			// Compute linebuffer\012			vx_int16 xs = x - OHD_COLS;\012			if (xs >= 0) {				\012				ReadFromLineBuffer<ScalarType, BufferType, BUFFER_NUM, VEC_NUM, KERN_SIZE, VEC_COLS>(internal_buffer, linebuffer, buffer, xs);\012				WriteToLineBuffer<ScalarType, BufferType, BUFFER_NUM, VEC_NUM, KERN_SIZE, VEC_COLS>(buffer, linebuffer, xs);\012			}\012\012			// Compute Vertical Filter including sliding window\012			SlidingWindowVertical<ScalarType, IMG_ROWS, KERN_RAD, VEC_NUM, KERN_SIZE, BORDER_TYPE>(buffer, window_ver, y);\012			ComputeFilterVertical<ScalarType, KernelType, KERN_SIZE, VEC_NUM>(window_ver, kernel, kernel_mult, kernel_shift, kernel_type, output_data);\012\012			// Write output data to global memory\012			if ((y >= KERN_RAD) && (x >= OHD_COLS)) {\012				output[ptr_dst] = output_data;\012				ptr_dst++;\012			}\012		}\012	}\012}\012\012/** @brief  Computes multiple 1d convolution filter of kernel_type type\012@param ScalarType   Data type of the input/output image (8-bit, 16-bit, 32-bit)\012@param KernType     Data type of the kernel (8-bit, 16-bit, 32-bit)\012@param VEC_PIX      The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM      Amount of pixels computed in parallel (1, 2, 4, 8)\012@param IMG_COLS     Image width\012@param IMG_ROWS     Image height\012@param KERN_SIZE    Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE  Type of border (Constant, Replicated or Undefined)\012@param input        Input image\012@param output       Output image\012@param kernel       The convolution kernel\012@param kernel_mult  Resulting pixels are 1. multiplied by this amount\012@param kernel_shift Resulting pixels are 2. shifted to the right by this amount\012@param kernel_type  The type of convolution\012*/\012template <typename ScalarType, typename KernelType, vx_uint32 VEC_PIX, vx_uint16 VEC_NUM, vx_uint16 IMG_COLS, vx_uint16 IMG_ROWS, vx_uint16 KERN_SIZE, vx_border_e BORDER_TYPE>\012void ComputeFilter1d(vx_image<ScalarType, VEC_NUM> input[(IMG_ROWS*IMG_COLS) / VEC_NUM], vx_image<ScalarType, VEC_NUM> *output, KernelType kernel[KERN_SIZE], \012	const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type) {\012////#pragma HLS INLINE\012\012	// Check parameter input\012	CheckFilterParameters<ScalarType, ScalarType, VEC_NUM, 1, IMG_COLS, KERN_SIZE>();\012\012	// Constants to compute optimum buffer width\012	const vx_uint16 DATA_WIDTH = sizeof(ScalarType) * VEC_NUM * (KERN_SIZE - 1);\012	const vx_uint16 BUFFER_UINT32 = DATA_WIDTH % 4;\012	const vx_uint16 BUFFER_UINT16 = DATA_WIDTH % 2;\012	const vx_uint16 BUFFER_NUM = (BUFFER_UINT32 == 0) ? (DATA_WIDTH >> 2) : ((BUFFER_UINT16 == 0) ? (DATA_WIDTH >> 1) : (DATA_WIDTH));\012	const vx_uint16 BUFFER_WIDTH = (BUFFER_UINT32 == 0) ? (4) : ((BUFFER_UINT16 == 0) ? (2) : (1));\012	\012	// Sets the Buffer Data type to the maximum possible, to reduce the amount of BRAM used\012	if (BUFFER_WIDTH == 4)\012		ComputeFilter1dFunc<ScalarType, KernelType, vx_uint32, BUFFER_NUM, VEC_PIX, VEC_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE>(input, output, kernel, kernel_mult, kernel_shift, kernel_type);\012	else if (BUFFER_WIDTH == 2)\012		ComputeFilter1dFunc<ScalarType, KernelType, vx_uint16, BUFFER_NUM, VEC_PIX, VEC_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE>(input, output, kernel, kernel_mult, kernel_shift, kernel_type);\012	else if (BUFFER_WIDTH == 1)\012		ComputeFilter1dFunc<ScalarType, KernelType, vx_uint8, BUFFER_NUM, VEC_PIX, VEC_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE>(input, output, kernel, kernel_mult, kernel_shift, kernel_type);\012}\012\012/** @brief  Computes multiple 2d convolution filter of kernel_type type\012@param InType       Data type of the input image (8-bit, 16-bit, 32-bit)\012@param OutType      Data type of the output image (8-bit, 16-bit, 32-bit)\012@param KernType     Data type of the kernel (8-bit, 16-bit, 32-bit)\012@param BufferType   (sizeof(InType) * VEC_NUM * (KERN_SIZE - 1)) == (sizeof(BufferType) * BUFFER_NUM)\012@param BUFFER_NUM   (sizeof(InType) * VEC_NUM * (KERN_SIZE - 1)) == (sizeof(BufferType) * BUFFER_NUM)\012@param VEC_PIX      The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM      Amount of pixels computed in parallel (1, 2, 4, 8)\012@param KERN_NUM     Amount of pixels computed in parallel (1, 2)\012@param IMG_COLS     Image width\012@param IMG_ROWS     Image height\012@param KERN_SIZE    Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE  Type of border (Constant, Replicated or Undefined)\012@param input        Input image\012@param output1      1. Output image\012@param output2      2. Output image\012@param kernel       The convolution kernel\012@param kernel_mult  Resulting pixels are 1. multiplied by this amount\012@param kernel_shift Resulting pixels are 2. shifted to the right by this amount\012@param kernel_type  The type of convolution\012*/\012template <typename InType, typename OutType, typename KernType, typename BufferType, vx_uint16 BUFFER_NUM, vx_uint32 VEC_PIX, vx_uint16 VEC_NUM, vx_uint16 KERN_NUM, vx_uint16 IMG_COLS, vx_uint16 IMG_ROWS, vx_uint16 KERN_SIZE, vx_border_e BORDER_TYPE>\012void ComputeFilter2dFunc(vx_image<InType, VEC_NUM> input[VEC_PIX], vx_image<OutType, VEC_NUM> output1[VEC_PIX], vx_image<OutType, VEC_NUM> output2[VEC_PIX], \012	KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM]) {\012////#pragma HLS INLINE\012\012	// Constants\012	const vx_uint16 VEC_COLS = IMG_COLS / VEC_NUM;\012	const vx_uint16 KERN_RAD = KERN_SIZE / 2;\012	const vx_uint16 WIN_COLS = 2 * KERN_RAD + VEC_NUM + (VEC_NUM - (KERN_RAD % VEC_NUM)) % VEC_NUM;\012	const vx_uint16 OHD_COLS = (WIN_COLS - KERN_RAD) / VEC_NUM - 1;\012	const vx_uint16 LINE_BUFFER_WIDTH = VEC_NUM*(KERN_SIZE - 1);\012\012	// Linebuffer\012	BufferType linebuffer[BUFFER_NUM][VEC_COLS];\012\012	// Sliding window for complete vector\012	InType window[KERN_SIZE][WIN_COLS];\012//#pragma HLS array_partition variable=window complete dim=0\012\012	// Compute the filter (pipelined)\012	vx_uint32 ptr_src = 0, ptr_dst = 0;\012#pragma ii 1\012	for (vx_uint16 y = 0; y < IMG_ROWS + KERN_RAD; y++) {\012		for (vx_uint16 x = 0; x < VEC_COLS + OHD_COLS; x++) {\012\012			InType input_buffer[VEC_NUM];\012//#pragma HLS array_partition variable=input_buffer complete dim=0\012			InType buffer[KERN_SIZE][VEC_NUM];\012//#pragma HLS array_partition variable=buffer complete dim=0\012\012			// Input & Output\012			vx_image<InType, VEC_NUM> input_data;\012			vx_image<OutType, VEC_NUM> output_data[KERN_NUM];\012\012			// Read input data from global memory\012			if ((y < IMG_ROWS) && (x < VEC_COLS)) {\012				input_data = input[ptr_src];\012				ptr_src++;\012			}\012#pragma unroll\012			for (vx_uint16 v = 0; v < VEC_NUM; v++) {\012				input_buffer[v] = input_data.pixel[v];\012			}\012\012			// Read data from line_buffer to buffer\012			ReadFromLineBuffer<InType, BufferType, BUFFER_NUM, VEC_NUM, KERN_SIZE, VEC_COLS>(input_buffer, linebuffer, buffer, x);\012\012			// Write data from buffer to line_buffer\012			WriteToLineBuffer<InType, BufferType, BUFFER_NUM, VEC_NUM, KERN_SIZE, VEC_COLS>(buffer, linebuffer, x);\012\012			// Move sliding window with replicated/constant border\012			SlidingWindow<InType, VEC_NUM, IMG_ROWS, KERN_RAD, VEC_COLS, WIN_COLS, KERN_SIZE, BORDER_TYPE>(buffer, window, x, y);\012\012			// Compute filter\012			ComputeFilter<InType, OutType, KernType, VEC_NUM, KERN_NUM, KERN_SIZE, WIN_COLS>(window, kernel, kernel_mult, kernel_shift, kernel_type, output_data);\012\012			// Write output data to global memory\012			if ((y >= KERN_RAD) && (x >= OHD_COLS)) {\012				if (KERN_NUM > 0)\012					output1[ptr_dst] = output_data[0];\012				if (KERN_NUM > 1)\012					output2[ptr_dst] = output_data[1];\012				ptr_dst++;\012			}\012		}\012	}\012}\012\012/** @brief  Computes multiple 2d convolution filter of kernel_type type\012@param InType       Data type of the input image (8-bit, 16-bit, 32-bit)\012@param OutType      Data type of the output image (8-bit, 16-bit, 32-bit)\012@param KernType     Data type of the kernel (8-bit, 16-bit, 32-bit)\012@param VEC_PIX      The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM      Amount of pixels computed in parallel (1, 2, 4, 8)\012@param KERN_NUM     Amount of pixels computed in parallel (1, 2)\012@param IMG_COLS     Image width\012@param IMG_ROWS     Image height\012@param KERN_SIZE    Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE  Type of border (Constant, Replicated or Undefined)\012@param input        Input image\012@param output1      1. Output image\012@param output2      2. Output image\012@param kernel       The convolution kernel\012@param kernel_mult  Resulting pixels are 1. multiplied by this amount\012@param kernel_shift Resulting pixels are 2. shifted to the right by this amount\012@param kernel_type  The type of convolution\012*/\012template <typename InType, typename OutType, typename KernType, vx_uint32 VEC_PIX, vx_uint16 VEC_NUM, vx_uint16 KERN_NUM, vx_uint16 IMG_COLS, vx_uint16 IMG_ROWS, vx_uint16 KERN_SIZE, vx_border_e BORDER_TYPE>\012void ComputeFilter2d(vx_image<InType, VEC_NUM> input[VEC_PIX], vx_image<OutType, VEC_NUM> output1[VEC_PIX], vx_image<OutType, VEC_NUM> output2[VEC_PIX], \012	KernType kernel[KERN_NUM][KERN_SIZE][KERN_SIZE], const vx_uint64 kernel_mult, const vx_uint32 kernel_shift, const HIFLIPVX::FilterOperation kernel_type[KERN_NUM]) {\012////#pragma HLS INLINE\012\012	// Check parameter input\012	CheckFilterParameters<InType, OutType, VEC_NUM, KERN_NUM, IMG_COLS, KERN_SIZE>();\012\012	// Constants to compute optimum buffer width\012	const vx_uint16 DATA_WIDTH = sizeof(InType) * VEC_NUM * (KERN_SIZE - 1);\012	const vx_uint16 BUFFER_UINT32 = DATA_WIDTH % 4;\012	const vx_uint16 BUFFER_UINT16 = DATA_WIDTH % 2;\012	const vx_uint16 BUFFER_NUM = (BUFFER_UINT32 == 0) ? (DATA_WIDTH >> 2) : ((BUFFER_UINT16 == 0) ? (DATA_WIDTH >> 1) : (DATA_WIDTH));\012	const vx_uint16 BUFFER_WIDTH = (BUFFER_UINT32 == 0) ? (4) : ((BUFFER_UINT16 == 0) ? (2) : (1));\012\012	// Sets the Buffer Data type to the maximum possible, to reduce the amount of BRAM used\012	if (BUFFER_WIDTH == 4)\012		ComputeFilter2dFunc<InType, OutType, KernType, vx_uint32, BUFFER_NUM, VEC_PIX, VEC_NUM, KERN_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE>(input, output1, output2, kernel, kernel_mult, kernel_shift, kernel_type);\012	else if (BUFFER_WIDTH == 2)\012		ComputeFilter2dFunc<InType, OutType, KernType, vx_uint16, BUFFER_NUM, VEC_PIX, VEC_NUM, KERN_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE>(input, output1, output2, kernel, kernel_mult, kernel_shift, kernel_type);\012	else if (BUFFER_WIDTH == 1)\012		ComputeFilter2dFunc<InType, OutType, KernType, vx_uint8, BUFFER_NUM, VEC_PIX, VEC_NUM, KERN_NUM, IMG_COLS, IMG_ROWS, KERN_SIZE, BORDER_TYPE>(input, output1, output2, kernel, kernel_mult, kernel_shift, kernel_type);\012}\012\012\012/*********************************************************************************************************************/\012/* Filter Function Definition */\012/*********************************************************************************************************************/\012\012/** @brief  Computes a Box filter over a window of the input image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param SEPARABLE   Is true, if separable filter should be used\012@param input       Input image\012@param output      Output image\012*/\012template<typename ScalarType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, vx_bool SEPARABLE>\012void HwBox(vx_image<ScalarType, VEC_NUM> input[VEC_PIX], vx_image<ScalarType, VEC_NUM> output[VEC_PIX]) {\012////#pragma HLS INLINE\012\012	// Check function parameters/types\012	STATIC_ASSERT(numeric_limits<ScalarType>::is_signed == false, scalar_type_must_be_unsigned);\012\012	// Kernel Type\012	typedef vx_uint16 KernelType;\012\012	// Kernel Parameters\012	const vx_uint8 KERN_NUM = 1;\012	vx_uint64 kernel_mult = 1;\012	vx_uint32 kernel_shift = 0;\012\012	if (SEPARABLE == vx_false_e) {\012\012		// Function Input\012		KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE];\012//#pragma HLS array_partition variable=kernel_vector complete dim=0\012\012		// Compute kernel and normalization (Compile-Time)\012#pragma unroll\012		for (vx_uint8 y = 0; y < KERN_SIZE; y++) {\012#pragma unroll\012			for (vx_uint8 x = 0; x < KERN_SIZE; x++) {\012				kernel_vector[0][y][x] = 1;\012			}\012		}\012		ComputeNormalization2d<KernelType, KERN_SIZE>(kernel_vector[0], kernel_mult, kernel_shift);\012\012		// Kernel normalization and type\012		const HIFLIPVX::FilterOperation kernel_type[KERN_NUM] = { HIFLIPVX::BOX_FILTER };\012\012		// Compute Filter\012		ComputeFilter2d<ScalarType, ScalarType, KernelType, VEC_PIX, VEC_NUM, KERN_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input, output, NULL, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012\012	} else {\012\012		// Function Input\012		KernelType kernel_vector[KERN_SIZE];\012//#pragma HLS array_partition variable=kernel_vector complete dim=0\012\012		// Compute kernel and normalization (Compile-Time)\012#pragma unroll\012		for (vx_uint8 i = 0; i < KERN_SIZE; i++) {\012			kernel_vector[i] = 1;\012		}\012		ComputeNormalization1d<KernelType, KERN_SIZE>(kernel_vector, kernel_mult, kernel_shift);\012\012		// Kernel normalization and type\012		const HIFLIPVX::FilterOperation kernel_type = HIFLIPVX::BOX_FILTER;\012\012		// Compute Filter\012		ComputeFilter1d<ScalarType, KernelType, VEC_PIX, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input, output, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012	}\012}\012\012/** @brief  Convolves the input with the client supplied convolution matrix. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned, signed)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       Input image\012@param output      Output image\012@param conv        The custom convolution kernel\012*/\012template<typename ScalarType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE>\012void HwConvolve(vx_image<ScalarType, VEC_NUM> input[VEC_PIX], vx_image<ScalarType, VEC_NUM> output[VEC_PIX], const ScalarType conv[KERN_SIZE][KERN_SIZE]) {\012////#pragma HLS INLINE\012\012	// Kernel Parameters\012	const vx_uint8 KERN_NUM = 1;\012	vx_uint64 kernel_mult = 1;\012	vx_uint32 kernel_shift = 0;\012\012	// Function Input\012	ScalarType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE];\012//#pragma HLS array_partition variable=kernel_vector complete dim=0\012\012	// Compute kernel and normalization (Compile-Time)\012#pragma unroll\012	for (vx_uint8 i = 0; i < KERN_SIZE; i++) {\012#pragma unroll\012		for (vx_uint8 j = 0; j < KERN_SIZE; j++) {\012			kernel_vector[0][i][j] = conv[i][j];\012		}\012	}\012	ComputeNormalization2d<ScalarType, KERN_SIZE>(kernel_vector[0], kernel_mult, kernel_shift);\012\012	// Kernel normalization and type\012	const HIFLIPVX::FilterOperation kernel_type[KERN_NUM] = { HIFLIPVX::CUSTOM_CONVOLUTION };\012\012	// Compute Filter\012	ComputeFilter2d<ScalarType, ScalarType, ScalarType, VEC_PIX, VEC_NUM, KERN_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input, output, NULL, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012}\012\012/** @brief  Implements Dilation, which grows the white space in a Boolean image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       Input image\012@param output      Output image\012*/\012template<typename ScalarType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE>\012void HwDilate(vx_image<ScalarType, VEC_NUM> input[VEC_PIX], vx_image<ScalarType, VEC_NUM> output[VEC_PIX]) {\012////#pragma HLS INLINE\012\012	// Check function parameters/types\012	STATIC_ASSERT(numeric_limits<ScalarType>::is_signed == false, scalar_type_must_be_unsigned);\012\012	// Kernel Parameters\012	typedef vx_uint16 KernelType;\012\012	// Function Input\012	KernelType kernel_vector[KERN_SIZE];\012//#pragma HLS array_partition variable=kernel_vector complete dim=0\012\012	// Kernel normalization and type\012	const vx_uint64 kernel_mult = 1;\012	const vx_uint32 kernel_shift = 0;\012	const HIFLIPVX::FilterOperation kernel_type = HIFLIPVX::DILATE_IMAGE;\012\012	// Compute Filter\012	ComputeFilter1d<ScalarType, KernelType, VEC_PIX, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input, output, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012}\012\012/** @brief  Implements Erosion, which shrinks the white space in a Boolean image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       Input image\012@param output      Output image\012*/\012template<typename ScalarType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE>\012void HwErode(vx_image<ScalarType, VEC_NUM> input[VEC_PIX], vx_image<ScalarType, VEC_NUM> output[VEC_PIX]) {\012////#pragma HLS INLINE\012\012	// Check function parameters/types\012	STATIC_ASSERT(numeric_limits<ScalarType>::is_signed == false, scalar_type_must_be_unsigned);\012\012	// Kernel Parameters\012	typedef vx_uint16 KernelType;\012\012	// Function Input\012	KernelType kernel_vector[KERN_SIZE];\012//#pragma HLS array_partition variable=kernel_vector complete dim=0\012\012	// Kernel normalization and type\012	const vx_uint64 kernel_mult = 1;\012	const vx_uint32 kernel_shift = 0;\012	const HIFLIPVX::FilterOperation kernel_type = HIFLIPVX::ERODE_IMAGE;\012\012	// Compute Filter\012	ComputeFilter1d<ScalarType, KernelType, VEC_PIX, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input, output, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012}\012\012/** @brief  Computes a Gaussian filter over a window of the input image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param SEPARABLE   Is true, if separable filter should be used\012@param input       Input image\012@param output      Output image\012*/\012template<typename ScalarType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE, vx_bool SEPARABLE>\012void HwGaussian(vx_image<ScalarType, VEC_NUM> input[VEC_PIX], vx_image<ScalarType, VEC_NUM> output[VEC_PIX]) {\012////#pragma HLS INLINE\012\012	// Check function parameters/types\012	STATIC_ASSERT(numeric_limits<ScalarType>::is_signed == false, scalar_type_must_be_unsigned);\012\012	// Kernel Type\012	typedef vx_uint16 KernelType;\012\012	// Kernel Parameters\012	const vx_uint8 KERN_NUM = 1;\012	vx_uint64 kernel_mult = 1;\012	vx_uint32 kernel_shift = 0;\012\012	if (SEPARABLE == vx_false_e) {\012		\012		// Function Input\012		KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE];\012//#pragma HLS array_partition variable=kernel_vector complete dim=0\012		\012		// Compute kernel and normalization (Compile-Time)\012		ComputeGaussianKernels<KernelType, KERN_SIZE>(kernel_vector[0]);\012		ComputeNormalization2d<KernelType, KERN_SIZE>(kernel_vector[0], kernel_mult, kernel_shift);\012		\012		// Set normalization and type\012		const HIFLIPVX::FilterOperation kernel_type[KERN_NUM] = { HIFLIPVX::GAUSSIAN_FILTER };\012		\012		// Compute Filter\012		ComputeFilter2d<ScalarType, ScalarType, KernelType, VEC_PIX, VEC_NUM, KERN_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input, output, NULL, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012\012	} else {		\012\012		// Function Input\012		KernelType kernel_vector[KERN_SIZE][KERN_SIZE];\012//#pragma HLS array_partition variable=kernel_vector complete dim=0\012\012		// Compute kernel and normalization (Compile-Time)\012		ComputeGaussianKernels<KernelType, KERN_SIZE>(kernel_vector);\012		ComputeNormalization1d<KernelType, KERN_SIZE>(kernel_vector[0], kernel_mult, kernel_shift);\012\012		// Kernel normalization and type\012		const HIFLIPVX::FilterOperation kernel_type = HIFLIPVX::GAUSSIAN_FILTER;\012\012		// Compute Filter\012		ComputeFilter1d<ScalarType, KernelType, VEC_PIX, VEC_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input, output, kernel_vector[0], kernel_mult, kernel_shift, kernel_type);\012	}\012}\012\012/** @brief  Computes a median pixel value over a window of the input image. The output image dimensions should be the same as the dimensions of the input image.\012@param DataType    Data type of the input/output image (unsigned)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       Input image\012@param output      Output image\012*/\012template<typename ScalarType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE>\012void HwMedian(vx_image<ScalarType, VEC_NUM> input[VEC_PIX], vx_image<ScalarType, VEC_NUM> output[VEC_PIX]) {\012////#pragma HLS INLINE\012\012	// Check function parameters/types\012	STATIC_ASSERT(numeric_limits<ScalarType>::is_signed == false, scalar_type_must_be_unsigned);\012\012	// Kernel Type\012	typedef vx_uint16 KernelType;\012\012	// Kernel Parameters\012	const vx_uint8 KERN_NUM = 1;\012	const vx_uint64 kernel_mult = 1;\012	const vx_uint32 kernel_shift = 0;\012\012	// Function Input\012	KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE];\012//#pragma HLS array_partition variable=kernel_vector complete dim=0\012\012	// Kernel normalization and type\012	const HIFLIPVX::FilterOperation kernel_type[KERN_NUM] = { HIFLIPVX::MEDIAN_FILTER };\012\012	// Compute Filter\012	ComputeFilter2d<ScalarType, ScalarType, KernelType, VEC_PIX, VEC_NUM, KERN_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input, output, NULL, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012}\012\012/** @brief  Implements the Scharr Image Filter Kernel. The output images dimensions should be the same as the dimensions of the input image.\012@param SrcType     Data type of the input image (unsigned)(8-bit, 16-bit, 32-bit)\012@param DstType     Data type of the output image (signed)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       The input image\012@param output1     The output image (x derivative)\012@param output2     The output image (y derivative)\012*/\012template <typename InType, typename OutType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_border_e BORDER_TYPE>\012void HwScharr3x3(vx_image<InType, VEC_NUM> input[VEC_PIX], vx_image<OutType, VEC_NUM> output1[VEC_PIX], vx_image<OutType, VEC_NUM> output2[VEC_PIX]) {\012////#pragma HLS INLINE\012\012	// Check function parameters/types\012	STATIC_ASSERT(numeric_limits<InType>::is_signed == false, derivative_input_must_be_unsigned);\012	STATIC_ASSERT(numeric_limits<OutType>::is_signed == true, derivative_output_must_be_signed);\012\012	// Kernel Type\012	typedef vx_int16 KernelType;\012\012	// Kernel Parameters\012	const vx_uint8 KERN_NUM = 2;\012	const vx_uint8 KERN_SIZE = 3;\012	const vx_uint64 kernel_mult = 1;\012	const vx_uint32 kernel_shift = 5;\012\012	// Function Input\012	KernelType kernel_vector[2][KERN_SIZE][KERN_SIZE] = {\012		{\012			{ 3, 0, -3 },\012			{ 10, 0, -10 },\012			{ 3, 0, -3 },\012		}, {\012			{ 3, 10, 3 },\012			{ 0, 0, 0 },\012			{ -3, -10, -3 },\012		} };\012//#pragma HLS array_partition variable=kernel_vector complete dim=0\012\012	// Kernel normalization and type\012	const HIFLIPVX::FilterOperation kernel_type[KERN_NUM] = { HIFLIPVX::DERIVATIVE_X, HIFLIPVX::DERIVATIVE_Y };\012\012	// Compute Filter\012	ComputeFilter2d<InType, OutType, KernelType, VEC_PIX, VEC_NUM, KERN_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input, output1, output2, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012}\012\012/** @brief  Implements the Sobel Image Filter Kernel. The output images dimensions should be the same as the dimensions of the input image.\012@param SrcType     Data type of the input image (unsigned)(8-bit, 16-bit, 32-bit)\012@param DstType     Data type of the output image (signed)(8-bit, 16-bit, 32-bit)\012@param VEC_PIX     The amount of pixels diveded by the pixels computed in parallel\012@param VEC_NUM     Amount of pixels computed in parallel (1, 2, 4, 8)\012@param WIDTH       Image width\012@param HEIGHT      Image height\012@param KERN_SIZE   Kernel size (3, 5, 7, 9, 11)\012@param BORDER_TYPE Type of border (Constant, Replicated or Undefined)\012@param input       The input image\012@param output1     The output image (x derivative)\012@param output2     The output image (y derivative)\012*/\012template <typename InType, typename OutType, vx_uint32 VEC_PIX, vx_uint8 VEC_NUM, vx_uint16 WIDTH, vx_uint16 HEIGHT, vx_uint8 KERN_SIZE, vx_border_e BORDER_TYPE>\012void HwSobel(vx_image<InType, VEC_NUM> input[VEC_PIX], vx_image<OutType, VEC_NUM> output1[VEC_PIX], vx_image<OutType, VEC_NUM> output2[VEC_PIX]) {\012////#pragma HLS INLINE\012\012	// Check function parameters/types\012	STATIC_ASSERT(numeric_limits<InType>::is_signed == false, input_must_be_unsigned);\012	STATIC_ASSERT(numeric_limits<OutType>::is_signed == true, output_must_be_signed);\012\012	// Kernel Type\012	typedef vx_int16 KernelType;\012\012	// Kernel Amount\012	const vx_uint8 KERN_NUM = 2;\012\012	// Kernel Normalization\012	vx_uint64 kernel_mult = 1;\012	vx_uint32 kernel_shift = 0;\012\012	// Function Input\012	KernelType kernel_vector[KERN_NUM][KERN_SIZE][KERN_SIZE];\012//#pragma HLS array_partition variable=kernel_vector complete dim=0\012\012	// Compute kernel and normalization (Compile-Time)\012	ComputeSobelKernels<KernelType, KERN_SIZE>(kernel_vector[0], kernel_vector[1]);\012	ComputeNormalization2d<KernelType, KERN_SIZE>(kernel_vector[0], kernel_mult, kernel_shift);\012\012	// Kernel normalization and type\012	const HIFLIPVX::FilterOperation kernel_type[KERN_NUM] = { HIFLIPVX::DERIVATIVE_X, HIFLIPVX::DERIVATIVE_Y };\012\012	// Compute Filter\012	ComputeFilter2d<InType, OutType, KernelType, VEC_PIX, VEC_NUM, KERN_NUM, WIDTH, HEIGHT, KERN_SIZE, BORDER_TYPE>(input, output1, output2, kernel_vector, kernel_mult, kernel_shift, kernel_type);\012}\012\012#endif /* SRC_IMG_FILTER_CORE_H_ */\012"}, {"path":"img_helper.h", "name":"img_helper.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/HLS/HiFlipVX_Intel_FPGA/img_helper.h", "content":"/**\012* Licence: GNU GPLv3 \\n\012* You may copy, distribute and modify the software as long as you track\012* changes/dates in source files. Any modifications to or software\012* including (via compiler) GPL-licensed code must also be made available\012* under the GPL along with build & install instructions.\012*\012* @file    img_helper.h\012* @author  Lester Kalms <lester.kalms@tu-dresden.de>\012* @version 1.3\012* @brief Description:\\n\012*  These are helper functions needed by different functions (e.g. static assertion).\012* All own Enumerations, Typedefs, Macros and Namespaces are contained in this file.\012*/\012\012#ifndef SRC_IMG_HELPER_H_\012#define SRC_IMG_HELPER_H_\012\012/*! \\brief set this to SDSoC, when using SDSoC */\012//#define SDSOC\012\012/*********************************************************************************************************************/\012/* All includes libraries are here */\012/*********************************************************************************************************************/\012\012#define _USE_MATH_DEFINES\012\012#include <stdlib.h>\012#include <stdint.h>\012#include <stdio.h>\012#include <limits>\012#include <iostream>\012#include <cmath>\012#include <algorithm>\012#include \"vx_types.h\"\012#include <vector>\012#ifdef __SDSCC__\012#include \"sds_lib.h\"\012#endif\012\012/*********************************************************************************************************************/\012/* Global function */\012/*********************************************************************************************************************/\012\012/*! \\brief Needed as image type for vectorization\012@param TYPE The data type for the pixels\012@param SIZE The vectorization degree\012*/\012template<class TYPE, const size_t SIZE>\012struct vx_image {\012	TYPE pixel[SIZE];\012};\012\012/*! \\brief Creates an image object\012@param  ImageType The output image type (use \"struct vx_image<...>\" for vectorization of 2, 4 and 8)\012@param  PixelType The data type of the image pixels\012@param  COLS      The image columns\012@param  ROWS      The image rows\012@return           Pointer to the allocated memory\012*/\012template<typename ImageType, typename PixelType, vx_uint32 COLS, vx_uint32 ROWS>\012__inline ImageType *CreateImage() {\012#ifdef __SDSCC__\012	return (ImageType *)sds_alloc(sizeof(PixelType)*COLS*ROWS);\012#else\012	return (ImageType *)(new PixelType[COLS*ROWS]);\012#endif\012}\012\012/*! \\brief Destroys an image object\012@param  ImageType The image type\012@param  image     The image\012*/\012template<typename ImageType>\012__inline void DestroyImage(ImageType *image) {\012#ifdef __SDSCC__\012	return sds_free(image);\012#else\012	return delete[] image;\012#endif\012}\012\012/*********************************************************************************************************************/\012/* Own Macros */\012/*********************************************************************************************************************/\012\012// Maximum and Minumum values of datatypes\012#define VX_INT8_MIN     static_cast<int8_t>(0-128)         /*!< \\brief Minimum of signed 8 bit type */\012#define VX_INT16_MIN    static_cast<int16_t>(0-32768)      /*!< \\brief Minimum of signed 16 bit type */\012#define VX_INT32_MIN    static_cast<int32_t>(0-2147483648) /*!< \\brief Minimum of signed 32 bit type */\012#define VX_INT8_MAX     static_cast<int8_t>(127)           /*!< \\brief Maximum of signed 8 bit type */\012#define VX_INT16_MAX    static_cast<int16_t>(32767)        /*!< \\brief Maximum of signed 16 bit type */\012#define VX_INT32_MAX    static_cast<int32_t>(2147483647)   /*!< \\brief Maximum of signed 32 bit type */\012#define VX_UINT8_MAX    static_cast<uint8_t>(0xff)         /*!< \\brief Maximum of unsigned 8 bit type */\012#define VX_UINT16_MAX   static_cast<uint16_t>(0xffff)      /*!< \\brief Maximum of unsigned 16 bit type */\012#define VX_UINT32_MAX   static_cast<uint32_t>(0xffffffff)  /*!< \\brief Maximum of unsigned 32 bit type */\012\012#ifndef M_PI\012#define M_PI 3.14159265358979323846 /*!< \\brief PI if not defined by cmath */\012#endif\012\012/*! \\brief Gets the datatype of an integer:\012* \\details The output is of type <tt>\\ref vx_type_e</tt> and is 8, 16, 32, 64 bit signed or unsigned\012*/\012#define GET_TYPE(TYPE) (const vx_type_e)( \\\012	(std::numeric_limits<TYPE>::is_integer == true) ? ( \\\012		(std::numeric_limits<TYPE>::is_signed == false) ? ( \\\012			(sizeof(TYPE) == 1) ? (VX_TYPE_UINT8) : ( \\\012				(sizeof(TYPE) == 2) ? (VX_TYPE_UINT16) : ( \\\012					(sizeof(TYPE) == 4) ? (VX_TYPE_UINT32) : ( \\\012						(sizeof(TYPE) == 8) ? (VX_TYPE_UINT64) : ( \\\012							VX_TYPE_INVALID))))) :  ( \\\012			(sizeof(TYPE) == 1) ? (VX_TYPE_INT8) : ( \\\012				(sizeof(TYPE) == 2) ? (VX_TYPE_INT16) : ( \\\012					(sizeof(TYPE) == 4) ? (VX_TYPE_INT32) : ( \\\012						(sizeof(TYPE) == 8) ? (VX_TYPE_INT64) : ( \\\012							VX_TYPE_INVALID)))))) : ( \\\012	VX_TYPE_INVALID) \\\012)\012\012#define VECTOR_PIXELS(HEIGHT, WIDTH, VEC_NUM) (const vx_uint32) \\\012	((static_cast<vx_uint32>(HEIGHT)*static_cast<vx_uint32>(WIDTH)) / static_cast<vx_uint32>(VEC_NUM))\012\012/*********************************************************************************************************************/\012/* Own enums  */\012/*********************************************************************************************************************/\012\012/*! \\brief Contains the different pixelwise and filter operation types\012*/\012namespace HIFLIPVX {\012\012	/*! \\brief Perfroms a windowed filter function on an image\012	*/\012	enum FilterOperation {\012		GAUSSIAN_FILTER,     /*!< \\brief Gaussian filter (optimized for kernel structure) */\012		DERIVATIVE_X,        /*!< \\brief Scharr/Sobel derivative filter (optimized for kernel structure) */\012		DERIVATIVE_Y,        /*!< \\brief Scharr/Sobel derivative filter (optimized for kernel structure) */\012		CUSTOM_CONVOLUTION,  /*!< \\brief Costum convolution filter */\012		BOX_FILTER,          /*!< \\brief Box filter (optimized for kernel structure) */\012		MEDIAN_FILTER,       /*!< \\brief Median filter (optimized for kernel structure) */\012		ERODE_IMAGE,         /*!< \\brief Erode image filter (sperable kernel only) */\012		DILATE_IMAGE,        /*!< \\brief Dilate image filter (sperable kernel only) */\012		NON_MAX_SUPPRESSION  /*!< \\brief Do Non-Maxima Suppression */\012	};\012\012	/*! \\brief Performs an pixelwise operation on an image (same data type for input/output)\012	*/\012	enum PixelwiseOperationA {\012		COPY_DATA,    /*!< \\brief Copy a data object to another. */\012		BITWISE_NOT,  /*!< \\brief Performs a bitwise NOT operation on a input images. */\012		BITWISE_AND,  /*!< \\brief Performs a bitwise AND operation between two unsigned images. */\012		BITWISE_OR,   /*!< \\brief Performs a bitwise INCLUSIVE OR operation between two unsigned images. */\012		BITWISE_XOR,  /*!< \\brief Performs a bitwise EXCLUSIVE OR (XOR) operation between two unsigned images. */\012		MAX,          /*!< \\brief Implements a pixel-wise maximum kernel. */\012		MIN,          /*!< \\brief Implements a pixel-wise minimum kernel. */\012		ABSOLUTE_DIFFERENCE,   /*!< \\brief Computes the absolute difference between two images */\012		ARITHMETIC_ADDITION,   /*!< \\brief Performs addition between two images */\012		ARITHMETIC_SUBTRACTION, /*!< \\brief Performs subtraction between two images */\012		MAGNITUDE,               /*!< \\brief Implements the Gradient Magnitude Computation Kernel */\012		MULTIPLY                 /*!< \\brief Performs element-wise multiplication between two images and a scalar value. */\012	};\012\012	/*! \\brief Performs an pixelwise operation on an image (vary data type for input/output)\012	*/\012	enum PixelwiseOperationB {\012		AC_IMAGE,    /*!< \\brief  Accumulates an input image into output image. */\012		AC_SQUARED,  /*!< \\brief  Accumulates a squared value from an input image to an output image. */\012		AC_WEIGHTED, /*!< \\brief  Accumulates a weighted value from an input image to an output image.  */\012		THRESHOLD    /*!< \\brief  Thresholds an input image and produces an output Boolean image. */\012	};\012}\012\012/*********************************************************************************************************************/\012/* Static Assertion (COMPILE TIME) */\012/*********************************************************************************************************************/\012\012// note that we wrap the non existing type inside a struct to avoid warning\012// messages about unused variables when static assertions are used at function\012// scope\012// the use of sizeof makes sure the assertion error is not ignored by SFINAE\012template <bool>\012struct StaticAssertion;\012template <>\012struct StaticAssertion<true>\012{\012}; // StaticAssertion<true>\012template<int i>\012struct StaticAssertionTest\012{\012}; // StaticAssertionTest<int>\012\012#define CONCATENATE(arg1, arg2)   CONCATENATE1(arg1, arg2)\012#define CONCATENATE1(arg1, arg2)  CONCATENATE2(arg1, arg2)\012#define CONCATENATE2(arg1, arg2)  arg1##arg2\012\012/*! \\brief Pre-C++11 Static Assertions Without Boost\012* \\details: from  http://stackoverflow.com/questions/1980012/boost-static-assert-without-boost/1980156\012*\012* <code>STATIC_ASSERT(expression, message)</code>\012*\012* When the static assertion test fails, a compiler error message that somehow\012* contains the \"STATIC_ASSERTION_FAILED_AT_LINE_xxx_message\" is generated.\012*\012* /!\\ message has to be a valid C++ identifier, that is to say it must not\012* contain space characters, cannot start with a digit, etc.\012*\012* STATIC_ASSERT(true, this_message_will_never_be_displayed);\012*/\012#define STATIC_ASSERT(expression, message)\\\012struct CONCATENATE(__static_assertion_at_line_, __LINE__)\\\012{\\\012	StaticAssertion<static_cast<bool>((expression))> CONCATENATE(CONCATENATE(CONCATENATE(STATIC_ASSERTION_FAILED_AT_LINE_, __LINE__), _), message);\\\012};\\\012typedef StaticAssertionTest<sizeof(CONCATENATE(__static_assertion_at_line_, __LINE__))> CONCATENATE(__static_assertion_test_at_line_, __LINE__)\012\012/*********************************************************************************************************************/\012/* HW: Helper Functions for arithmetic computation  */\012/*********************************************************************************************************************/\012\012/*! \\brief Gets the maximum value of a certain data type\012@param Type  The data type that should be evaluated\012@return      The maximum value for \"Type\"\012*/\012template<typename Type>\012Type ComputeMax() {\012////#pragma HLS INLINE\012	const vx_type_e MAX_TYPE = GET_TYPE(Type);\012	return\012		(MAX_TYPE == VX_TYPE_UINT8) ? (VX_UINT8_MAX) : (\012		(MAX_TYPE == VX_TYPE_UINT16) ? (VX_UINT16_MAX) : (\012			(MAX_TYPE == VX_TYPE_UINT32) ? (VX_UINT32_MAX) : (\012			(MAX_TYPE == VX_TYPE_INT8) ? (VX_INT8_MAX) : (\012				(MAX_TYPE == VX_TYPE_INT16) ? (VX_INT16_MAX) : (\012				(MAX_TYPE == VX_TYPE_INT32) ? (VX_INT32_MAX) : (\012					VX_TYPE_INVALID))))));\012}\012\012/*! \\brief Gets the minimum value of a certain data type\012@param Type  The data type that should be evaluated\012@return      The minimum value for \"Type\"\012*/\012template<typename Type>\012Type ComputeMin() {\012////#pragma HLS INLINE\012	const vx_type_e MIN_TYPE = GET_TYPE(Type);\012	return\012		(MIN_TYPE == VX_TYPE_UINT8) ? (0) : (\012		(MIN_TYPE == VX_TYPE_UINT16) ? (0) : (\012			(MIN_TYPE == VX_TYPE_UINT32) ? (0) : (\012			(MIN_TYPE == VX_TYPE_INT8) ? (VX_INT8_MIN) : (\012				(MIN_TYPE == VX_TYPE_INT16) ? (VX_INT16_MIN) : (\012				(MIN_TYPE == VX_TYPE_INT32) ? (VX_INT32_MIN) : (\012					VX_TYPE_INVALID))))));\012}\012\012/*! \\brief Saturates a function to a maximum and minimum value\012@param Type    The data type of the value\012@param data    The input value\012@param max_val The maximum value\012@param min_val The minimum value\012@return        The saturated value\012*/\012template<typename Type>\012Type SaturateMaxMin(Type data, Type max_val, Type min_val) {\012////#pragma HLS INLINE\012	if (data > max_val)\012		return max_val;\012	else if (data < min_val)\012		return min_val;\012	else\012		return data;\012}\012\012/*! \\brief An arithmetic right shift that simulates the behavior of division. For signed values there is a different behavior between shift and division when rounding.\012@param Type             The data type of the value\012@param SIGNED_DATA_TYPE If value is signed\012@param data             The input value\012@param shift            The shift value\012@return                 The result\012*/\012template<typename Type, bool SIGNED_DATA_TYPE>\012Type ShiftArithmeticRight(Type data, vx_uint16 shift) {\012////#pragma HLS INLINE\012	Type a = data >> shift;\012	if ((SIGNED_DATA_TYPE == true) && (a < 0)) {\012		a += 1;\012	}\012	return a;\012}\012\012/** @brief Computes square root: Rounding to floor or to nearest integer\012@param OutType		The data type of the output\012@param InType		The data type of the input\012@param ROUND_POLICY Rounding policy (to zero & nearest even)\012@param CHECK_MAX	Is true, if the maximum value should be checked (needed for rounding to nearest even)\012@param value		The input value\012@return				The square root of the input value\012*/\012template<typename OutType, typename InType, bool CHECK_MAX, vx_round_policy_e ROUND_POLICY>\012OutType SqrtLester(InType value) {\012////#pragma HLS INLINE\012\012	const OutType MAX_VAL = ComputeMax<OutType>();\012\012	// Number of stages (latency)\012	const vx_uint8 N = sizeof(OutType) * 8;\012\012	// Variables\012	OutType   A1 = 0;  // A^1 Intermediate result\012	InType A2 = 0;  // A^2 Square of the intermediate result\012\012	// Each stage computes 1 bit of the resulting vector\012#pragma unroll\012	for (vx_uint8 n = N - 1; n < N; n--) {\012\012		// Add new bit of position n and compute (A1 + B1)^2\012		OutType B1 = static_cast<OutType>( 1) << (n);\012		InType  B2 = static_cast<InType >(B1) << (n);\012		InType  AB = static_cast<InType >(A1) << (n);\012		InType  A2_next = A2 + B2 + (AB << 1); // A*A + B*B + 2*A*B\012\012		// Store if tmp does not exceed value\012		if (A2_next <= value) {\012			A1 |= B1;\012			A2 = A2_next;\012		}\012	}\012\012	// Round to the nearest integer and check for overflow\012	if (ROUND_POLICY == VX_ROUND_POLICY_TO_NEAREST_EVEN) {\012		if (CHECK_MAX) {\012			if (((value - A2) > static_cast<InType>(A1)) && (A1 != MAX_VAL))\012				A1++;\012		} else {\012			if ((value - A2) > static_cast<InType>(A1))\012				A1++;\012		}\012	}\012\012	// Return result\012	return A1;\012}\012\012/*********************************************************************************************************************/\012/* HW: Helper Functions to Create Kernels (COMPILE TIME) */\012/*********************************************************************************************************************/\012\012/** @brief Computes the Gaussian Kernel using the Sigma values (not compile time in all SDx versions)\012@param ScalarType Data type of the kernel\012@param KERN_SIZE  The size of the kernel\012@param kernel     The computed gaussian kernel\012@param sigma      The input sigma value\012@return           The fraction size of the fixed-point result\012*/\012template <typename ScalarType, const vx_uint8 KERN_SIZE>\012const vx_uint16 ComputeGaussianKernelSigma(ScalarType kernel[KERN_SIZE][KERN_SIZE], const double sigma) {\012////#pragma HLS INLINE\012\012	// Constants\012	const vx_uint16 K_RAD = (vx_uint16)KERN_SIZE / (vx_uint16)2;\012	const double s = 2.0 * sigma * sigma;\012\012	// Variables\012	double sum = 0.0;\012	double doubleKernel[KERN_SIZE][KERN_SIZE];\012//#pragma HLS array_partition variable=doubleKernel complete dim=0\012\012	// Creates the gaussian kernel\012#pragma unroll\012	for (vx_uint8 x = 0; x < KERN_SIZE; x++) {\012#pragma unroll\012		for (vx_uint8 y = 0; y < KERN_SIZE; y++) {\012			const vx_uint32 a = static_cast<vx_uint32>((vx_uint16)x - K_RAD);\012			const vx_uint32 b = static_cast<vx_uint32>((vx_uint16)y - K_RAD);\012			const double c = static_cast<double>(a*a + b*b);\012			const double r = sqrt(c);\012			doubleKernel[x][y] = (exp(-(r*r) / s)) / (M_PI * s);\012			sum += doubleKernel[x][y];\012		}\012	}\012\012	// Normalizes the gaussian kernel\012#pragma unroll\012	for (vx_uint8 x = 0; x < KERN_SIZE; x++) {\012#pragma unroll\012		for (vx_uint8 y = 0; y < KERN_SIZE; y++) {\012			doubleKernel[x][y] /= sum;\012		}\012	}\012\012	// Computes the fraction for the fixed point representation\012	vx_int32 e_max = VX_INT32_MIN;\012#pragma unroll\012	for (vx_uint8 i = 0; i < KERN_SIZE; i++) {\012#pragma unroll\012		for (vx_uint8 j = 0; j < KERN_SIZE; j++) {\012			int e = 0;\012			frexp(doubleKernel[i][j], &e);\012			e_max = std::max(e_max, (vx_int32)e);\012		}\012	}\012	const vx_int32 fraction = 8 * sizeof(ScalarType) - e_max;\012	const vx_uint16 kernFraction = static_cast<vx_uint16>(std::min(std::max(fraction, (vx_int32)0), (vx_int32)31));\012\012	// Computes and stores the fixed point kernel\012	vx_uint32 shift = 1;\012#pragma unroll\012	for (vx_uint16 i = 0; i < kernFraction; i++) {\012		shift *= 2;\012	}\012#pragma unroll\012	for (vx_uint8 i = 0; i < KERN_SIZE; i++) {\012#pragma unroll\012		for (vx_uint8 j = 0; j < KERN_SIZE; j++) {\012			kernel[i][j] = static_cast<ScalarType>(doubleKernel[i][j] * static_cast<double>(shift));\012		}\012	}\012\012	// Returns the fraction\012	return kernFraction;\012}\012\012/** @brief Convolute an array with the convolution array [1 2 1]\012@param ScalarType      Data type of the kernel\012@param KERN_SIZE       The size of the final kernel\012@param BUFFER_SIZE     The amount of kernels that can be stored in \"kernel_buffer\"\012@param kernel_buffer   Buffers input and output kernel\012@param cur_kernel_ptr  Pointer where the input kernel is stored\012@param cur_kernel_size The size of the input kernel\012*/\012template<typename ScalarType, vx_uint8 KERN_SIZE, vx_int16 BUFFER_SIZE>\012void ComputeConvolution(ScalarType kernel_buffer[BUFFER_SIZE][KERN_SIZE], const vx_int16 cur_kernel_ptr, const vx_int16 cur_kernel_size) {\012////#pragma HLS INLINE\012\012	// Constants\012	const vx_int16 kernel_size = cur_kernel_size + 2;\012	const vx_int16 kernel_rad = kernel_size >> 1;\012\012	// Standard convolution kernel\012	ScalarType convoltion[3] = { 1, 2, 1 };\012\012	// convolute kernel\012#pragma unroll\012	for (vx_int32 j = 0; j < kernel_size; j++) {\012		const vx_int32 range = std::min((j < kernel_rad) ? (j + 1) : (kernel_size - j), (vx_int32)3);\012		const vx_int32 start_0 = std::max(2 - j, (vx_int32)0);\012		const vx_int32 start_1 = std::max(j - 2, (vx_int32)0);\012		ScalarType sum = 0;\012#pragma unroll\012		for (vx_int32 k = 0; k < range; k++) {\012			sum += (convoltion[start_0 + k] * kernel_buffer[cur_kernel_ptr][start_1 + k]);\012		}\012		kernel_buffer[cur_kernel_ptr + 1][j] = sum;\012	}\012}\012\012/** @brief Computes 2d kernel from two 1d kernels\012@param ScalarType Data type of the kernel\012@param KERN_SIZE  The size of the kernel\012@param src1       The 1. 1d kernel\012@param src2       The 2. 1d kernel\012@param dst        The resulting 2d kernel\012*/\012template<typename ScalarType, vx_uint8 KERN_SIZE>\012void ComputeKernel(ScalarType src1[KERN_SIZE], ScalarType src2[KERN_SIZE], ScalarType dst[KERN_SIZE][KERN_SIZE]) {\012////#pragma HLS INLINE\012\012#pragma unroll\012	for (vx_uint8 i = 0; i < KERN_SIZE; i++) {\012#pragma unroll\012		for (vx_uint8 j = 0; j < KERN_SIZE; j++) {\012			dst[i][j] = src1[i] * src2[j];\012		}\012	}\012}\012\012/** @brief Computes the 1d kernels for the sobel filter\012@param ScalarType Data type of the kernel\012@param KERN_SIZE  The size of the kernel\012@param sobel_x    Stores the sobel kernel in x-direction\012@param sobel_y    Stores the sobel kernel in y-direction\012*/\012template<typename ScalarType, vx_uint8 KERN_SIZE>\012void ComputeSobelKernels(ScalarType sobel_x[KERN_SIZE][KERN_SIZE], ScalarType sobel_y[KERN_SIZE][KERN_SIZE]) {\012////#pragma HLS INLINE\012\012	// Constants and variables\012	const vx_int16 ONE = static_cast<vx_int16>(1);\012	const vx_int16 THREE = static_cast<vx_int16>(3);\012	const vx_int16 BUFFER_SIZE = (((vx_int16)KERN_SIZE - THREE) >> ONE) + ONE;\012	vx_int16 buffer_ptr = 0;\012\012	// Sobel 1d kernel\012	ScalarType buffer_0[BUFFER_SIZE][KERN_SIZE];\012	buffer_0[0][0] = 1;\012	buffer_0[0][1] = 2;\012	buffer_0[0][2] = 1;\012	ScalarType buffer_1[BUFFER_SIZE][KERN_SIZE];\012	buffer_1[0][0] = -1;\012	buffer_1[0][1] = 0;\012	buffer_1[0][2] = 1;\012\012	// vx_uint8 kernel for higher kernel size\012#pragma unroll\012	for (vx_uint8 i = 3; i < KERN_SIZE; i += 2) {\012		ComputeConvolution<ScalarType, KERN_SIZE, BUFFER_SIZE>(buffer_0, buffer_ptr, (vx_int16)i);\012		ComputeConvolution<ScalarType, KERN_SIZE, BUFFER_SIZE>(buffer_1, buffer_ptr, (vx_int16)i);\012		buffer_ptr++;\012	}\012\012	// Compute the 2d kernel\012	ComputeKernel<ScalarType, KERN_SIZE>(buffer_0[buffer_ptr], buffer_1[buffer_ptr], sobel_x);\012	ComputeKernel<ScalarType, KERN_SIZE>(buffer_1[buffer_ptr], buffer_0[buffer_ptr], sobel_y);\012}\012\012/** @brief Computes the Gaussian kernel\012@param ScalarType Data type of the kernel\012@param KERN_SIZE  The size of the kernel\012@param gaussian   Stores the gaussian kernel\012*/\012template<typename ScalarType, vx_uint8 KERN_SIZE>\012void ComputeGaussianKernels(ScalarType gaussian[KERN_SIZE][KERN_SIZE]) {\012////#pragma HLS INLINE\012\012	const vx_int16 ONE = static_cast<vx_int16>(1);\012	const vx_int16 THREE = static_cast<vx_int16>(3);\012\012	// Constants and variables\012	const vx_int16 BUFFER_SIZE = (((vx_int16)KERN_SIZE - THREE) >> ONE) + ONE;\012	vx_int16 buffer_ptr = 0;\012\012	// Gaussian 1d kernel\012	ScalarType buffer_0[BUFFER_SIZE][KERN_SIZE];\012	buffer_0[0][0] = 1;\012	buffer_0[0][1] = 2;\012	buffer_0[0][2] = 1;\012\012	// Computer Gaussian kernel with bigger kernel sizes\012#pragma unroll\012	for (vx_uint8 i = 3; i < KERN_SIZE; i += 2) {\012		ComputeConvolution<ScalarType, KERN_SIZE, BUFFER_SIZE>(buffer_0, buffer_ptr, (vx_int16)i);\012		buffer_ptr++;\012	}\012\012	// Compute the 2d kernel from the 1d kernel\012	ComputeKernel<ScalarType, KERN_SIZE>(buffer_0[buffer_ptr], buffer_0[buffer_ptr], gaussian);\012}\012\012/** @brief Computes the normalization with given sum of kernel coefficients\012@param kernel_sum Sum of the kernel coefficients\012@param norm_mult  For normalization: multiply with this value\012@param norm_shift For normalization: shift the multiplied result with this value\012*/\012void ComputeNormalization(const vx_uint64 kernel_sum, vx_uint64 &norm_mult, vx_uint32 &norm_shift) {\012////#pragma HLS INLINE\012\012	// Constants\012	const vx_uint32 MAX_SHIFT = static_cast<vx_uint32>(48);\012	const vx_uint32 MIN_SHIFT = static_cast<vx_uint32>(15);\012	const vx_uint64 ONE = static_cast<vx_uint64>(1);\012	const vx_uint64 ZERO = static_cast<vx_uint64>(0);\012\012	// Variables\012	vx_uint16 new_shift = 0;\012	vx_uint16 new_mult = 1;\012	vx_uint32 old_shift = 0;\012	vx_uint64 old_mult = 1;\012	vx_uint64 norm_mult_a = 1;\012	vx_uint32 norm_shift_a = 0;\012	vx_uint64 norm_mult_b = 1;\012	vx_uint32 norm_shift_b = 0;\012	vx_uint64 temp = 0;\012	bool is_power_two = false;\012\012	// Compute Mult and Shift (Not Power of two)\012	old_mult = temp = (ONE << MAX_SHIFT) / kernel_sum;\012#pragma unroll\012	for (vx_uint32 i = 0; i < MAX_SHIFT; i++) {\012		if (temp > ZERO) {\012			temp = temp >> static_cast<vx_uint32>(1);\012			old_shift = i;\012		}\012	}\012	if (old_shift > 16) {\012		new_shift = static_cast<vx_uint16>(MAX_SHIFT - (old_shift - MIN_SHIFT));\012		new_mult = static_cast<vx_uint16>(old_mult >> (old_shift - MIN_SHIFT));\012	} else {\012		new_shift = static_cast<vx_uint16>(MAX_SHIFT);\012		new_mult = static_cast<vx_uint16>(old_mult);\012	}\012	norm_mult_a = static_cast<vx_uint64>(new_mult);\012	norm_shift_a = static_cast<vx_uint32>(new_shift);\012\012	// Compute Mult and Shift (Power of two)\012#pragma unroll\012	for (vx_uint32 i = 0; i < sizeof(vx_uint32) * 8; i++) {\012		if ((kernel_sum & (ONE << i)) != ZERO)\012			norm_shift_b = i;\012	}\012\012	// Check if scaling is by a power of two\012	is_power_two = (kernel_sum & (kernel_sum - ONE)) == ZERO;\012\012	// Compute Normalization and Multiplication\012	norm_mult = (is_power_two) ? (norm_mult_b) : (norm_mult_a);\012	norm_shift = (is_power_two) ? (norm_shift_b) : (norm_shift_a);\012}\012\012/** @brief Computes the normalization of a 2d kernel ((a * norm_mult) >> norm_shift)\012@param KernType   Data type of the kernel\012@param KERN_SIZE  The size of the kernel\012@param kernel     The kernel itself\012@param norm_mult  For normalization: multiply with this value\012@param norm_shift For normalization: shift the multiplied result with this value\012*/\012template <typename KernType, vx_uint8 KERN_SIZE>\012void ComputeNormalization2d(KernType kernel[KERN_SIZE][KERN_SIZE], vx_uint64 &norm_mult, vx_uint32 &norm_shift) {\012////#pragma HLS INLINE\012\012	// Variables\012	vx_uint64 kernel_sum = 0;\012\012	// Sum the kernel values\012#pragma unroll\012	for (vx_uint8 i = 0; i < KERN_SIZE; i++) {\012#pragma unroll\012		for (vx_uint8 j = 0; j < KERN_SIZE; j++) {\012			kernel_sum += static_cast<vx_uint64>(abs(static_cast<vx_int64>(kernel[i][j])));\012		}\012	}\012\012	// Compute Normalization\012	ComputeNormalization(kernel_sum, norm_mult, norm_shift);\012}\012\012/** @brief Computes the normalization of a 1d kernel ((a * norm_mult) >> norm_shift)\012@param KernType   Data type of the kernel\012@param KERN_SIZE  The size of the kernel\012@param kernel     The kernel itself\012@param norm_mult  For normalization: multiply with this value\012@param norm_shift For normalization: shift the multiplied result with this value\012*/\012template <typename KernType, vx_uint8 KERN_SIZE>\012void ComputeNormalization1d(KernType kernel[KERN_SIZE], vx_uint64 &norm_mult, vx_uint32 &norm_shift) {\012////#pragma HLS INLINE\012\012	// Variables\012	vx_uint64 kernel_sum = 0;\012\012	// Sum the kernel values for normalization (pre-compile)\012#pragma unroll\012	for (vx_uint8 i = 0; i < KERN_SIZE; i++) {\012		kernel_sum += static_cast<vx_uint64>(abs(static_cast<vx_int64>(kernel[i])));\012	}\012\012	// Compute Normalization\012	ComputeNormalization(kernel_sum, norm_mult, norm_shift);\012}\012\012#endif /* SRC_IMG_HELPER_H_ */\012"}, {"path":"main.cpp", "name":"main.cpp", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/HLS/HiFlipVX_Intel_FPGA/main.cpp", "content":"\012#include \"img_filter_base.h\"\012#include \"main.h\" //wich manufacturer?\012\012\012\012//// Image Size\012//#define COLS_FHD 1920\012//#define ROWS_FHD 1080\012//#define PIXELS_FHD COLS_FHD*ROWS_FHD\012//#define COLS_HD 1280\012//#define ROWS_HD 720\012//#define PIXELS_HD COLS_HD*ROWS_HD\012//\012//// Vectorization\012//#define VEC_NUM 8\012//#define VEC_PIX (PIXELS_FHD / VEC_NUM)\012//\012//// Defines\012//#define FILTER_SIZE 3\012//#define SEPARABLE_FILTER   (vx_bool)vx_true_e\012//#define CONVOLVE_FILTER_SIZE 3\012//#define BOX_BORDER      VX_BORDER_CONSTANT\012//#define CONVOLVE_BORDER VX_BORDER_CONSTANT\012//#define DILATE_BORDER   VX_BORDER_CONSTANT\012//#define ERODE_BORDER    VX_BORDER_CONSTANT\012//#define GAUSSIAN_BORDER VX_BORDER_CONSTANT\012//#define MEDIAN_BORDER   VX_BORDER_REPLICATE\012//#define SCHARR_BORDER   VX_BORDER_CONSTANT\012//#define SOBEL_BORDER    VX_BORDER_CONSTANT\012//\012// Typedefs\012typedef vx_uint8 filter_u_type;\012typedef vx_int8 filter_s_type;\012//#if (VEC_NUM == 1)\012//typedef filter_u_type filter_u_image;\012//typedef filter_s_type filter_s_image;\012//#else\012typedef vx_image<filter_u_type, VEC_NUM_K> filter_u_image;\012typedef vx_image<filter_s_type, VEC_NUM_K> filter_s_image;\012//#endif\012\012//component void foo(){\012//     filter_u_image input[VEC_PIX]; \012//     filter_s_image output1[VEC_PIX]; \012//     filter_s_image output2[VEC_PIX];\012//    \012//    ImgSobel<filter_u_type, filter_s_type, VEC_NUM, COLS_FHD, ROWS_FHD, FILTER_SIZE, SOBEL_BORDER>),input, output1, output2;\012//}\012//\012\012// Implements the Sobel Image Filter Kernel.\012int main(){\012//void TestHwSobel(filter_u_image input[VEC_PIX], filter_s_image output1[VEC_PIX], filter_s_image output2[VEC_PIX]) {\012\012#ifdef Xilinx\012	#pragma HLS INTERFACE axis port=input\012	#pragma HLS INTERFACE axis port=output1\012	#pragma HLS INTERFACE axis port=output2\012\012	#pragma HLS data_pack variable=input\012	#pragma HLS data_pack variable=output1\012	#pragma HLS data_pack variable=output2\012//Buffers are defined automatically by Intel\012#endif\012\012     filter_u_image input0[VEC_PIX]; \012     filter_s_image output1[VEC_PIX]; \012     filter_s_image output2[VEC_PIX];\012    \012     ImgSobel<filter_u_type, filter_s_type, VEC_NUM_K, COLS_FHD_K, ROWS_FHD_K, FILTER_SIZE_K, SOBEL_BORDER_K>(input0, output1, output2);\012 // 	template component void ImgSobel<filter_u_type, filter_s_type, VEC_NUM, COLS_FHD, ROWS_FHD, FILTER_SIZE, SOBEL_BORDER>(filter_u_image input, filter_s_image output1,filter_s_image output2);\012}\012\012"}, {"path":"main.h", "name":"main.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/HLS/HiFlipVX_Intel_FPGA/main.h", "content":"//// Conversion from Xilinx to intel follow this rules:\012//https://www.intel.com/content/www/us/en/programmable/documentation/mtr1422491996806.html#mtr1422491925947 to intel follow this rules:\012\012//FPGA manufacturer\012//#define Xilinx\012//#define Intel\012#ifdef Intel\012//to indentify component intefaces\012	#include \"HLS/hls.h\"\012#endif\012\012\012// Image Size\012#define COLS_FHD_K 1920\012#define ROWS_FHD_K 1080\012#define PIXELS_FHD COLS_FHD_K*ROWS_FHD_K\012#define COLS_HD_K 1280\012#define ROWS_HD_K 720\012#define PIXELS_HD COLS_HD_K*ROWS_HD_K\012\012// Vectorization\012#define VEC_NUM_K 8\012#define VEC_PIX (PIXELS_FHD / VEC_NUM_K)\012\012// Defines\012#define FILTER_SIZE_K 3\012#define SEPARABLE_FILTER   (vx_bool)vx_true_e\012#define CONVOLVE_FILTER_SIZE 3\012#define BOX_BORDER      VX_BORDER_CONSTANT\012#define CONVOLVE_BORDER VX_BORDER_CONSTANT\012#define DILATE_BORDER   VX_BORDER_CONSTANT\012#define ERODE_BORDER    VX_BORDER_CONSTANT\012#define GAUSSIAN_BORDER VX_BORDER_CONSTANT\012#define MEDIAN_BORDER   VX_BORDER_REPLICATE\012#define SCHARR_BORDER   VX_BORDER_CONSTANT\012#define SOBEL_BORDER_K    VX_BORDER_CONSTANT\012\012// Typedefs\012//typedef vx_uint8 filter_u_type;\012//typedef vx_int8 filter_s_type;\012//\012//typedef vx_image<filter_u_type, VEC_NUM> filter_u_image;\012//typedef vx_image<filter_s_type, VEC_NUM> filter_s_image;\012"}, {"path":"/opt/intelFPGA_pro/19.1/hls/include/HLS/task.h", "name":"task.h", "has_active_debug_locs":false, "absName":"/opt/intelFPGA_pro/19.1/hls/include/HLS/task.h", "content":"#ifndef _INTEL_IHC_HLS_TASK\012#define _INTEL_IHC_HLS_TASK\012#include \"HLS/function_traits.h\"\012\012#include <type_traits>\012#include <utility>\012\012// Make sure the macros to take the user calls into implementations\012// is not in effect for the source code of the implementation\012#undef launch\012#undef collect\012\012// Bring in the platform specific '_task' for composition\012#if defined(__INTELFPGA_COMPILER__)  && !defined(HLS_X86)\012#include \"HLS/internal/_task_FPGA.h\"\012#else\012#include \"HLS/internal/_task_X64.h\"\012#endif\012\012namespace ihc {\012  namespace internal {\012    // The task is a singleton that is shared between\012    // a calculation and its result:\012    // * Identify the functionality\012    //   task<function>::instance()\012    // * Launch the calculations\012    //   task<function>::instance().launch(args...);\012    // * Get the results\012    //   [ret = ]task<function>::instance().collect();\012    //      > blocking until launch is finished\012    //      > returns result for non-void function\012    //\012    // When the main program exits, any pending\012    // launches will still be processed in their\012    // respective thread\012    //\012    // The task is implemented as an\012    // Adaptor Design Pattern\012    // The X64 or FPGA implementation is adapted to the desired API\012    // This adaptor is straight forward:\012    // Both architecture specific implementations are supposed to\012    // be interface compatible with this adaptor\012    template<typename X, X& f>\012    class task {\012    public:\012      // using F: typename X is different between compilers!\012      using F = decltype(f);\012      using T = typename ihc::function_traits<F>::return_type;\012\012      // Singleton\012      // Anywhere in the function hierarchy where \"f\" gets called,\012      // this specific task (with the corresponding thread and queue)\012      // needs to be used\012      static task& instance() {\012        static task t;\012        return t;\012      }\012\012      // Launch the callable\012      template<typename ... Args>\012      void launch(Args&& ... args) {\012        return _t.launch(std::forward<Args>(args)...);\012      }\012\012      // Get the result\012      T collect() {\012        // Restore void if needed\012        return static_cast<T>(_t.collect());\012      }\012\012    private:\012      // Constructor\012      task() {};\012      // Destructor\012      // Can't be explicit for FPGA target in Intel(R) HLS Compiler\012      //~_task() {}\012\012      // Composition (_task is architecture specific)\012      internal::_task<X, f> _t;\012\012    }; // class task\012\012    // Launch (through singleton)\012    template< class X, X&  f, typename... Args>\012    void launch(Args&&... args) {\012#if defined(__INTELFPGA_COMPILER__)  && !defined(HLS_X86)\012      internal::_task<X, f> _t;\012      _t.launch(std::forward<Args>(args)...);\012#else\012      task<X, f>::instance().launch(std::forward<Args>(args)...);\012#endif\012    }\012\012    // Collect (through singleton)\012    template< typename X, X& f>\012    typename ihc::function_traits<decltype(f)>::return_type collect() {\012      // using F: typename X is different between compilers!\012      using F = decltype(f);\012      using T = typename ihc::function_traits<F>::return_type;\012      // Restore void if needed\012#if defined(__INTELFPGA_COMPILER__)  && !defined(HLS_X86)\012      internal::_task<X, f> _t;\012      return static_cast<T>(_t.collect());\012#else\012      return static_cast<T>(task<X, f>::instance().collect());\012#endif\012    }\012  } // namespace internal\012\012  // Fake functions to help with Content Assist (IntelliSense)\012\012  // /!\\ Please remember to put parens around a launch of \012  //     a templated function:\012  //     ihc::launch(\012  //       ( foo<Types...> ),\012  //       args... );\012  template<typename F, typename... Args>\012  void launch(F&& f, Args&&...args);\012  template<typename F>\012  typename ihc::function_traits<F>::return_type collect(F&& f);\012\012} // namespace ihc\012\012// Work around for C++14 (no support for <auto& f>\012#define launch(x, ...)  internal::launch<decltype(x),x>(__VA_ARGS__)\012#define collect(x)      internal::collect<decltype(x),x>()\012\012#endif // _INTEL_IHC_HLS_TASK\012"}, {"path":"vx_types.h", "name":"vx_types.h", "has_active_debug_locs":false, "absName":"/home/angelica/Documents/HLS/HiFlipVX_Intel_FPGA/vx_types.h", "content":"/**\012* Copyright (c) 2012-2017 The Khronos Group Inc.\012*\012* Licensed under the Apache License, Version 2.0 (the \"License\");\012* you may not use this file except in compliance with the License.\012* You may obtain a copy of the License at\012*\012*    http://www.apache.org/licenses/LICENSE-2.0\012*\012* Unless required by applicable law or agreed to in writing, software\012* distributed under the License is distributed on an \"AS IS\" BASIS,\012* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\012* See the License for the specific language governing permissions and\012* limitations under the License.\012*/\012\012#ifndef _OPENVX_TYPES_H_\012#define _OPENVX_TYPES_H_\012\012/*!\012* \\file vx_types.h\012* \\brief The type definitions required by OpenVX Library.\012*/\012\012#include <stdint.h>\012\012/*********************************************************************************************************************/\012/* OpenVX Macros */\012/*********************************************************************************************************************/\012\012/*! \\def VX_DF_IMAGE\012* \\brief Converts a set of four chars into a \\c uint32_t container of a VX_DF_IMAGE code.\012* \\note Use a <tt>\\ref vx_df_image</tt> variable to hold the value.\012* \\ingroup group_basic_features\012*/\012#define VX_DF_IMAGE(a,b,c,d)                  ((a) | (b << 8) | (c << 16) | (d << 24))\012\012/*! \\def VX_ATTRIBUTE_BASE\012* \\brief Defines the manner in which to combine the Vendor and Object IDs to get\012* the base value of the enumeration.\012* \\ingroup group_basic_features\012*/\012#define VX_ATTRIBUTE_BASE(vendor, object)   (((vendor) << 20) | (object << 8))\012\012/*! \\def VX_ENUM_BASE\012* \\brief Defines the manner in which to combine the Vendor and Object IDs to get\012* the base value of the enumeration.\012* \\details From any enumerated value (with exceptions), the vendor, and enumeration\012* type should be extractable. Those types that are exceptions are\012* <tt>\\ref vx_vendor_id_e</tt>, <tt>\\ref vx_type_e</tt>, <tt>\\ref vx_enum_e</tt>, <tt>\\ref vx_df_image_e</tt>, and \\c vx_bool.\012* \\ingroup group_basic_features\012*/\012#define VX_ENUM_BASE(vendor, id)            (((vendor) << 20) | (id << 12)) \012\012/*********************************************************************************************************************/\012/* OpenVX typedefs */\012/*********************************************************************************************************************/\012\012/*! \\brief An 8 bit ASCII character.\012* \\ingroup group_basic_features\012*/\012typedef char     vx_char;\012\012/*! \\brief An 8-bit unsigned value.\012* \\ingroup group_basic_features\012*/\012typedef uint8_t  vx_uint8;\012\012/*! \\brief A 16-bit unsigned value.\012* \\ingroup group_basic_features\012*/\012typedef uint16_t vx_uint16;\012\012/*! \\brief A 32-bit unsigned value.\012* \\ingroup group_basic_features\012*/\012typedef uint32_t vx_uint32;\012\012/*! \\brief A 64-bit unsigned value.\012* \\ingroup group_basic_features\012*/\012typedef uint64_t vx_uint64;\012\012/*! \\brief An 8-bit signed value.\012* \\ingroup group_basic_features\012*/\012typedef int8_t   vx_int8;\012\012/*! \\brief A 16-bit signed value.\012* \\ingroup group_basic_features\012*/\012typedef int16_t  vx_int16;\012\012/*! \\brief A 32-bit signed value.\012* \\ingroup group_basic_features\012*/\012typedef int32_t  vx_int32;\012\012/*! \\brief A 64-bit signed value.\012* \\ingroup group_basic_features\012*/\012typedef int64_t  vx_int64;\012\012/*! \\brief A 32-bit float value.\012* \\ingroup group_basic_features\012*/\012typedef float    vx_float32;\012\012/*! \\brief A 64-bit float value (aka double).\012* \\ingroup group_basic_features\012*/\012typedef double   vx_float64;\012\012/*! \\brief Sets the standard enumeration type size to be a fixed quantity.\012* \\details All enumerable fields must use this type as the container to\012* enforce enumeration ranges and sizeof() operations.\012* \\ingroup group_basic_features\012*/\012typedef int32_t vx_enum;\012\012/*! \\brief A wrapper of <tt>size_t</tt> to keep the naming convention uniform.\012* \\ingroup group_basic_features\012*/\012typedef size_t vx_size;\012\012/*! \\brief Used to hold a VX_DF_IMAGE code to describe the pixel format and color space.\012* \\ingroup group_basic_features\012*/\012typedef uint32_t vx_df_image;\012\012/*! \\brief A Boolean value.\012* This allows 0 to be FALSE, as it is in C, and any non-zero to be TRUE.\012* \\code\012* vx_bool ret = vx_true_e;\012* if (ret) printf(\"true!\\n\");\012* ret = vx_false_e;\012* if (!ret) printf(\"false!\\n\");\012* \\endcode\012* This would print both strings.\012* \\ingroup group_basic_features\012*/\012typedef enum _vx_bool_e {\012	/*! \\brief The \"false\" value. */\012	vx_false_e = 0,\012	/*! \\brief The \"true\" value. */\012	vx_true_e,\012} vx_bool;\012\012/*! \\brief The type enumeration lists all the known types in OpenVX.\012* \\ingroup group_basic_features\012*/\012enum vx_type_e {\012	VX_TYPE_INVALID = 0x000,/*!< \\brief An invalid type value. When passed an error must be returned. */\012	VX_TYPE_CHAR = 0x001,/*!< \\brief A <tt>\\ref vx_char</tt>. */\012	VX_TYPE_INT8 = 0x002,/*!< \\brief A <tt>\\ref vx_int8</tt>. */\012	VX_TYPE_UINT8 = 0x003,/*!< \\brief A <tt>\\ref vx_uint8</tt>. */\012	VX_TYPE_INT16 = 0x004,/*!< \\brief A <tt>\\ref vx_int16</tt>. */\012	VX_TYPE_UINT16 = 0x005,/*!< \\brief A <tt>\\ref vx_uint16</tt>. */\012	VX_TYPE_INT32 = 0x006,/*!< \\brief A <tt>\\ref vx_int32</tt>. */\012	VX_TYPE_UINT32 = 0x007,/*!< \\brief A <tt>\\ref vx_uint32</tt>. */\012	VX_TYPE_INT64 = 0x008,/*!< \\brief A <tt>\\ref vx_int64</tt>. */\012	VX_TYPE_UINT64 = 0x009,/*!< \\brief A <tt>\\ref vx_uint64</tt>. */\012	VX_TYPE_FLOAT32 = 0x00A,/*!< \\brief A <tt>\\ref vx_float32</tt>. */\012	VX_TYPE_FLOAT64 = 0x00B,/*!< \\brief A <tt>\\ref vx_float64</tt>. */\012	VX_TYPE_ENUM = 0x00C,/*!< \\brief A <tt>\\ref vx_enum</tt>. Equivalent in size to a <tt>\\ref vx_int32</tt>. */\012	VX_TYPE_SIZE = 0x00D,/*!< \\brief A <tt>\\ref vx_size</tt>. */\012	VX_TYPE_DF_IMAGE = 0x00E,/*!< \\brief A <tt>\\ref vx_df_image</tt>. */\012	VX_TYPE_BOOL = 0x010,/*!< \\brief A <tt>\\ref vx_bool</tt>. */\012};\012\012/*********************************************************************************************************************/\012/* OpenVX enums (TODO: Change Vendor ID) */\012/*********************************************************************************************************************/\012\012/*! \\brief The Vendor ID of the Implementation. As new vendors submit their\012* implementations, this enumeration will grow.\012* \\ingroup group_basic_features\012*/\012enum vx_vendor_id_e {\012	VX_ID_KHRONOS = 0x000, /*!< \\brief The Khronos Group */\012};\012\012/*! \\brief The set of supported enumerations in OpenVX.\012* \\details These can be extracted from enumerated values using <tt>\\ref VX_ENUM_TYPE</tt>.\012* \\ingroup group_basic_features\012*/\012enum vx_enum_e {\012	VX_ENUM_INTERPOLATION = 0x04, /*!< \\brief Interpolation Types. */\012	VX_ENUM_CONVERT_POLICY = 0x0A, /*!< \\brief Convert Policy. */\012	VX_ENUM_THRESHOLD_TYPE = 0x0B, /*!< \\brief Threshold Type List. */\012	VX_ENUM_BORDER = 0x0C, /*!< \\brief Border Mode List. */\012	VX_ENUM_ROUND_POLICY = 0x12, /*!< \\brief Rounding Policy. */\012};\012\012/*! \\brief The Conversion Policy Enumeration.\012* \\ingroup group_basic_features\012*/\012enum vx_convert_policy_e {\012	/*! \\brief Results are the least significant bits of the output operand, as if\012	* stored in two's complement binary format in the size of its bit-depth.\012	*/\012	VX_CONVERT_POLICY_WRAP = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_CONVERT_POLICY) + 0x0,\012	/*! \\brief Results are saturated to the bit depth of the output operand. */\012	VX_CONVERT_POLICY_SATURATE = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_CONVERT_POLICY) + 0x1,\012};\012\012/*! \\brief Based on the VX_DF_IMAGE definition.\012* \\note Use <tt>\\ref vx_df_image</tt> to contain these values.\012* \\ingroup group_basic_features\012*/\012enum vx_df_image_e {\012	/*! \\brief A single plane of 24-bit pixel as 3 interleaved 8-bit units of\012	* R then G then B data. This uses the BT709 full range by default.\012	*/\012	VX_DF_IMAGE_RGB = VX_DF_IMAGE('R', 'G', 'B', '2'),\012	/*! \\brief A single plane of 32-bit pixel as 4 interleaved 8-bit units of\012	* R then G then B data, then a <i>don't care</i> byte.\012	* This uses the BT709 full range by default.\012	*/\012	VX_DF_IMAGE_RGBX = VX_DF_IMAGE('R', 'G', 'B', 'A'),\012	/*! \\brief A single plane of unsigned 8-bit data.\012	* The range of data is not specified, as it may be extracted from a YUV or\012	* generated.\012	*/\012	VX_DF_IMAGE_U8 = VX_DF_IMAGE('U', '0', '0', '8'),\012	/*! \\brief A single plane of unsigned 8-bit data.\012	* The range of data is not specified, as it may be extracted from a YUV or\012	* generated.\012	*/\012	VX_DF_IMAGE_S8 = VX_DF_IMAGE('S', '0', '0', '8'),\012	/*! \\brief A single plane of signed 16-bit data.\012	* The range of data is not specified, as it may be extracted from a YUV or\012	* generated.\012	*/\012	VX_DF_IMAGE_U16 = VX_DF_IMAGE('U', '0', '1', '6'),\012	/*! \\brief A single plane of signed 16-bit data.\012	* The range of data is not specified, as it may be extracted from a YUV or\012	* generated.\012	*/\012	VX_DF_IMAGE_S16 = VX_DF_IMAGE('S', '0', '1', '6'),\012	/*! \\brief A single plane of unsigned 32-bit data.\012	* The range of data is not specified, as it may be extracted from a YUV or\012	* generated.\012	*/\012	VX_DF_IMAGE_U32 = VX_DF_IMAGE('U', '0', '3', '2'),\012	/*! \\brief A single plane of unsigned 32-bit data.\012	* The range of data is not specified, as it may be extracted from a YUV or\012	* generated.\012	*/\012	VX_DF_IMAGE_S32 = VX_DF_IMAGE('S', '0', '3', '2'),\012};\012\012/*! \\brief The Threshold types.\012* \\ingroup group_threshold\012*/\012enum vx_threshold_type_e {\012	/*! \\brief A threshold with only 1 value. */\012	VX_THRESHOLD_TYPE_BINARY = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_THRESHOLD_TYPE) + 0x0,\012	/*! \\brief A threshold with 2 values (upper/lower). Use with Canny Edge Detection. */\012	VX_THRESHOLD_TYPE_RANGE = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_THRESHOLD_TYPE) + 0x1,\012};\012\012/*! \\brief The image reconstruction filters supported by image resampling operations.\012*\012* The edge of a pixel is interpreted as being aligned to the edge of the image.\012* The value for an output pixel is evaluated at the center of that pixel.\012*\012* This means, for example, that an even enlargement of a factor of two in nearest-neighbor\012* interpolation will replicate every source pixel into a 2x2 quad in the destination, and that\012* an even shrink by a factor of two in bilinear interpolation will create each destination pixel\012* by average a 2x2 quad of source pixels.\012*\012* Samples that cross the boundary of the source image have values determined by the border\012* mode - see <tt>\\ref vx_border_e</tt> and <tt>\\ref VX_NODE_BORDER</tt>.\012* \\see vxuScaleImage\012* \\see vxScaleImageNode\012* \\see VX_KERNEL_SCALE_IMAGE\012* \\see vxuWarpAffine\012* \\see vxWarpAffineNode\012* \\see VX_KERNEL_WARP_AFFINE\012* \\see vxuWarpPerspective\012* \\see vxWarpPerspectiveNode\012* \\see VX_KERNEL_WARP_PERSPECTIVE\012* \\ingroup group_basic_features\012*/\012enum vx_interpolation_type_e {\012	/*! \\brief Output values are defined to match the source pixel whose center is nearest to the sample position. */\012	VX_INTERPOLATION_NEAREST_NEIGHBOR = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_INTERPOLATION) + 0x0,\012	/*! \\brief Output values are defined by bilinear interpolation between the pixels whose centers are closest\012	* to the sample position, weighted linearly by the distance of the sample from the pixel centers. */\012	VX_INTERPOLATION_BILINEAR = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_INTERPOLATION) + 0x1,\012	/*! \\brief Output values are determined by averaging the source pixels whose areas fall under the\012	* area of the destination pixel, projected onto the source image. */\012	VX_INTERPOLATION_AREA = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_INTERPOLATION) + 0x2,\012};\012\012/*! \\brief The border mode list.\012* \\ingroup group_borders\012*/\012enum vx_border_e {\012	/*! \\brief No defined border mode behavior is given. */\012	VX_BORDER_UNDEFINED = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_BORDER) + 0x0,\012	/*! \\brief For nodes that support this behavior, a constant value is\012	* \\e filled-in when accessing out-of-bounds pixels.\012	*/\012	VX_BORDER_CONSTANT = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_BORDER) + 0x1,\012	/*! \\brief For nodes that support this behavior, a replication of the nearest\012	* edge pixels value is given for out-of-bounds pixels.\012	*/\012	VX_BORDER_REPLICATE = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_BORDER) + 0x2,\012};\012\012/*! \\brief The Round Policy Enumeration.\012* \\ingroup group_context\012*/\012enum vx_round_policy_e {\012	/*! \\brief When scaling, this truncates the least significant values that are lost in operations. */\012	VX_ROUND_POLICY_TO_ZERO = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_ROUND_POLICY) + 0x1,\012	/*! \\brief When scaling, this rounds to nearest even output value. */\012	VX_ROUND_POLICY_TO_NEAREST_EVEN = VX_ENUM_BASE(VX_ID_KHRONOS, VX_ENUM_ROUND_POLICY) + 0x2,\012};\012\012/*! \\brief The 2D Coordinates structure. HINT: Updated by template parameter\012* \\ingroup group_basic_features\012*/\012template<typename T>\012struct vx_coordinates2d_t {\012	T x;    /*!< \\brief The X coordinate. */\012	T y;    /*!< \\brief The Y coordinate. */\012};\012\012#endif\012"}];